#!/usr/bin/perl -w
#
# $Id$
#
# Fetch UK television listings from the data provided by ananova.com.
#
# See release notes and/or cvs logs entries for module history
#
# -- Ed Avis, epa98@doc.ic.ac.uk
#

use strict;
use LWP::Simple;
use Getopt::Long;
use Tie::IxHash;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Date::Manip;
use UK_TZ;
use XMLTV;
use Tie::RefHash;
use Term::ProgressBar;
use Ananova_Channel;

# Prototype declarations
sub check_ananova_blurb();
sub get_regions();
sub get_dir();
sub read_channels_page();
sub usage();
sub get_file($$$);
sub date_programmes($$);
sub add_clumpidx($);
sub get_channel_pkgs();
sub init_channels();
sub write_channels($);
sub wanted_by_region($);

# PHP page provided by Ananova to access their internal listings data.
# This is used as an inital substring of all the URLs gotten by this
# program.
#
my $A = 'http://www.ananova.com/tv_listings/_tv_raw.php';

# On Windows Date::Manip can have trouble finding the local timezone.
# Since the output listings shouldn't depend on the local timezone
# anyway, we just set it here.
#
Date_Init('TZ=UT');

# Things will go horribly wrong if Ananova change pages from one day
# to the next while the script is running.  Assume they do it at
# midnight.
#
my $today = ParseDate('today'); die if not defined $today;
END {
    if (UnixDate(ParseDate('today'), '%Q') ne UnixDate($today, '%Q')) {
	warn "current day has changed, results may be messed up\n";
    }
}

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

# Check options.
my ($opt_days, $opt_help, $opt_cache);
GetOptions('days=i' => \$opt_days, 'help' => \$opt_help, 'cache:s' => \$opt_cache);
if ($opt_help) {
    print <<END
$0: get UK television listings in XMLTV format

The options available depend on what data is at the server.  Run with
no arguments to get a usage message and a default set of listings (7
days, London region).  It will write the listings to stdout, so
redirect it to a file.
END
  ;
    exit(1);
}

if (defined $opt_cache) {
    # Undocumented option to speed up debugging (and reduce server
    # load).  Previous versions of getlistings_uk_ananova used Memoize
    # all over the place, but this program doesn't have as many
    # side-effect-free routines.  Many of the subs are self-memoizing
    # in that they update a global hash; others are run once and
    # return a hash.
    #
    if ($opt_cache eq '') {
	$opt_cache = "$0.cache";
    }
    print STDERR "using cache $opt_cache\n";
    require POSIX;
    require Memoize;
    Memoize::memoize('get',
		     SCALAR_CACHE => [ 'TIE', 'DB_File', $opt_cache,
				       POSIX::O_RDWR() | POSIX::O_CREAT(),
				       0666 ]);
}

# The date libraries, however, do benefit from memoization.  It's only
# about an 8% speed increase for the program as a whole, but worth it.
#
use Memoize;
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly\n";
}
else {
     foreach (qw(parse_uk_date ParseDate UnixDate DateCalc Date_Cmp
		 ParseDateDelta)) {
	 Memoize::memoize($_) or warn "cannot memoize $_";
     }
}

my $bar = new Term::ProgressBar('getting list of channels', 4);
my $copyright = check_ananova_blurb(); update $bar;

# Set up an XMLTV::Writer; print copyright and start of document.
# Ananova's data is in Latin-1.
#
my $writer = new XMLTV::Writer(encoding => 'ISO-8859-1');
$writer->comment($copyright);
$writer->start({ 'source-info-url'     =>
	  'http://www.ananova.com/tv_listings/_tv_full_listings.html',
	         'source-info-name'    => 'Ananova',
	         'source-data-url'     => $A,
	         'generator-info-name' => 'XMLTV/0.4',
	         'generator-info-url'  =>
	  'http://www.doc.ic.ac.uk/~epa98/work/apps/xmltv/',
	       });

my $regions = get_regions(); update $bar;
#t 'regions: ' . d $regions;

init_channels();
read_channels_page(); update $bar;

# Hardcoded channel packages.  It is planned to move these to separate
# files, but I didn't have time to reorganize the directory structure
# before the 0.4 release.
#
my %channel_pkgs = get_channel_pkgs();

# We've set the type of 'radio' and 'satellite' channels.  Now deal
# with the terrestrial channels, which have a region set.  We should
# find that every channel fits into radio, xor satellite, xor one
# particular region.
#
# We end up with a list of [ day, type, channel, filename ], where
# type is one of 'radio', 'satellite', or a region code.
#
my @files;

my %seen_ch;
foreach (get_dir()) {
#    local $Log::TraceMessages::On = 1;
    my ($orig, $day, $ananova_id, $region) = @$_;
    t 'got line from dir: orig=' . d($orig) . ', day=' . d($day) . ', ananova_id=' . d($ananova_id) . ', region=' . d($region);
    my $ch = Channel->find_by_ananova_id($ananova_id);
    t 'found channel by Ananova id: ' . d $ch;
    if (not defined $ch) {
	t 'creating a new channel and adding id';
	$ch = new Channel();
	$ch->add_ananova_id($ananova_id);
    }
    $seen_ch{$ch}++; # no dup check, since multiple days

    # If channel not seen before, assume terrestrial.
    my $type = $ch->get_type();
    $type = 'terrestrial' if not defined $type;
    my $has_region = (defined $region);

    if ($type eq 'terrestrial') {
	if ($has_region) {
	    $ch->add_region($region);
	    push @files, [ $day, $region, $ananova_id, $orig ];
	}
	else {
	    # Probably an old file which is still lying around in dir.
	    # We don't bother with these.
	    #
	    $type = 'duff';
	}
    }
    elsif ($type eq 'satellite' or $type eq 'radio') {
	if ($has_region) {
	    warn 'channel ' . $ch->stringify() . " was seen as $type but also region $region";
	}
	else {
	    push @files, [ $day, $type, $ananova_id, $orig ];
	}
    }
    elsif ($type eq 'duff') {
	# Ignore.
    }
    else { die "bad type $type" }
    $ch->set_type($type);
}
t 'files: ' . d \@files;
update $bar;

# Check that there are no redundant entries in the channel data.
foreach (Channel->all()) {
    unless ($seen_ch{$_}) {
	warn "channels data mentions channel $_, but not used\n";
	$_->set_type('duff');
    }
}

# Now work out which of @files we actually want to download.  We can
# pick channels in three ways: by type ('radio', 'satellite'), by
# Ananova region ('15', '2' with display names like 'Carlton', 'Tyne
# Tees') and individually by XMLTV id.
#
my (%wanted_type, %wanted_region, %wanted_xmltv_id);
my $want_all;
my %type_display;
$type_display{$_} = $_ foreach qw(radio satellite);
my %region_display = reverse %$regions;
if (defined $ARGV[0] and $ARGV[0] eq 'ALL') {
    $want_all = 1;
}
else {
#    local $Log::TraceMessages::On = 1;
    foreach my $arg (@ARGV) {
	t "working out arg $arg";
	my $larg = lc $arg;
	my $t;

	# See whether the argument matches a type.  We look for an
	# exact match and if not that then a regexp match.
	#
	foreach (sort keys %type_display) {
	    my $ldn = lc $type_display{$_};
	    if ($ldn eq $larg) {
		$t = $_;
		last;
	    }
	    elsif (not defined $t and index($ldn, $larg) != -1) {
		$t = $_;
	    }
	}
	if (defined $t) {
	    print STDERR "getting channel type $type_display{$t}\n";
	    $wanted_type{$t}++
	      && warn "channel type $type_display{$t} mentioned twice\n";
	    next;
	}

	# Or a terrestrial region.
	foreach (sort keys %region_display) {
	    my $ldn = lc $region_display{$_};
	    if ($ldn eq $larg) {
		$t = $_;
		last;
	    }
	    elsif (not defined $t and index($ldn, $larg) != -1) {
		$t = $_;
	    }
	}
	if (defined $t) {
	    print STDERR "getting terrestrial region $region_display{$t}\n";
	    $wanted_region{$t}++
	      && warn "terrestrial region $region_display{$t} mentioned twice\n";
	    next;
	}
	
	# Nothing so far, but maybe it matches a channel package.
	foreach (sort keys %channel_pkgs) {
	    # Exact match only since they're computery names.
	    if ($_ eq $arg) {
		$t = $_;
		last;
	    }
	}
	if (defined $t) {
	    print STDERR "getting channel package $t\n";
	    foreach (@{$channel_pkgs{$t}}) {
		t "setting wanted XMLTV id $_";
		++ $wanted_xmltv_id{$_};
	    }
	    next;
	}

	# Finally, perhaps it matches the name of a channel.
	my $found_dn;
	foreach (Channel->all()) {
	    next if $_->get_type() eq 'duff';
	    my $dn = $_->get_a_display_name();
	    next if not defined $dn;
	    my $ldn = lc $dn;
	    my $xmltv_id = $_->get_xmltv_id();
	    die if not defined $xmltv_id;

	    if ($ldn eq $larg) {
		$t = $xmltv_id;
		$found_dn = $dn;
		last;
	    }
	    elsif (not defined $t and index($ldn, $larg) != -1) {
		$t = $xmltv_id;
		$found_dn = $dn;
	    }
	}
	if (defined $t) {
	    print STDERR "getting channel $found_dn\n";
	    $wanted_xmltv_id{$t}++
	      && warn "channel with XMLTV id $t already chosen";
	    next;
	}
	
	if (not defined $t) {
	    warn "'$arg' does not match any known channel type, package or channel\n";
	    usage();
	}
    }
    if (not keys %wanted_type
	and not keys %wanted_region
	and not keys %wanted_xmltv_id) {
	if (not @ARGV) {
	# Fall back on default region 'carlton'.
	    my $chosen;
	    foreach (sort keys %region_display) {
		if ($region_display{$_} =~ /\Qcarlton\E/i) {
		    print STDERR "getting terrestrial region $region_display{$_}\n";
		    $wanted_region{$_}++;
		    $chosen = $_;
		    last;
		}
	    }
	    if (defined $chosen) {
		warn "no channel types, packages or channels given, assuming $region_display{$chosen}\n";
		usage();
	    } else {
		warn "no channel types, packages or channels given and default 'carlton' not found, "
		  . "giving up\n";
		usage();
		exit(1);
	    }
	}
	else {
	    warn "nothing to download\n";
	    # But we'll let it print an empty file anyway...
	}
    }
}

# There used to be a warning that if you chose 'satellite' you'd need
# to also pick a terrestrial region to get channels like BBC1.  This
# is no longer the case since Ananova now has listings for BBC1
# Digital and so on.  Besides, with the new channel packages
# 'satellite' will probably not be used much.
#

# Filter out the files we want to download - those with the correct
# channel type, region or channel id.
#
my @new_files;
t 'deciding which files to download';
my %used_xmltv_id;
foreach (@files) {
#    local $Log::TraceMessages::On = 1;
    t 'looking at file: ' . d $_;
    if (defined $opt_days and $opt_days < $_->[0]) {
	t 'outside the --days range';
	next;
    }

    if ($want_all) {
	t 'want all files, so want this one';
	push @new_files, $_;
	next;
    }

    my $tor = $_->[1];
    t "type or region: $tor";
    if ($wanted_type{$tor} or $wanted_region{$tor}) {
	t 'want this type or region';
	push @new_files, $_;
	next;
    }

    my $ch = Channel->find_by_ananova_id($_->[2]);
    t 'looked up by Ananova id: ' . d $ch;
    if (defined $ch) {
	my $xmltv_id = $ch->get_xmltv_id();
	t 'channel has XMLTV id: ' . d $xmltv_id;
	if (defined $xmltv_id) {
	    if ($wanted_xmltv_id{$xmltv_id}) {
		t 'this id is wanted';

		# But the same id may be available as two different
		# files.  We want only the first Ananova set of pages
		# for this channel.
		#
		if ($ch->get_first_ananova_id() eq $_->[2]) {
		    t 'is first Ananova id, adding';
		    push @new_files, $_;
		    $used_xmltv_id{$xmltv_id}++;
		    next;
		}
		else {
		    t 'a secondary Ananova page for this channel, not adding';
		}
	    }
	}
    }
}
@files = @new_files;
t 'checking that every wanted XMLTV id was found';
foreach (sort keys %wanted_xmltv_id) {
    next if $used_xmltv_id{$_};
    my $ch = Channel->find_by_xmltv_id($_);
    die if not defined $ch;
    warn 'channel ' . $ch->stringify() . ' not found on site';
}

# We want to get them in day order, so that we can get the first day's
# listings first.  This is becuase we need to get a complete day to
# get the complete channel information, which must be written out
# before any programmes.
#
$bar = new Term::ProgressBar('downloading listings', scalar @files);
my $first_day;
my $wrote_channels = 0;
my @progs_todo;
foreach (sort { $a->[0] <=> $b->[0] } @files) {
    my ($day, $type, $ananova_id, $filename) = @$_;
    t "getting file for day $day, type $type, Ananova id $ananova_id, filename $filename";
    die if defined $opt_days and $day > $opt_days;
    $first_day = $day if not defined $first_day;

    # Work out the actual day this number corresponds to: 1 is
    # today.
    #
    my $day_offset = $day-1;
    t 'day offset: ' . d $day_offset;
    my $day_date = DateCalc($today, "+ $day_offset days");
    die if not defined $day_date;

    # Get a list of programmes from this filename, fix the dates and
    # add clumpidxes.
    #
    my $ch = Channel->find_by_ananova_id($ananova_id);
    die if not defined $ch;
    my $progs = get_file($day_date, $ch, $filename);
    date_programmes($progs, $day_date);
    add_clumpidx($progs);

    # Check to see if we have to write channels data first.
    if (not $wrote_channels) {
	if ($day != $first_day) {
	    # Must have done a whole day's listings, channels are ready to
	    # write.
	    #
	    write_channels($writer);
	    $wrote_channels = 1;
	}
    }

    push @progs_todo, @$progs;
    if ($wrote_channels) {
	t 'channels have been written before, write programmes';
	$writer->write_programme($_) foreach @progs_todo;
	@progs_todo = ();
    }

    update $bar;
}

# In case we never got to the second day, make sure the pending stuff
# is written.
#
if (not $wrote_channels) {
    write_channels($writer);
    $writer->write_programme($_) foreach @progs_todo;
    $wrote_channels = 1; @progs_todo = ();
}

# Finish.
$writer->end();
exit();


# Check that the usage message has not changed (if it has, this
# program probably needs changing).  Returns the copyright message.
#
sub check_ananova_blurb() {
    for (get $A) {
	die "cannot get $A" if not defined;

	# Remove cruft and check it looks as expected.
	s/^\s*\#\s*//gm; s/(\s)\s+/$1/g;
	s/
useage: \?show=<request>
where request is one of \[regions\|channels\|dir\|<file>\]
\?show=regions outputs a list of regions and region codes
\?show=channels outputs a list of channel codes and names
\?show=dir outputs the list of currently valid file names.*//s
  or warn "usage message has changed to: $_\n";

	# There should be no need to fix non-ASCII characters since we
	# have set the XMLTV::Writer for Latin-1.
	#

	return $_;
    }
}


# Return a reference to an ordered hash mapping region display name to
# Ananova internal region name.
#
sub get_regions() {
    my $url =  "$A?show=regions";
    (my $data = get $url) or die "cannot get $url";
#    t "got regions page: $data";
    my %r; tie %r, 'Tie::IxHash';
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	if (/^region\.((?:[a-z]+_)?\d+)=(.+)$/) {
	    $r{$2} = $1;
	}
	else {
	    warn "bad line from $url: $_";
	}
    }
    if (not keys %r) {
	warn "couldn't get any region data from $url";
    }
    return \%r;
}


# Get the list of Ananova 'filenames' and parse each filename into a
# tuple of:
#
# [ original filename, day number, channel id, region ]
#
# Region may be undef, and channel id will also contain the region
# details (so that bbc1_2 and bbc1ea_0 are distinct channels).
#
# Returns a list of these tuples (er, listrefs).
#
sub get_dir() {
    local $Log::TraceMessages::On = 0;
    my $url =  "$A?show=dir";
    (my $data = get $url) or die "cannot get $url";
#    t "got dir page: $data";

    my @r;
    my %warned_unknown_region;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	my $orig = $_;

	s/^day(\d+)_// or die "bad Ananova filename $_ (no 'dayX_')";
	my $day = $1;
	my $channel = $_;

	my $region;
	foreach my $r (values %$regions) {
	    if ($r =~ /\D/ && s/$r$//) {
		# Ends with the region code itself.  This isn't
		# applicable if the region code is just a number.
		#
		$region = $r;
		last;
	    }
	    
	    $r =~ /(\d+)$/ or die "bad region code $r";
#	    t "just the number of region: $1";
	    if (/_$1$/) {
		# Ends with _ and just the number of the region.
		$region = $r;
		last;
	    }
	}

	if (not defined $region) {
	    if (/^(?:[a-z]+_)?[a-z0-9]+$/) {
		# No region at all, okay.
	    }
	    else {
		unless ($warned_unknown_region{$_}++) {
		    warn "can't find region for channel id $_\n";
		}
	    }
	}

	push @r, [ $orig, $day, $channel, $region ];
    }
    return @r;
}


# Read Ananova's Channels page.  This tells us about radio and
# satellite channels.
#
sub read_channels_page() {
    local $Log::TraceMessages::On = 0;
    my $url =  "$A?show=channels";
    (my $data = get $url) or die "cannot get $url";
#    t "got channels page: $data";

    my (%type, %display);
    my %seen_display;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	if (/^(radio|satellite)\.([a-z0-9_]+)=(.+)$/) {
	    t 'matched';
	    my ($type, $ananova_id, $display) = ($1, $2, $3);
	    t "type=$type, ch=$ananova_id, display=$display";

	    my $ch = Channel->find_by_ananova_id($ananova_id);
	    $ch = new Channel() if not defined $ch;
	    $ch->set_type($type);
	    $ch->add_ananova_id($ananova_id);

	    # Only set the display name based on the first (ie,
	    # best) Ananova id for this channel.  Otherwise we'd
	    # have a conflict between say 'Border' and 'Border
	    # (Scottish viewers)'.  Only the first of the two should
	    # have a chance to set the display name.
	    #
	    if ($ch->get_first_ananova_id() eq $ananova_id) {
		$ch->set_main_display_name($display, 0);
	    }

	    if ($seen_display{lc $display}++) {
		# Kludge around fact that we _know_ Nickelodeon
		# is wrong: I've reported it but they haven't fixed it
		# yet.
		#
		unless ($display eq 'Nickelodeon') {
		    warn "channel display name $display seen twice";
		}
	    }
	}
	else {
	    warn "bad line in channels listing: $_\n";
	}
    }
}


# Usage message
my $shown_usage = 0;
sub usage() {
    return if $shown_usage++;
    my $msg = <<END
usage: $0 [--days N] channel-spec...

There are three ways to choose which channels to download.  Pick a
terrestrial region or channel type from:

END
;
    $msg .= join(', ', sort values %region_display) . "\n";
    $msg .= join(', ', sort values %type_display) . "\n";
    $msg .= <<END

'radio' means all radio stations and 'satellite' all satellite
channels.  But if you have satellite, you probably want to pick one
or more of the following channel packages:

END
;
    foreach (sort keys %channel_pkgs) {
	my @names;
	foreach (@{$channel_pkgs{$_}}) {
	    my $ch = Channel->find_by_xmltv_id($_);
	    if (defined $ch) {
		push @names, $ch->get_a_display_name();
	    }
	    else {
		warn "channel id $_ mentioned in package, but not known\n";
		push @names, $_;
	    }
	}
        $msg .= "$_: " . join(', ', @names) . "\n\n";
    }

    $msg .= <<END
Or you can specify the names of individual channels directly.

You can abbreviate names by giving a case-insensitive substring, for
example 'Tyne Tees' could be abbreviated to 'tyne'.  The special value
'ALL' means get every available channel, but this gives a very big
output file!
END
  ;
    warn $msg;
}


# Get data for a particular day.
#
# Parameters:
#   date expected in file (in Date::Manip format)
#   Channel object, used to check and set display name
#   'filename'
#   whether the channel name in the file should be used
#
# Returns: reference to list of programme details, or undef if error.
# These won't have proper start and stop times; instead they have a
# 'time' key and you should use date_programmes() or similar to fix up
# the list of programmes afterwards.  Also the channel is not
# included, you should add that to each programme (probably in RFC2838
# style) afterwards.
#
my (%warned_shorter, $warned_wrong_date); # cut down on duplicate warnings
sub get_file($$$) {
    my ($date_expected, $ch, $file) = @_;
    my $url =  "$A?show=$file";

    my $data = get $url; die "cannot get $url" if not defined $data;

    my @lines = split /\n/, $data;
    foreach (@lines) { s/^\s+//; s/\s+$//; s/\#.*// }
    @lines = grep { length } @lines;

    if (not @lines) {
	# No non-comment lines.  This could be because the PHP script
	# is returning 'file not found'.  That happens if you request
	# the directory listing, it contains obsolete files which
	# (wrongly) are still around, and then your request for the
	# file itself is handled by a different box where the file is
	# in fact deleted.
	#
	if ($data =~ /\n\# $file does not exist$/) {
	    warn "file $file does not exist on server, probably should be removed from dir\n";
	    return undef;
	}
	else {
	    warn "cannot get data from $url, returns:\n$data";
	    return undef;
	}
    }

    # Check the date.
    if (not check_page_date((shift @lines), $date_expected)) {
	warn "bad date in $url, skipping";
	return undef;
    }

    # Set the definitive channel name, if not already set.  The
    # channel name can change if the same channel is listed in two
    # places, for example 'Sky Sports 2' and 'Sky Sports 2 (ITV
    # Digital)'.  We could end up grabbing both pages and mapping them
    # to the same channel.  The first name found wins.
    #
    # In practice I expect that soon we'll make sure to grab only one
    # of the two pages: getting both is really just for debugging.
    #

    # Check the channel name is as expected (if we know what the
    # display name should be for this channel).
    #
    my $got_ch_display = shift @lines;
    if (not $ch->has_definitive_display_name()) {
	$ch->set_main_display_name($got_ch_display, 1);
    }

    my $copyright = pop @lines;
    if ($copyright !~ /^\(c\) Copyright/) {
	warn "strange copyright message: $copyright\n";
    }

    if (@lines and $lines[0] =~
	/^There are no listings available for this channel today\|\|/) {
	return [];
    }

    # Right, got that cruft out of the way, each remaining line is a
    # |-separated list of programme details.
    #
    my @r;
    my $prev_time;
    foreach (@lines) {
	my @fields = split /\|/, $_, -1; # toothpicks ahoy!
	my $num_fields = scalar @fields;
	if ($num_fields == 1 and $fields[0] =~ /copyright/i) {
	    next;
	}
	if ($num_fields < 17 or $num_fields >= 22) {
	    warn "wrong number of fields ($num_fields, need 17..21) "
	      . "in line from $url: $_\n";
	    warn "fields are: " . join("\n", @fields) . "\n";
	    warn "skipping line\n";
	    next;
	}
	my ($title, $time, $when, $episode_num, $episode_name, $cast,
	    $director, $duration, $main_desc, $type, $subtitled, $bw,
	    $stereo, $mono, $new, $repeat, $digital)
	  = @fields;
	my %p;

	# In the XMLTV format, title is multivalued, so it needs to be
	# a list.  Furthermore each element is itself a list of
	# [ string, language ].  Many other elements are like this.
	#
	$p{title} = [ [ $title, $LANG ] ];
	
	# The comment from Ananova says that the time is 'probably in
	# time zone existing at 5:00am of the correct file date'.  I
	# assume that means that it might not be, and it might instead
	# have an explicit timezone.  We'll just use the old
	# date-parsing routines to figure out the timezone.
	#
	# That means that for now, we add an element 'time' to the
	# programme details, and later on, date_programmes() turns
	# this into a proper start and stop time.
	#
	if (length $time) {
	    if (not $time =~ /^\d\d?:\d\d$/) {
		warn "bad time '$time' in line from page $url: $_";
		warn "skipping line";
		next;
	    }
	}
	else {
	    # No time was given for this programme.  This is probably
	    # because it's contained in the same 'clump' as the
	    # previous one, for example 'CBBC' at 6:45 is followed in
	    # the listings by 'Teletubbies' without a time.
	    #
	    # For this case, we give the programme the same time as
	    # the previous one.  That's the way it appears in the
	    # Ananova user-visible pages and it's what add_clumpidx()
	    # expects.
	    #
	    if (not defined $prev_time) {
		warn "no time for first line from page $url: $_";
		warn "skipping line";
		next;
	    }
	    $time = $prev_time;
	}

	# For sanity-checking the time against 'when',
	# comparing raw hours and minutes will probably be faster
	# than using Date::Manip.
	#
	$time =~ /^(\d\d?):(\d\d)$/ or die;
	my ($hours, $minutes) = ($1, $2);
	if (length($hours) == 1) {
	    $hours = "0$hours";
	    $time = "$hours:$minutes";
	}
	$p{time} = $time;
	$prev_time = $time;
	
	# The 'when' attribute can be DAYTIME, EVENING or LATENIGHT.
	# It seems a bit redundant to me.  But on the principle that
	# no scrap of information should be thrown away, we check that
	# it's sensible.
	#
	if ($when eq 'DAYTIME') {
	    if (5 <= $hours and $hours < 18) {
		# Daytime is between 05:00 and 18:00.  It overlaps
		# slightly with LATENIGHT.
		#
	    }
	    else {
		warn "time $time is wrongly considered 'DAYTIME' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'EVENING') {
	    if (18 <= $hours) {
		# Evening is from 18:00 until midnight.
	    }
	    else {
		warn "time $time is wrongly considered 'EVENING' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'LATENIGHT') {
	    # Latenight is until 07:00 (or sometimes a programme just
	    # beginning at that time is still latenight).  Annoyingly,
	    # 23:59 is also counted as latenight, so we'll say it runs
	    # from 23:00 to 07:00.
	    #
	    if (23 <= $hours
		or $hours < 7
		or ($hours == 7 and $minutes == 0)) {
		# Okay.
	    }
	    else {
		warn "time $time is wrongly considered 'LATENIGHT' "
		  . "in line from url $url: $_\n";
	    }
	}
	else {
	    warn "unknown 'when' specifier $when "
	      . "in line from url $url: $_";
	}

	# Episode number.
	if (length $episode_num) {
	    if ($episode_num =~ m!^[0-9/]+$!) {
		# Assume that Ananova numbers episodes from 1; but
		# XMLTV - like all good languages - counts from 0.
		#
		$episode_num =~ s/^(\d+)/$1 - 1/e;

		# We don't know the series or season.
		$p{'episode-num'} = [ ". . $episode_num", 'xmltv_ns' ];
	    }
	    else {
		warn "bad episode number '$episode_num' "
		  . "in line from url $url: $_";
	    }
	}

	# Epsiode name.  This corresponds to the badly named
	# 'sub-title' in XMLTV.
	#
	if (length $episode_name) {
	    $p{'sub-title'} = [ [ $episode_name, $LANG ] ];
	}

	# Cast.
	if (length $cast) {
	    foreach (split /\s*,\s*/, $cast) {
		push @{$p{credits}{actor}}, $_;
	    }
	}

	# Director.
	if (length $director) {
	    foreach (split /\s*,\s*/, $director) {
		push @{$p{credits}{director}}, $_;
	    }
	}
	
	# Ananova's idea of 'duration' is usually the original length
	# of a film - not the length it is shown at on TV.  Now we do
	# have a 'length' element in the XMLTV format, but that's
	# meant for the length _as shown_, just not including adverts
	# or other junk.  So we just discard duration.
	#
	# There is an occasional bug in the site where the duration has
	# what looks like a year stuck three times onto the end.  As
	# in '85 mins1997 1997 1997'.
	#
	$duration =~ s/(\d{4}) \1 \1$//;
	if ($duration ne '' and $duration !~ /^(\d+)\s+(?:mins|minutes)$/) {
	    warn "bad duration $duration "
	      . "in line from url $url: $_";
	}

	# Programme type.
	if (length $type) {
	    foreach (split /\s*,\s*/, $type) {
		# We don't give the language for categories because
		# they are liable to be strange strings like 'chldrn'.
		#
		push @{$p{category}}, [ lc $_ ];
	    }
	}

	# Subtitles.  Assume that when Ananova say this, they mean
	# teletext (I don't know what happens for foreign films with
	# on-screen subtitles).
	#
	if ($subtitled) {
	    # We don't know what language the subtitles are in.  $LANG
	    # sets the language for the descriptions, not the
	    # programmes themselves.
	    #
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	
	# Check 'type' of channel to decide whether video and audio
	# elements need be present.  If $p{video}{present} is false,
	# that means there's definitely no picture; if it's undefined
	# then we don't know yet.
	#
	my $ch_type = $ch->get_type();
	if ($ch_type eq 'terrestrial') {
	    # Terrestrial television.  We can't infer anything from
	    # that, because occasionally programmes are broadcast with
	    # no picture or no sound.
	    #
	}
	elsif ($ch_type eq 'satellite') {
	    # Similar.
	}
	elsif ($ch_type eq 'radio') {
	    $p{video}{present} = 0;
	    $p{audio}{present} = 1;
	}
	elsif ($ch_type eq 'duff') {
	    die "trying to download listings for duff channel";
	}
	else { die "bad type $ch_type for channel $ch" }

	# Black and white - in other words, not colour.
	if ($bw) {
	    if (defined $p{video}{present} and not $p{video}{present}) {
		warn "black-and-white flag set for a programme with no picture";
	    }
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}
	
	# Stereo or mono.
	if (not $stereo and not $mono) {
	    # Just don't set any of the flags.
	}
	else {
	    if (defined $p{audio}{present} and not $p{audio}{present}) {
		warn "stereo information set for a programme with no sound";
	    }
	    $p{audio}{present} = 1;

	    if (not $stereo and $mono) {
		$p{audio}{stereo} = 'mono';
	    }
	    elsif ($stereo and not $mono) {
		$p{audio}{stereo} = 'stereo';
	    }
	    elsif ($stereo and $mono) {
		warn "line in page $url has both stereo and mono: $_";
	    }
	    else { die }
	}

	# Repeat or new.  I don't know whether these are necessarily
	# mutually exclusive - you might have an instant repeat of the
	# first episode of a new series have both.  So I won't bother
	# checking that both are not set.
	#
	if ($repeat) {
	    # 'Repeat' in British TV usually means 'previously shown
	    # on the same channel'.  It has happened that series
	    # transferred from one channel to another got repeated on
	    # the new channel as 'new'.
	    #
	    # However, we can't say this for sure.  Things can be
	    # shown on BBC1 and then 'repeated' on BBC2, for example.
	    # Short of some really ornate system to describe all
	    # different nuances of previously-shown in the file
	    # format, we just have to leave the element empty.
	    #
	    $p{'previously-shown'} = {};
	}
	if ($new) {
	    $p{new} = 1;
	}

	# I don't know what the 'digital' flag is for: Ananova says
	# 'if known to be available on as digital transmission'.  Just
	# ignore it.
	#

	# There is one main description and four additional
	# descriptions with increasing levels of detail.  We
	# sanity-check that they have more or less increasing length.
	#
	my @descs = @fields[17..20];
	foreach my $i (0 .. $#descs) {
	    next if not defined $descs[$i] or not length $descs[$i];
	    foreach my $j ($i+1 .. $#descs) {
		next if not defined $descs[$j] or not length $descs[$j];
		# Sometimes the data really does have shorter text for
		# the supposedly more detailed description.  So we
		# can't check it pedantically.  OTOH this has caught
		# some errors in data input.  So we use a heuristic:
		# the more detailed description should be at least
		# half as long as a less detailed one.
		#
		if (2 * length $descs[$j] < length $descs[$i]) {
		    unless ($warned_shorter{$descs[$j]}{$descs[$i]}++) {
			warn
			  "description $j ($descs[$j]) is much shorter than description $i ($descs[$i]) "
			    . "in line from url $url: $_";
		    }
		}
	    }
	}
	# The most detailed description should be the same as the main
	# description.  Er, except when it is not present at all.
	#
	if (defined $descs[3] and $descs[3] ne '' and $descs[3] ne $main_desc) {
	    warn "description 3 ($descs[3]) isn't the same as main desc ($main_desc) "
	      . "in line from url $url: $_";
	    # Add on the main description so we don't lose it.
	    push @descs, $main_desc;
	}
	my %seen;
	foreach (reverse @descs) {
	    next if $_ eq '';
	    next if $seen{$_}++;
	    push @{$p{desc}}, [ $_, $LANG ];
	}

	# Channel.  By now we know the definitive display name of the
	# channel, so we can call get_xmltv_id().
	#
	$p{channel} = $ch->get_xmltv_id();

	# Source - used for debugging and written out only as a
	# comment in the output.
	#
	$p{source} = $file;

	push @r, \%p;
    }
    return \@r;
}


# check_page_date()
#
# Check the date in a day's listings matches what we expect.
# According to Ananova's comment there's some odd procedure you have
# to follow to make sure it is correct.
#
sub check_page_date($$) {
    my ($got, $expected) = @_;

    if (not $got =~
/^((?:Sun|Mon|Tues|Wednes|Thurs|Fri|Satur)day)\|(\d\d)\|(\d\d)\|(\d\d\d\d)$/)
    {
	warn "bad date '$got'";
	return 0;
    }
    my ($weekday, $dd, $mm, $yyyy) = ($1, $2, $3, $4);
    t "got date: $weekday $yyyy-$mm-$dd";
    my $dp = ParseDate("$yyyy-$mm-$dd");
    if (not defined $dp) {
	warn "bad date '$got'";
	return 0;
    }
    t "parsed out date $dp, check it matches $weekday";
    if (UnixDate($dp, '%A') ne $weekday) {
	# Apparently you have to step backwards by one or two days
	# until the date matches the weekday given.
	#
	my $found = 0;
	foreach (0, 1) {
	    $dp = DateCalc($dp, '- 1 day'); die if not defined $dp;
	    if (UnixDate($dp, '%A') eq $weekday) {
		$found = 1;
		last;
	    }
	}
	if (not $found) {
	    warn "weekday of $got is wrong (even tried going back a couple of days)";
	    return undef;
        }
    }

    # But does it match what we expect?
    if (UnixDate($dp, '%Q') ne UnixDate($expected, '%Q')) {
	if ($opt_cache) {
	    unless ($warned_wrong_date++) {
		warn "since cache is in use, ignoring wrong date in pages\n";
	    }
	}
	else {
	    warn "wrong date in page\n";
	    return 0;
	}
    }

    return 1;
}


# date_programmes()
#
# Given a list of programme details (from extract_progs()) and the date
# of this listing, add proper time and date for each programme.  In UT.
#
# Parameters:
#   reference to list of programme details
#   date in Date::Manip format
#
# Modifies the list passed in, so that each programme no longer has
# {'time'} but has {'start'} instead.  If the programme has
# {'length'}, gets rid of that too and puts in {'stop'}.
#
sub date_programmes($$) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_date) = @_;
    t 'adding date to programmes: ' . d $progs;
    t 'base date: ' . d $base_date;
    my $base_day = UnixDate($base_date, '%Q');
    die if not defined $base_day;
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;

    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my $current_tz = 0; # not undef, because of Memoize complaining

    foreach (@$progs) {
	t('adding date to programme ' . d($_));
	my $t = $_->{'time'};
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	if (defined gettz($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t "found explicit timezone $t, using for future progs";
	    $current_tz = gettz($t);
	}

	t "doing 24h UK time $t with base day $base_day";
	my $prog_date = parse_uk_date("$base_day $t", $current_tz);
	if (not defined $prog_date) {
	    # It's not a valid UK time.  Two reasons for this: it
	    # really isn't, or we're just confused about what day it
	    # is and need to 'jump' forward a day.
	    #
	    t 'that date is bad, maybe need to jump a day?';
	    my $err;
	    my $new_base_day = UnixDate
	      DateCalc($base_day, $day_later, \$err),
	      '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    my $new_prog_date = parse_uk_date("$new_base_day $t", $current_tz);
	    die "bad base day + time '$t' (even tried next day)"
	      if (not defined $new_prog_date) or ($new_prog_date !~ /\S/);
	    t 'okay... assume we will jump a day (do it later)';
	}

	if ((not defined $prog_date)
	    or (defined $prev_date
		and (Date_Cmp($prev_date, $prog_date) > 0) ) )
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day - but see below.
	    #
	    t 'time is lower than before';
	    my $prev_day = UnixDate $prev_date, '%Q';
	    t 'previous programme was at ' . d($prev_date);
	    my $threshold = ParseDate("$prev_day 12:00:00");
	    t 'threshold is ' . d($threshold);
	    if (Date_Cmp($prev_date, $threshold) < 0) {
		# I can't believe that one programme would last from
		# before 12:00 until after midnight on any day.  So
		# this seeming jump to the next day is bogus - it's
		# the same day but the time is a little bit earlier
		# for some reason.  (Probably UT/BST switching)
		#
		t 'previous programme started before threshold, ' .
		  'cannot be next day';
	    }
	    else {
		t 'must be next day';
		my $err;
		$base_day = UnixDate
		  DateCalc($base_day, $day_later, \$err),
		  '%Q';
		die "error from DateCalc(): $err" if defined $err;
		$prog_date = parse_uk_date("$base_day $t", $current_tz);
		die "bad base day + time '$t'"
		  if (not defined $prog_date) or ($prog_date !~ /\S/);
		t 'new base day: ' . d($base_day);
	    }
	}

	delete $_->{'time'};
	$_->{'start'} = $prog_date;
	t 'new start time: ' . d($_->{start});
	$prev_date = $prog_date;

	if (defined(my $length = delete $_->{length})) {
	    # Try to calculate the stop time based on start time and length.
	    if (not defined $_->{stop}) {
		my $stop = DateCalc($_->{start}, "+ $length");
		if (defined $stop) {
		    $_->{stop} = $stop;
		}
		else {
		    warn "could not calculate stop time from $_->{start} + $length";
		}
	    }
	    else {
		warn 'programme has both length and stop';
	    }
	}
    }
}


# add_clumpidx()
#
# Sometimes two programmes on a channel are given the same
# start time in the listings.  This seems to happen when the
# first is a 'mothership' containing several smaller things,
# for example '11:00 The Core, 11:00 Core News'.
#
# We add a 'clumpidx' attribute to distinguish these
# programmes.  Eg 'The Core' has clumpidx '0/2' and 'Core
# News' has '1/2'.
#
# Parameters:
#   a reference to a list of programmes for one channel, which will
#   be modified
#
sub add_clumpidx($) {
    die "usage: add_clumpidx(ref to list of programmes)"
      if @_ != 1;
    my $progs = shift;
    t('add_clumpidx() ENTRY');

    my $last_start;
    my %num_in_clump; # Maps start time to num. progs at that time
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	t '$start=' . d($start);
	$_->{clumpidx} = $num_in_clump{$start}++;
	t 'clumpidx now ' . d($_->{clumpidx});

	if ($num_in_clump{$start} > 1) {
	    if (not defined $last_start or $last_start ne $start) {
		warn <<END
more than one programme at $start on same channel, \
but not consecutive in listings (this is $_->{title})
END
				 ;
	    }
	}
	$last_start = $start;
    }

    # Okay, we've got clumpidx of '0', '1' where needed, but even
    # better would be '0/2', '1/2'.  We look at how many programmes
    # are in each clump: if only one, remove the clumpidx entirely.
    # If more than one, put the full 'x/y' clumpidx.
    #
    t "refine clumpidx's and build todo list";
    my %todo;
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	my $num = $num_in_clump{$start};
	die if not defined $_->{clumpidx};
	if ($num == 1) {
	    # Ordinary, sane programme not sharing its slot.  This
	    # would have a clumpidx of '0/1', which isn't worth
	    # putting in the output.
	    #
	    t 'only programme in slot';
	    die if $_->{clumpidx} ne '0';
	    delete $_->{clumpidx};
	}
	elsif ($num > 1) {
	    t 'shares a slot';
	    $_->{clumpidx} .= "/$num";
	    t 'new clumpidx: ' . d($_->{clumpidx});
	    push @{$todo{$start}}, $_;
	    t "\$todo{$start} now " . d($todo{$start});
	}
	else { die }
    }
    t 'add_clumpidx() EXIT';
}

# Write channels which are used.  We can't write channels which we
# didn't use, because we never downloaded any files for them and so
# never found out what the definitive display name was.  Fortunately,
# writing out channels that weren't used is pointless anyway :-).
#
# Parameter: XMLTV::Writer to use
#
sub write_channels( $ ) {
#    local $Log::TraceMessages::On = 1;
    my $writer = shift;
    my @wanted;
    foreach (Channel->all()) {
	t 'is this channel wanted? : ' . d $_;
	my $type = $_->get_type();
	die "channel $_ has unknown type" if not defined $type;
	if ($want_all
	    or $wanted_type{$type}
	    or $type eq 'terrestrial' and wanted_by_region($_)) {
	    t 'all, or by type, or by region: yes';
	    push @wanted, $_;
	    next;
	}
	
	my $xmltv_id = $_->get_xmltv_id();
	if (defined $xmltv_id and $wanted_xmltv_id{$xmltv_id}) {
	    t 'by XMLTV id, yes';
	    push @wanted, $_;
	    next;
	}
	t 'no';
    }

    my @new_wanted;
    foreach (@wanted) {
	# The XMLTV id and display name should be available by now.
	# If not, something went wrong downloading that channel and it
	# shouldn't be output.
	#
	my $has_xmltv_id = (defined $_->get_xmltv_id());
	my $has_dn = (defined $_->get_main_display_name());

	if (not $has_xmltv_id) {
	    warn 'cannot find or make XMLTV id for channel ' . $_->stringify() . ', not writing';
	    next;
	}

	if (not $has_dn) {
	    warn 'channel ' . $_->stringify() . ' has no display name, not writing';
	    next;
	}

	push @new_wanted, $_;
    }
    foreach (sort { $a->get_xmltv_id() cmp $b->get_xmltv_id() } @new_wanted) {
	$_->write($writer, $LANG);
    }
}
sub wanted_by_region($) {
    my $ch = shift;
    foreach (keys %wanted_region) {
	return 1 if $ch->is_region($_);
    }
    return 0;
}


####
# Channels stuff
#

# In principle it should be possible to find all channel data by
# looking at the Ananova site.  However they don't use the RFC2838
# style names, and I also want to add some extra display names for
# channel numbers.  So there's a hardcoded table listing XMLTV channel
# ids, their equivalent on the Ananova site, and optionally an extra
# (short) display name for that channel.
#
# It can be hard to decide whether two related channels should map to
# the same internal name - eg digital and analogue versions of the
# same channel.  I have made different internal names if I know that
# the content will be different (eg BBC1 digital is different to any
# of the analogue region versions), but otherwise mapped both channels
# to the same internal name.  Sometimes there are annoying small
# differences which require differing internal names, else
# sort_listings complains.  The same applies to regional variants for
# channels which don't differ between regions (eg Channel 5).
#
# Piping the output through sort_listings will check that the two
# versions of a channel are indeed identical.
#
sub init_channels() {
    my %ch_data =
      (
       '1.sports.sky.com'                         => [ [ 'st432' ] ],
       '2-fm.rte.ie'                              => [ [ 'rteradio2' ] ],
       '2.cinema.sky.com'                         => [ [ 'skycinema2' ] ],
       '2.moviemax.sky.com'                       => [ [ 'sky_moviemax2' ] ],
       '2.premier.sky.com'                        => [ [ 'sky_premier2' ] ],
       '2.sports.sky.com'                         => [ [ 'sky_sports2', 'st438' ] ],
       '2.tvtravelshop.co.uk'                     => [ [ 'st422' ] ],
       '3.moviemax.sky.com'                       => [ [ 'sky_moviemax3' ] ],
       '3.premier.sky.com'                        => [ [ 'sky_premier3' ] ],
       '3.sports.sky.com'                         => [ [ 'sky_sports3', 'st436' ] ],
       '4.moviemax.sky.com'                       => [ [ 'sky_moviemax4' ] ],
       '4.premier.sky.com'                        => [ [ 'sky_premier4' ] ],
       '5.moviemax.sky.com'                       => [ [ 'sky_moviemax5' ] ],
       '51.front-row.ntl.com'                     => [ [ 'st179' ] ],
       '52.front-row.ntl.com'                     => [ [ 'st180' ] ],
       '53.front-row.ntl.com'                     => [ [ 'st181' ] ],
       '54.front-row.ntl.com'                     => [ [ 'st182' ] ],
       'adults-only-1.itv.co.uk'                  => [ [ 'adultsonly1' ] ],
       'adults-only-2.itv.co.uk'                  => [ [ 'adultsonly2' ] ],
       'anglia.tv.co.uk'                          => [ [ 'anglia_0' ], 3 ],
       'animalplanet.discoveryeurope.com'         => [ [ 'animalplanetdigital' ] ],
       'artsworld.com'                            => [ [ 'st602' ] ],
       'ary-digital.ary-group.com'                => [ [ 'st617' ] ],
       'asia1tv.com'                              => [ [ 'st612' ] ],
       'asianet-tv.com'                           => [ [ 'asianet' ] ],
       'b4utv.com'                                => [ [ 'st619' ] ],
       'banglatv.com'                             => [ [ 'st613' ] ],
       'base.mtv.co.uk'                           => [ [ 'mtvbase' ] ],
       'bbc1.bbc.co.uk'                           => [ [ 'bbc1_2' ], 1 ],
       'bbc2.bbc.co.uk'                           => [ [ 'bbc2_2' ], 2 ],
       'beti.tv'                                  => [ [ 'st58' ] ],
       'biography-channel.biography.com'          => [ [ 'st474' ] ],
       'bloomberg.com'                            => [ [ 'bloomberg' ], 'Bloomberg' ],
       'blues.musicchoice.co.uk'                  => [ [ 'musicchoiceblues' ] ],
       'boomerang.cartoonnetwork.com'             => [ [ 'st215' ] ],
       'border-tv.com'                            => [ [ 'border_1', 'bordern_17' ], 3 ],
       'box-office-digital.sky.com'               => [ [ 'sky_boxofficedigital' ], 'Sky Box Office' ],
       'bravo.co.uk'                              => [ [ 'bravodigital' ], 'Bravo' ],
       'breeze.granadatv.co.uk'                   => [ [ 'granada_breezeondigital' ], 'Breeze' ],
       'british.eurosport.com'                    => [ [ 'britisheurosport' ], 'Eurosport' ],
       'cable.uk.scifi.com'                       => [ [ 'scificable' ], 'Sci-Fi' ],
       'carlton.com'                              => [ [ 'carlton_16', 'carlton_2' ], 3 ],
       'central.carlton.com'                      => [ [ 'central_3' ], 3 ],
       'challengetv.co.uk'                        => [ [ 'family_channeldigital' ], 'Challenge' ],
       'channel-9.tv-listings.ananova.com'        => [ [ 'st500' ] ],
       'channel-islands.tv-listings.ananova.com'  => [ [ 'channel_4' ] ],
       'channel4.com'                             => [ [ 'ch4_0', 'ch4_1', 'ch4_10', 'ch4_11', 'ch4_12', 'ch4_13', 'ch4_14', 'ch4_15', 'ch4_16', 'ch4_17', 'ch4_2', 'ch4_3', 'ch4_4', 'ch4_5', 'ch4_6', 'ch4_7', 'ch4_8', 'ch4_9' ], 4 ],
       'channel5.co.uk'                           => [ [ 'ch5_0', 'ch5_1', 'ch5_10', 'ch5_11', 'ch5_12', 'ch5_13', 'ch5_14', 'ch5_15', 'ch5_16', 'ch5_17', 'ch5_2', 'ch5_3', 'ch5_4', 'ch5_5', 'ch5_6', 'ch5_7', 'ch5_8', 'ch5_9' ], 5 ],
       'channelhealth.tv'                         => [ [ 'st200' ] ],
       'choice.bbc.co.uk'                         => [ [ 'bbcchoice' ] ],
       'christian-channel-europe.god-digital.com' => [ [ 'christian' ], 'Christian' ],
       'cinema.carlton.com'                       => [ [ 'carltoncinema' ] ],
       'cinema.sky.com'                           => [ [ 'sky_moviesgolddigital' ], 'Sky Cinema' ],
       'civilisations.discoveryeurope.com'        => [ [ 'discoverycivilisations' ] ],
       'classic.vh1online.co.uk'                  => [ [ 'vh1classic' ] ],
       'classical.musicchoice.co.uk'              => [ [ 'musicchoiceclassical' ] ],
       'classicfm.co.uk'                          => [ [ 'classicfm' ] ],
       'country.musicchoice.co.uk'                => [ [ 'musicchoicecountry' ] ],
       'dance.mtv.co.uk'                          => [ [ 'mtvdance' ] ],
       'dance.musicchoice.co.uk'                  => [ [ 'musicchoicedance' ] ],
       'digital.bbc1.bbc.co.uk'                   => [ [ 'bbc1digital' ], 1 ],
       'digital.bbc2.bbc.co.uk'                   => [ [ 'bbc2digital' ], 2 ],
       'digital.ireland.bbc1.bbc.co.uk'           => [ [ 'bbc1irishdigital' ] ],
       'digital.ireland.bbc2.bbc.co.uk'           => [ [ 'bbc2irishdigital' ] ],
       'digital.performancetv.co.uk'              => [ [ 'performancedigital' ] ],
       'digital.s4c.co.uk'                        => [ [ 's4cdigital' ], 'S4C' ],
       'digital.scotland.bbc1.bbc.co.uk'          => [ [ 'bbc1scotdigital' ] ],
       'digital.scotland.bbc2.bbc.co.uk'          => [ [ 'bbc2scotdigital' ] ],
       'digital.uk.scifi.com'                     => [ [ 'scifidigital' ], 'Sci-Fi' ],
       'digital.wales.bbc.co.uk'                  => [ [ 'bbc1walesdigital' ] ],
       'digital.wales.bbc2.bbc.co.uk'             => [ [ 'bbc2walesdigital' ] ],
       'digitalclassics.tv'                       => [ [ 'digitalclassicstv' ] ],
       'discoveryeurope.com'                      => [ [ 'discoverydigital' ], 'Discovery' ],
       'disneychannel.disney.co.uk'               => [ [ 'disney' ], 'Disney' ],
       'e4.channel4.com'                          => [ [ 'e4' ] ],
       'east.bbc1.bbc.co.uk'                      => [ [ 'bbc1ea_0' ], 1 ],
       'east.bbc2.bbc.co.uk'                      => [ [ 'bbc2ea_0' ], 2 ],
       'easy.musicchoice.co.uk'                   => [ [ 'musicchoiceeasy' ] ],
       'einstein.tv'                              => [ [ 'einsteintv' ] ],
       'europe.cnbc.com'                          => [ [ 'cnbc' ], 'CNBC' ],
       'europe.cnn.com'                           => [ [ 'cnn' ] ],
       'eurosport.sky.com'                        => [ [ 'sky_eurosport' ], 'Eurosport' ],
       'extra.sports.sky.com'                     => [ [ 'st437' ] ],
       'extreme.com'                              => [ [ 'extremesports' ] ],
       'extreme.filmfour.channel4.com'            => [ [ 'filmfourextreme' ] ],
       'fantasy.televisionx.co.uk'                => [ [ 'fantasy' ], 'Fantasy' ],
       'filmfour.channel4.com'                    => [ [ 'filmfour' ], 'FilmFour' ],
       'foxkids.co.uk'                            => [ [ 'foxdigital' ], 'Fox Kids' ],
       'front-row.ntl.com'                        => [ [ 'st214' ] ],
       'ftv.com'                                  => [ [ 'fashiontv' ] ],
       'gold.musicchoice.co.uk'                   => [ [ 'musicchoicegold' ] ],
       'grampiantv.co.uk'                         => [ [ 'grampian_5' ], 3 ],
       'granadatv.co.uk'                          => [ [ 'granada_6' ], 3 ],
       'hits.mtv.co.uk'                           => [ [ 'mtvextra' ] ],
       'hits.musicchoice.co.uk'                   => [ [ 'musicchoicehits' ] ],
       'home.discoveryeurope.com'                 => [ [ 'tlcdigital' ], 'Discovery Home' ],
       'ireland.bbc1.bbc.co.uk'                   => [ [ 'bbc1irish_12' ], 1 ],
       'ireland.bbc2.bbc.co.uk'                   => [ [ 'bbc2irish_12' ], 2 ],
       'itn.co.uk'                                => [ [ 'st616' ] ],
       'itv-digital.men.granadatv.co.uk'          => [ [ 'granada_menondigital' ] ],
       'itv2.itv.co.uk'                           => [ [ 'itv2' ] ],
       'itvdigital.moviemax.sky.com'              => [ [ 'sky_moviemaxondigital' ], 'Sky Moviemax' ],
       'jazz.musicchoice.co.uk'                   => [ [ 'musicchoicejazz' ] ],
       'jr.nickelodeon.co.uk'                     => [ [ 'nickelodeonjr' ] ],
       'kids.discoveryeurope.com'                 => [ [ 'discoverykids' ] ],
       'knowledge.bbc.co.uk'                      => [ [ 'bbcknowledge' ], 'BBC Know' ],
       'landmark-travel.tv-listings.ananova.com'  => [ [ 'st66' ] ],
       'landscapetv.com'                          => [ [ 'landscape' ], 'Landscape' ],
       'living.flextech.telewest.co.uk'           => [ [ 'ukliving' ] ],
       'london-live.bbc.co.uk'                    => [ [ 'london_live' ] ],
       'london.bbc1.bbc.co.uk'                    => [ [ 'bbc1london_16' ] ],
       'london.bbc2.bbc.co.uk'                    => [ [ 'tv_724_16' ] ],
       'love.musicchoice.co.uk'                   => [ [ 'musicchoicelove' ] ],
       'lyric-fm.rte.ie'                          => [ [ 'rteradiofm3' ] ],
       'm2europe.com'                             => [ [ 'm2' ] ],
       'men.granadatv.co.uk'                      => [ [ 'granada_men' ], 'Men & Motors' ],
       'meridian.tv.co.uk'                        => [ [ 'meridian_15', 'meridian_9' ], 3 ],
       'midlands.bbc1.bbc.co.uk'                  => [ [ 'bbc1mid_3' ], 1 ],
       'midlands.bbc2.bbc.co.uk'                  => [ [ 'bbc2mid_3' ], 2 ],
       'moviemax.sky.com'                         => [ [ 'sky_movies' ] ],
       'mtv.co.uk'                                => [ [ 'mtv' ] ],
       'mutv.manutd.com'                          => [ [ 'mutv' ] ],
       'nationalgeographic.co.uk'                 => [ [ 'nationalgeographicdigital' ], 'National Geographic' ],
       'news-24.bbc.co.uk'                        => [ [ 'bbcnews24' ] ],
       'news.sports.sky.com'                      => [ [ 'sky_sportsnews' ] ],
       'nickelodeon.co.uk'                        => [ [ 'nickelodeon', 'nickelodeonddigital' ] ],
       'north-east.bbc1.bbc.co.uk'                => [ [ 'bbc1ne_1', 'bbc1ne_11' ], 1 ],
       'north-east.bbc2.bbc.co.uk'                => [ [ 'bbc2ne_1', 'bbc2ne_11' ], 2 ],
       'north-west.bbc1.bbc.co.uk'                => [ [ 'bbc1nw_6' ], 1 ],
       'north-west.bbc2.bbc.co.uk'                => [ [ 'bbc2nw_6' ], 2 ],
       'north.bbc1.bbc.co.uk'                     => [ [ 'bbc1n_14' ], 1 ],
       'north.bbc2.bbc.co.uk'                     => [ [ 'bbc2n_14' ], 2 ],
       'ondigital.premier.sky.com'                => [ [ 'sky_premierondigital' ], 'Sky Premier' ],
       'ondigital.sky-one.sky.com'                => [ [ 'sky_oneondigital' ], 'S1' ],
       'paramountcomedy.com'                      => [ [ 'paramount' ] ],
       'parliament.bbc.co.uk'                     => [ [ 'bbcparliament' ], 'BBC Parl' ],
       'performancetv.co.uk'                      => [ [ 'performance' ] ],
       'play.flextech.telewest.co.uk'             => [ [ 'ukplay' ] ],
       'playboy.com'                              => [ [ 'playboy' ], 'Playboy' ],
       'playhouse.disney.co.uk'                   => [ [ 'st418' ] ],
       'plus-1.discoveryeurope.com'               => [ [ 'discoveryplus1' ], 'Discovery+1' ],
       'plus-1.disneychannel.disney.co.uk'        => [ [ 'st707' ] ],
       'plus-1.filmfour.channel4.com'             => [ [ 'filmfourplus1' ] ],
       'plus-1.foxkids.co.uk'                     => [ [ 'foxplus1' ], 'Fox Kids+1' ],
       'plus-1.home.discoveryeurope.com'          => [ [ 'st701' ] ],
       'plus-1.thehistorychannel.co.uk'           => [ [ 'st702' ] ],
       'plus-1.uk.cartoonnetwork.com'             => [ [ 'st705' ] ],
       'plus.granadatv.co.uk'                     => [ [ 'granada_plus', 'granada_plusondigital' ] ],
       'prime.bbc.com'                            => [ [ 'bbcprime' ] ],
       'qvc1.qvcuk.com'                           => [ [ 'st216' ] ],
       'qvcuk.com'                                => [ [ 'qvc' ] ],
       'racingchannel.com'                        => [ [ 'racing' ], 'Racing' ],
       'radio-1.bbc.co.uk'                        => [ [ 'radio1' ], 'R1' ],
       'radio-1.rte.ie'                           => [ [ 'rteradio1' ] ],
       'radio-2.bbc.co.uk'                        => [ [ 'radio2' ], 'R2' ],
       'radio-3.bbc.co.uk'                        => [ [ 'radio3' ], 'R3' ],
       'radio-4.bbc.co.uk'                        => [ [ 'radio4' ], 'R4' ],
       'radio-5-mw.bbc.co.uk'                     => [ [ 'radio5mw' ], 'R5' ],
       'radio-cymru.bbc.co.uk'                    => [ [ 'cymru' ] ],
       'radio-scotland.bbc.co.uk'                 => [ [ 'radioscotland' ] ],
       'radio-ulster.bbc.co.uk'                   => [ [ 'radioulster' ] ],
       'radio-wales.bbc.co.uk'                    => [ [ 'wales' ] ],
       'red-hot-all-girl.tv-listings.ananova.com' => [ [ 'redhotallgirl' ] ],
       'replay.nickelodeon.co.uk'                 => [ [ 'nickelodeonreplay' ] ],
       'rnag.ie'                                  => [ [ 'nagaeltachta' ] ],
       'rock.musicchoice.co.uk'                   => [ [ 'musicchoicerock' ] ],
       'rte-1.rte.ie'                             => [ [ 'rte1_12' ] ],
       'rte-2.rte.ie'                             => [ [ 'rte2_12' ] ],
       's4c.co.uk'                                => [ [ 's4c_7' ], 'S4C' ],
       'sci-trek.discoveryeurope.com'             => [ [ 'discoveryscitrek' ], 'Sci-Trek' ],
       'scotland.bbc1.bbc.co.uk'                  => [ [ 'bbc1scot_10', 'bbc1scot_17', 'bbc1scot_5' ], 1 ],
       'scotland.bbc2.bbc.co.uk'                  => [ [ 'bbc2scot_10', 'bbc2scot_17', 'bbc2scot_5' ], 2 ],
       'scottishtv.co.uk'                         => [ [ 'scottish_10' ], 3 ],
       'screenshop.co.uk'                         => [ [ 'st615' ] ],
       'setindia.com'                             => [ [ 'sonytv' ], 'SETI' ],
       'shop-america.tv-listings.ananova.com'     => [ [ 'st121' ] ],
       'shop-tv.co.uk'                            => [ [ 'shop' ], 'Shop' ],
       'simplyshoppingtv.co.uk'                   => [ [ 'simplyshopping' ] ],
       'sky-news.sky.com'                         => [ [ 'sky_news' ] ],
       'sky-one.sky.com'                          => [ [ 'sky_channel' ], 'S1' ],
       'sky-premier.sky.com'                      => [ [ 'bsb_movie' ] ],
       'sky-sports-1.sky.com'                     => [ [ 'bsb_sports' ] ],
       'south-east.bbc1.bbc.co.uk'                => [ [ 'bbc1se_15' ], 1 ],
       'south-east.bbc2.bbc.co.uk'                => [ [ 'bbc2se_15' ], 2 ],
       'south-west.bbc1.bbc.co.uk'                => [ [ 'bbc1sw_13', 'bbc1sw_4' ], 1 ],
       'south-west.bbc2.bbc.co.uk'                => [ [ 'bbc2sw_13', 'bbc2sw_4' ], 2 ],
       'south.bbc1.bbc.co.uk'                     => [ [ 'bbc1s_9' ], 1 ],
       'south.bbc2.bbc.co.uk'                     => [ [ 'bbc2s_9' ], 2 ],
       'sport-plus.itv.co.uk'                     => [ [ 'itvsportplus' ], 'ITV Sport Plus' ],
       'sport-select.itv.co.uk'                   => [ [ 'itvsportselect' ] ],
       'sport.itv.co.uk'                          => [ [ 'itvsport' ] ],
       'star-plus.startv.com'                     => [ [ 'st678' ] ],
       'studio.com'                               => [ [ 'st606' ] ],
       'talk-radio.co.uk'                         => [ [ 'talkradiouk' ] ],
       'taratv.net'                               => [ [ 'tara' ] ],
       'tcm.turner.com'                           => [ [ 'tcm' ], 'TCM' ],
       'tg4.ie'                                   => [ [ 'tv83' ] ],
       'theadultchannel.co.uk'                    => [ [ 'adult' ], 'Adult' ],
       'thebox.co.uk'                             => [ [ 'box' ] ],
       'thehistorychannel.co.uk'                  => [ [ 'historydigital' ], 'History' ],
       'todayfm.com'                              => [ [ 'radioireland' ] ],
       'toon.disney.co.uk'                        => [ [ 'st417' ] ],
       'travel.discoveryeurope.com'               => [ [ 'discoverytravel' ] ],
       'travelchannel.co.uk'                      => [ [ 'traveldigital' ], 'Travel' ],
       'trouble.co.uk'                            => [ [ 'troubledigital' ], 'Trouble' ],
       'tttv.granadatv.co.uk'                     => [ [ 'tyne_11' ], 3 ],
       'tv3.ie'                                   => [ [ 'tv84' ] ],
       'tvasia.com'                               => [ [ 'tvasia' ], 'Zee' ],
       'tvtravelshop.co.uk'                       => [ [ 'tvtravelshop' ], 'Travel Shop' ],
       'uk-drama.flextech.telewest.co.uk'         => [ [ 'ukarena' ] ],
       'uk-gold-2.flextech.telewest.co.uk'        => [ [ 'ukgoldclassics' ] ],
       'uk-gold.flextech.telewest.co.uk'          => [ [ 'ukgold' ] ],
       'uk-horizons.flextech.telewest.co.uk'      => [ [ 'ukhorizons' ] ],
       'uk-style.flextech.telewest.co.uk'         => [ [ 'ukstyle' ] ],
       'uk.cartoonnetwork.com'                    => [ [ 'cartoon' ] ],
       'utv.co.uk'                                => [ [ 'ulster_12' ], 3 ],
       'utv2.utv.co.uk'                           => [ [ 'tv452' ] ],
       'vh1online.co.uk'                          => [ [ 'vh1' ] ],
       'virginradio.co.uk'                        => [ [ 'virgin' ] ],
       'wales.bbc1.bbc.co.uk'                     => [ [ 'bbc1wales_7' ], 1 ],
       'wales.bbc2.bbc.co.uk'                     => [ [ 'bbc2wales_7' ], 2 ],
       'wales.htv.co.uk'                          => [ [ 'htvwales_7' ], 3 ],
       'west.bbc1.bbc.co.uk'                      => [ [ 'bbc1w_8' ], 1 ],
       'west.bbc2.bbc.co.uk'                      => [ [ 'bbc2w_8' ], 2 ],
       'west.htv.co.uk'                           => [ [ 'htvwest_8' ], 3 ],
       'westcountry.carlton.com'                  => [ [ 'westcountry_13' ], 3 ],
       'widescreen.premier.sky.com'               => [ [ 'sky_premierwidescreen' ], 'Sky Premier' ],
       'wings.discoveryeurope.com'                => [ [ 'discoverywings' ] ],
       'world-svc.bbc.com'                        => [ [ 'worldsvc' ] ],
       'world-tv.bbc.com'                         => [ [ 'bbcworld' ] ],
       'world.filmfour.channel4.com'              => [ [ 'filmfourworld' ] ],
       'yorkshire.granadatv.co.uk'                => [ [ 'ytv_14' ], 3 ],
      );

    foreach (keys %ch_data) {
	t "initializing channel with id $_";
	my $ch = new Channel();
	$ch->set_xmltv_id($_);
	foreach (@{$ch_data{$_}->[0]}) {
	    t "adding Ananova id $_";
	    $ch->add_ananova_id($_);
	}
	my $extra_display = $ch_data{$_}->[1];
	t 'maybe adding extra display name: ' . d $extra_display;
	$ch->add_extra_display_names($extra_display)
	  if defined $extra_display;
    }
}

# Return a hash mapping package names to lists of XMLTV channel ids.
sub get_channel_pkgs() {
    my %pkgs = (
		# Free digital channels.  The terrestrial analogue
		# versions are not included here because they come
		# under their own region package (eg 'Tyne Tees').  I
		# haven't included BBC1 Ireland, BBC1 Scotland
		# etc. because I don't know whether they're
		# universally available.
		#
		gratis => [qw(
digital.bbc1.bbc.co.uk digital.bbc2.bbc.co.uk carlton.com channel4.com
channel5.co.uk travelchannel.co.uk home.discoveryeurope.com
choice.bbc.co.uk knowledge.bbc.co.uk einstein.tv tcm.turner.com
sky-news.sky.com bloomberg.com news-24.bbc.co.uk parliament.bbc.co.uk
europe.cnn.com itn.co.uk boomerang.cartoonnetwork.com
channelhealth.tv ftv.com extreme.com qvc1.qvcuk.com tvtravelshop.co.uk
2.tvtravelshop.co.uk shop-tv.co.uk screenshop.co.uk
shop-america.tv-listings.ananova.com simplyshoppingtv.co.uk
christian-channel-europe.god-digital.com)],

		musicchoice => [qw(
blues.musicchoice.co.uk classical.musicchoice.co.uk
country.musicchoice.co.uk dance.musicchoice.co.uk
easy.musicchoice.co.uk gold.musicchoice.co.uk hits.musicchoice.co.uk
jazz.musicchoice.co.uk love.musicchoice.co.uk
rock.musicchoice.co.uk)],

		adult => [qw(
theadultchannel.co.uk adults-only-1.itv.co.uk adults-only-2.itv.co.uk
fantasy.televisionx.co.uk playboy.com
red-hot-all-girl.tv-listings.ananova.com)],

		factual => [qw(
animalplanet.discoveryeurope.com knowledge.bbc.co.uk
civilisations.discoveryeurope.com
discoveryeurope.com kids.discoveryeurope.com
plus-1.discoveryeurope.com sci-trek.discoveryeurope.com
travel.discoveryeurope.com wings.discoveryeurope.com einstein.tv
thehistorychannel.co.uk nationalgeographic.co.uk channelhealth.tv
biography-channel.biography.com plus-1.home.discoveryeurope.com
plus-1.thehistorychannel.co.uk home.discoveryeurope.com)],

		news => [qw(
news-24.bbc.co.uk parliament.bbc.co.uk bloomberg.com europe.cnn.com
sky-news.sky.com itn.co.uk)],

		# I couldn't decide what to call this ('ethnic'?)
		# until I realized that all the channels come from the
		# same continent :-).
		#
		asia => [qw(
asianet-tv.com setindia.com asia1tv.com banglatv.com
ary-digital.ary-group.com b4utv.com star-plus.startv.com tvasia.com)],

		sport => [qw(
british.eurosport.com sky-sports-1.sky.com extreme.com sport.itv.co.uk
sport-plus.itv.co.uk sport-select.itv.co.uk mutv.manutd.com
racingchannel.com eurosport.sky.com 2.sports.sky.com 3.sports.sky.com
news.sports.sky.com 1.sports.sky.com 3.sports.sky.com
extra.sports.sky.com 2.sports.sky.com)],

		# Of course actual 'entertainment' is subjective.
		entertainment => [qw(
bravo.co.uk e4.channel4.com
challengetv.co.uk men.granadatv.co.uk itv-digital.men.granadatv.co.uk
plus.granadatv.co.uk itv2.itv.co.uk sky-one.sky.com
ondigital.sky-one.sky.com trouble.co.uk
uk-gold.flextech.telewest.co.uk uk-gold-2.flextech.telewest.co.uk
play.flextech.telewest.co.uk)],

		# 'misc' are just those that didn't fit in elsewhere.
		misc => [qw(
prime.bbc.com world-tv.bbc.com europe.cnbc.com ftv.com landscapetv.com
channel-9.tv-listings.ananova.com beti.tv studio.com utv2.utv.co.uk
choice.bbc.co.uk)],

		film => [qw(
sky-premier.sky.com cinema.carlton.com filmfour.channel4.com
extreme.filmfour.channel4.com plus-1.filmfour.channel4.com
world.filmfour.channel4.com box-office-digital.sky.com
2.moviemax.sky.com 3.moviemax.sky.com 4.moviemax.sky.com
5.moviemax.sky.com itvdigital.moviemax.sky.com moviemax.sky.com
cinema.sky.com 2.premier.sky.com 3.premier.sky.com 4.premier.sky.com
ondigital.premier.sky.com widescreen.premier.sky.com 2.cinema.sky.com
51.front-row.ntl.com 52.front-row.ntl.com 53.front-row.ntl.com
54.front-row.ntl.com front-row.ntl.com b4utv.com tcm.turner.com)],

		children => [qw(
uk.cartoonnetwork.com kids.discoveryeurope.com
disneychannel.disney.co.uk foxkids.co.uk plus-1.foxkids.co.uk
nickelodeon.co.uk nickelodeon.co.uk nickelodeon.co.uk
jr.nickelodeon.co.uk replay.nickelodeon.co.uk
boomerang.cartoonnetwork.com toon.disney.co.uk playhouse.disney.co.uk
plus-1.uk.cartoonnetwork.com plus-1.disneychannel.disney.co.uk)],

		religion => [qw(
christian-channel-europe.god-digital.com)],

		classics => [qw(
digitalclassics.tv tcm.turner.com uk-drama.flextech.telewest.co.uk
uk-gold.flextech.telewest.co.uk uk-gold-2.flextech.telewest.co.uk
uk-horizons.flextech.telewest.co.uk living.flextech.telewest.co.uk
play.flextech.telewest.co.uk uk-style.flextech.telewest.co.uk)],

		lifestyle => [qw(
breeze.granadatv.co.uk plus-1.home.discoveryeurope.com
home.discoveryeurope.com living.flextech.telewest.co.uk
uk-style.flextech.telewest.co.uk)],

		music => [qw(
m2europe.com mtv.co.uk base.mtv.co.uk dance.mtv.co.uk hits.mtv.co.uk
blues.musicchoice.co.uk classical.musicchoice.co.uk
country.musicchoice.co.uk dance.musicchoice.co.uk
easy.musicchoice.co.uk gold.musicchoice.co.uk hits.musicchoice.co.uk
jazz.musicchoice.co.uk love.musicchoice.co.uk rock.musicchoice.co.uk
vh1online.co.uk classic.vh1online.co.uk thebox.co.uk)],

		comedy => [qw(paramountcomedy.com)],

		arts => [qw(
performancetv.co.uk digital.performancetv.co.uk artsworld.com)],

		# I hope that putting 'Travel Shop' etc in here is
		# correct.
		#
		shop => [qw(
qvcuk.com shop-tv.co.uk simplyshoppingtv.co.uk
shop-america.tv-listings.ananova.com qvc1.qvcuk.com
2.tvtravelshop.co.uk screenshop.co.uk
landmark-travel.tv-listings.ananova.com tvtravelshop.co.uk)],

		scifi => [qw(
cable.uk.scifi.com digital.uk.scifi.com)],

		travel => [qw(
travel.discoveryeurope.com 2.tvtravelshop.co.uk
landmark-travel.tv-listings.ananova.com travelchannel.co.uk
tvtravelshop.co.uk)],
	       );


    # Check that every XMLTV id here is actually known.
    foreach my $pkg_name (keys %pkgs) {
	foreach my $ch_id (@{$pkgs{$pkg_name}}) {
	    my $ch = Channel->find_by_xmltv_id($ch_id);
	    if (not defined $ch) {
		warn "channel id $ch_id mentioned in package $pkg_name, but not known";
	    }
	}
    }

    return %pkgs;
}
