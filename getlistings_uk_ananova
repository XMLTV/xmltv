#!/usr/bin/perl -w
use strict;
use LWP::Simple;
use Getopt::Long;
use Tie::IxHash;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Date::Manip;
use XML::Writer;
use UK_TZ;
use XMLTV;
use Tie::RefHash;
use Term::ProgressBar;

# Prototype declarations
sub check_ananova_blurb();
sub get_regions();
sub get_dir();
sub get_ch_types();
sub usage();
sub get_file($$$);
sub date_programmes($$);
sub add_clumpidx($$);
sub ch_output($);
sub get_ch_to_output();
sub new_relation();
sub related($$$);
sub relate($$$);
sub unrelate($$$);
sub nuke_from_rel($$);
sub relatives($$);

# PHP page provided by Ananova to access their internal listings data.
# This is used as an inital substring of all the URLs gotten by this
# program.
# 
my $A = 'http://www.ananova.com/tv_listings/_tv_raw.php';

# Memoize some subroutines if possible
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly\n";
}
else {
    # FIXME
#     foreach (qw/parse_uk_date date_to_uk
# 	        ParseDate UnixDate DateCalc Date_Cmp
#                 ParseDateDelta/)
#     {
# 	Memoize::memoize($_) or die "cannot memoize $_: $!";
#     }
}

# Things will go horribly wrong if Ananova change pages from one day
# to the next while the script is running.  Assume they do it at
# midnight. 
# 
my $today = ParseDate('today'); die if not defined $today;
END {
    if (UnixDate(ParseDate('today'), '%Q') ne UnixDate($today, '%Q')) {
	warn "current day has changed, results may be messed up\n";
    }
}

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

my $bar = new Term::ProgressBar('getting list of channels', 4);
my $copyright = check_ananova_blurb(); update $bar;

# Set up an XML::Writer; print copyright and start of document.
my $writer = new XML::Writer(DATA_MODE   => 1,
			     DATA_INDENT => 2 );
$writer->xmlDecl("ISO-8859-1", "1.0");
$writer->comment($copyright);
{ local $^W = 0; $writer->doctype('tv', undef, 'xmltv.dtd') }
$writer->startTag('tv',
		  'source-info-url'     =>
	  'http://www.ananova.com/tv_listings/_tv_full_listings.html',
		  'source-info-name'    => 'Ananova',
		  'source-data-url'     => $A,
		  'generator-info-name' => 'XMLTV/0.2.10',
		  'generator-info-url'  =>
	  'http://www.doc.ic.ac.uk/~epa98/work/apps/xmltv/',
		 );

my $regions = get_regions(); update $bar;
#t 'regions: ' . d $regions;

# $ch_types maps channel id to type, $ch_pretty maps it to pretty
# name.  However, the pretty names in the channel file are not
# definitive; they're used to print progress messages, but the name
# in the listings file itself takes precedence.
# 
my ($ch_types, $ch_pretty) = get_ch_types(); update $bar;
my %ch_pretty_definitive; # whether the name in $ch_pretty is defin.

my %ch_to_output = get_ch_to_output();
t '\%ch_to_output=' . d \%ch_to_output;

# We've set the type of 'radio' and 'satellite' channels.  Now deal
# with the terrestrial channels, which have a region set.  We should
# find that every channel fits into radio, xor satellite, xor one
# particular region.
# 
# We end up with a list of [ day, type, channel, filename ], where
# type is one of 'radio', 'satellite', or a region code.
# 
my @files;
my %used_ch_types;

# Some entries in show=dir are for non-terrestrial channels which
# don't appear in show=channels.  This means they are old files which
# didn't get deleted, although they should have been.
# 
my %duff_channels;
END {
    my @duff = sort keys %duff_channels;
    if (@duff) {
	# Don't bother warning, this error almost always happens and
	# the Ananova people are aware of the inconsistency.
	# 

# 	warn <<END
# The following channels had listings files, but were not mentioned in
# the listing of channels:

# @duff

# The listings files are probably old ones, they haven\'t been fetched.
END
  ;
    }
}
    
foreach (get_dir()) {
    my ($orig, $day, $ch, $region) = @$_;
    my $has_type = (defined $ch_types->{$ch});
    my $has_region = (defined $region);
    ++ $used_ch_types{$ch};

    if (not $has_type and not $has_region) {
	# So the channel is not listed as 'radio' or 'satellite', and
	# neither does it have a region.  This probably means it's an
	# old file which is still lying around in dir.
	# 
	$duff_channels{$ch} = 1;
    }
    elsif (not $has_type and $has_region) {
	$ch_types->{$ch} = $region;
	push @files, [ $day, $region, $ch, $orig ];
    }
    elsif ($has_type and not $has_region) {
	if ($ch_types->{$ch} eq 'satellite' or $ch_types->{$ch} eq 'radio') {
	    # Satellite and radio channels do not have a region, okay.
	    push @files, [ $day, $ch_types->{$ch}, $ch, $orig ];
	}
	else {
	    warn "channel $ch has unknown type $ch_types->{$ch}";
	}
    }
    elsif ($has_type and $has_region) {
	if ($ch_types->{$ch} eq $region) {
	    # Encountered the same region as before, okay.
	    push @files, [ $day, $region, $ch, $orig ];
	}
	else {
	    warn "channel $ch has changed from $ch_types->{$ch} to $region";
	}
    }
    else { die }
}
#t 'files: ' . d \@files;
update $bar;

# Check that there are no redundant entries in the channel data.
foreach (keys %$ch_types) {
    unless ($used_ch_types{$_}) {
	warn "channels data mentions $_ ($ch_pretty->{$_}), but not used\n";
    }
}

# Check for --days option.
my $opt_days;
GetOptions('days=i' => \$opt_days);
    
# Now work out which of @files we actually want to download.
my (%type_pretty, %wanted_type);
my $want_all;
if (defined $ARGV[0] and $ARGV[0] eq 'ALL') {
    $want_all = 1;
}
else {
    %type_pretty = reverse %$regions;
    $type_pretty{$_} = $_ foreach qw(radio satellite);
    foreach my $arg (@ARGV) {
	my $t;
	foreach (keys %type_pretty) {
	    if ($type_pretty{$_} =~ /\Q$arg\E/i) {
		$t = $_;
		last;
	    }
	}
	if (not defined $t) {
	    warn "'$arg' does not match any known channel type\n";
	    usage();
	}
	else {
	    $wanted_type{$t}++
	      && warn "channel type $type_pretty{$t} mentioned twice\n";
	}
    }
    if (not keys %wanted_type) {
	my $default;
	foreach (keys %type_pretty) {
	    if ($type_pretty{$_} =~ /carlton/i) {
		$default = $_;
		++ $wanted_type{$_};
		last;
	    }
	}
	if (keys %wanted_type) {
	    warn "no channel types given, assuming $type_pretty{$default}\n";
	    usage();
	}
	else {
	    warn "no channel types given and default 'carlton' not found, "
	      . "giving up\n";
	    usage();
	    exit(1);
	}
    }
    die if not keys %wanted_type;
}

# At present, the Ananova site doesn't have any handling for satellite
# versions of terrestrial channels.  For example, the special digital
# versions of BBC1 and BBC2.  These are not listed anywhere,
# although they're a standard part of Sky Digital.  As a stopgap,
# users need to choose a terrestrial region (probably 'Carlton') as
# well.  Hopefully Ananova will get a schedule feed for BBC1, BBC2, C4
# and C5 digital, so this workaround can go away.  (And I hear that
# ITV will soon be available on Sky Digital too.)
# 
# We could also warn about not getting the radio channels when you
# choose 'satellite', but that's more obviously something you need to
# specify separately.
# 
if ($wanted_type{satellite}) {
    my $also_chose_terrestrial = 0;
    foreach (keys %wanted_type) {
	if ($_ ne 'radio' and $_ ne 'satellite') {
	    $also_chose_terrestrial = 1;
	    last;
	}
    }
    unless ($also_chose_terrestrial) {
	warn <<END
You have selected to grab satellite listings.  At present, the
five terrestrial channels are not included under 'satellite', although
they may be available on some services such as Sky Digital.

You might want to specify the region 'Carlton' in addition to
'satellite', to make sure you get all the channels.  (Similarly
'radio' if you want radio stations.)
END
  ;
    }
}

# Filter out the files we want to download - those with the correct
# channel type.
# 
@files = grep {
    ($want_all or $wanted_type{$_->[1]})
      && (not defined $opt_days or $opt_days >= $_->[0])
  } @files;
$bar = new Term::ProgressBar('downloading listings', scalar @files);
foreach (@files) {
    my ($day, $type, $ch, $filename) = @$_;
    die if not ($want_all or $wanted_type{$type});
    die if defined $opt_days and $day > $opt_days;

    # Work out the actual day this number corresponds to: 1 is
    # today.
    # 
    my $day_offset = $day-1;
    t 'day offset: ' . d $day_offset;
    my $day_date = DateCalc($today, "+ $day_offset days");
    die if not defined $day_date;

    # Get a list of programmes from this filename.
    my $progs = get_file($day_date, $ch, $filename);

    # Add the correct channel identifier.  This is partly worked out
    # from the global $ch_pretty, which gets set by get_file(), so we
    # can't work out the identifier until this point.
    # 
    my $ch_output = ch_output($ch);
    $_->{channel} = $ch_output foreach @$progs;

    # Fix the dates.
    date_programmes($progs, $day_date);
	
    # Add clumpidx's.
    my $rel = new_relation();
    add_clumpidx($progs, $rel);
    t 'related programmes: ' . d($rel);

    # Write them out.
    write_programme($writer, $_) foreach @$progs;

    update $bar;
}

# Finish writing programmes.
$writer->endTag('tv');

# Now write the channels file.  Remember, %{$ch_pretty} maps Ananova
# id to pretty name, %ch_to_output maps it to XMLTV channel id.
# 
#$Log::TraceMessages::On = 1;
my %channels_output;
foreach (keys %$ch_pretty) {
    next unless $want_all or $wanted_type{$ch_types->{$_}};
    my $o = $ch_to_output{$_};
    my $p = $ch_pretty->{$_}; die if not defined $p;
    if (defined $o) {
	# Don't need to warn about more than one channel with the same
	# output id, because Channel 4 and Channel 5 are considered by
	# Ananova as split into regions, but each region is in fact
	# the same.  Likewise some things like the two versions of
	# Meridian (different for BBC, but not ITV).
	# 
	push @{$channels_output{$o}}, [ $LANG, $p ];
    }
    else { die "don't know RFC2838-style name for $_ ($p)" }
}
# Add some extra pretty names (mostly channel numbers, a few
# abbreviations of long names).  These are hardcoded here because
# there wasn't a better place for them - arguably the listings grabber
# for a particular country is the place to store that country's
# particular channel numbers.
# 
my %channel_numbers = ('theadultchannel.co.uk' => 'Adult',
		       'anglia.tv.co.uk' => 3,
		       'south-east.bbc1.bbc.co.uk' => 1,
		       'east.bbc1.bbc.co.uk' => 1,
		       'ireland.bbc1.bbc.co.uk' => 1,
		       'midlands.bbc1.bbc.co.uk' => 1,
		       'north.bbc1.bbc.co.uk' => 1,
		       'north-east.bbc1.bbc.co.uk' => 1,
		       'north-east.bbc1.bbc.co.uk' => 1,
		       'north-west.bbc1.bbc.co.uk' => 1,
		       'south.bbc1.bbc.co.uk' => 1,
		       'scotland.bbc1.bbc.co.uk' => 1,
		       'scotland.bbc1.bbc.co.uk' => 1,
		       'south-east.bbc1.bbc.co.uk' => 1,
		       'south-west.bbc1.bbc.co.uk' => 1,
		       'south-west.bbc1.bbc.co.uk' => 1,
		       'west.bbc1.bbc.co.uk' => 1,
		       'wales.bbc1.bbc.co.uk' => 1,
		       'south-east.bbc2.bbc.co.uk' => 2,
		       'east.bbc2.bbc.co.uk' => 2,
		       'ireland.bbc2.bbc.co.uk' => 2,
		       'midlands.bbc2.bbc.co.uk' => 2,
		       'north.bbc2.bbc.co.uk' => 2,
		       'north-east.bbc2.bbc.co.uk' => 2,
		       'north-east.bbc2.bbc.co.uk' => 2,
		       'north-west.bbc2.bbc.co.uk' => 2,
		       'south.bbc2.bbc.co.uk' => 2,
		       'scotland.bbc2.bbc.co.uk' => 2,
		       'scotland.bbc2.bbc.co.uk' => 2,
		       'south-east.bbc2.bbc.co.uk' => 2,
		       'south-west.bbc2.bbc.co.uk' => 2,
		       'south-west.bbc2.bbc.co.uk' => 2,
		       'west.bbc2.bbc.co.uk' => 2,
		       'wales.bbc2.bbc.co.uk' => 2,
		       'bloomberg.com' => 'Bloomberg',
		       'border-tv.com' => 3,
		       'bravo.co.uk' => 'Bravo',
		       'british.eurosport.com' => 'Eurosport',
		       'carlton.com' => 3,
		       'central.carlton.com' => 3,
		       'channel4.com' => 4, 
		       'channel5.co.uk' => 5,
		       'christian-channel-europe.god-digital.com'
		           => 'Christian',
		       'europe.cnbc.com' => 'CNBC',
		       'discoveryeurope.com' => 'Discovery',
		       'plus-1.discoveryeurope.com' => 'Discovery+1',
		       'sci-trek.discoveryeurope.com' => 'Sci-Trek',
		       'disneychannel.disney.co.uk' => 'Disney',
		       'challengetv.co.uk' => 'Challenge',
		       'fantasy.televisionx.co.uk' => 'Fantasy',
		       'filmfour.channel4.com' => 'FilmFour',
		       'foxkids.co.uk' => 'Fox Kids',
		       'plus-1.foxkids.co.uk' => 'Fox Kids+1',
		       'grampiantv.co.uk' => 3,
		       'granadatv.co.uk' => 3, 
		       'breeze.granadatv.co.uk' => 'Breeze',
		       'men.granadatv.co.uk' => 'Men & Motors',
		       'thehistorychannel.co.uk' => 'History',
		       'wales.htv.co.uk' => 3,
		       'west.htv.co.uk' => 3,
		       'sport-plus.itv.co.uk' => 'ITV Sport Plus',
		       'landscapetv.com' => 'Landscape',
		       'meridian.tv.co.uk' => 3,
		       'nationalgeographic.co.uk' => 'National Geographic',
		       'playboy.com' => 'Playboy',
		       'racingchannel.com' => 'Racing',
		       'radio-1.bbc.co.uk' => 'R1',
		       'radio-2.bbc.co.uk' => 'R2',
		       'radio-3.bbc.co.uk' => 'R3',
		       'radio-4.bbc.co.uk' => 'R4',
		       'radio-5-mw.bbc.co.uk' => 'R5',
		       's4c.co.uk' => 'S4C',
		       'digital.s4c.co.uk' => 'S4C',
		       'cable.uk.scifi.com' => 'Sci-Fi',
		       'digital.uk.scifi.com' => 'Sci-Fi',
		       'scottishtv.co.uk' => 3,
		       'shop-tv.co.uk' => 'Shop',
		       'box-office-digital.sky.com' => 'Sky Box Office',
		       'sky-one.sky.com' => 'S1', 
		       'eurosport.sky.com' => 'Eurosport',
		       'itvdigital.moviemax.sky.com' => 'Sky Moviemax',
		       'cinema.sky.com' => 'Sky Cinema',
		       'ondigital.sky-one.sky.com' => 'S1',
		       'ondigital.premier.sky.com' => 'Sky Premier',
		       'widescreen.premier.sky.com' => 'Sky Premier',
		       'setindia.com' => 'SETI',
		       'tcm.turner.com' => 'TCM',
		       'home.discoveryeurope.com' => 'Discovery Home',
		       'travelchannel.co.uk' => 'Travel',
		       'trouble.co.uk' => 'Trouble',
		       'tvasia.com' => 'Zee',
		       'tvtravelshop.co.uk' => 'Travel Shop',
		       'tttv.granadatv.co.uk' => 3,
		       'utv.co.uk' => 3,
		       'westcountry.carlton.com' => 3,
		       'yorkshire.granadatv.co.uk' => 3,
		      );
foreach (keys %channels_output) {
    my $extra = $channel_numbers{$_};
    if (defined $extra) {
	my $entry;
	if ($extra =~ tr/0-9//c) {
	    # Not a channel number, should have a 'language'.
	    $entry = [ $LANG, $extra ];
	}
	else {
	    $entry = [ undef, $extra ];
	}
	
	# Don't want to add it if it's already in the list.
	my $already = 0;
	foreach (@{$channels_output{$_}}) {
	    t 'checking existing entry: ' . d $_;
	    next if $_->[1] ne $entry->[1];
	    if (not defined $_->[0] and not defined $entry->[0]) {
		$already = 1;
		last;
	    }
	    if (defined $_->[0] and defined $entry->[0]
		and $_->[0] eq $entry->[0]) {
		$already = 1;
		last;
	    }
	}
	unless ($already) {
	    push @{$channels_output{$_}}, $entry;
	}
    }
}
t 'writing channels hash: ' . d \%channels_output;
write_channels(\%channels_output);
exit();


# Check that the usage message has not changed (if it has, this
# program probably needs changing).  Returns the copyright message.
# 
sub check_ananova_blurb() {
    (my $blurb = get $A) or die "cannot get $A";
    $blurb =~ s/^\s*\#\s*//gm; $blurb =~ s/(\s)\s+/$1/g;
    $blurb =~ s/
useage: \?show=<request>
where request is one of \[regions\|channels\|dir\|<file>\]
\?show=regions outputs a list of regions and region codes
\?show=channels outputs a list of channel codes and names
\?show=dir outputs the list of currently valid file names.*//s
  or warn "usage message has changed to: $blurb\n";
    return $blurb;
}


# Return a reference to an ordered hash mapping region pretty name to
# Ananova internal region name.
# 
sub get_regions() {
    my $url =  "$A?show=regions";
    (my $data = get $url) or die "cannot get $url";
#    t "got regions page: $data";
    my %r; tie %r, 'Tie::IxHash';
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	if (/^region\.((?:[a-z]+_)?\d+)=(.+)$/) {
	    $r{$2} = $1;
	}
	else {
	    warn "bad line from $url: $_";
	}
    }
    if (not keys %r) {
	warn "couldn't get any region data from $url";
    }
    return \%r;
}
    

# Get the list of Ananova 'filenames' and parse each filename into a
# tuple of:
# 
# [ original filename, day number, channel id, region ]
# 
# Region may be undef, and channel id will also contain the region
# details (so that bbc1_2 and bbc1ea_0 are distinct channels).
# 
# Returns a list of these tuples (er, listrefs).
# 
sub get_dir() {
    local $Log::TraceMessages::On = 0;
    my $url =  "$A?show=dir";
    (my $data = get $url) or die "cannot get $url";
#    t "got dir page: $data";

    my @r;
    my %warned_unknown_region;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	my $orig = $_;

	s/^day(\d+)_// or die "bad Ananova filename $_ (no 'dayX_')";
	my $day = $1;
	my $channel = $_;

	my $region;
	foreach my $r (values %$regions) {
	    if ($r =~ /\D/ && s/$r$//) {
		# Ends with the region code itself.  This isn't
		# applicable if the region code is just a number.
		# 
		$region = $r;
		last;
	    }
	    
	    $r =~ /(\d+)$/ or die "bad region code $r";
#	    t "just the number of region: $1";
	    if (/_$1$/) {
		# Ends with _ and just the number of the region.
		$region = $r;
		last;
	    }
	}

	if (not defined $region) {
	    if (/^(?:[a-z]+_)?[a-z0-9]+$/) {
		# No region at all, okay.
	    }
	    else {
		unless ($warned_unknown_region{$_}++) {
		    warn "can't find region for channel id $_\n";
		}
	    }
	}

	push @r, [ $orig, $day, $channel, $region ];
    }
    return @r;
}


# Get details of the different channel names.  Returns a list of two
# hashrefs: the first maps channel internal name to type ('radio' or
# 'satellite'), the second maps it to pretty name.
# 
sub get_ch_types() {
    local $Log::TraceMessages::On = 0;
    my $url =  "$A?show=channels";
    (my $data = get $url) or die "cannot get $url";
#    t "got channels page: $data";

    my (%type, %pretty);
    my %seen_pretty;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	if (/^(radio|satellite)\.([a-z0-9_]+)=(.+)$/) {
	    t 'matched';
	    my ($type, $ch, $pretty) = ($1, $2, $3);
	    t "type=$type, ch=$ch, pretty=$pretty";
	    if (defined $type{$ch}) {
		warn "channel $ch seen twice";
		next;
	    }
	    if ($seen_pretty{lc $pretty}++) {
		warn "channel pretty name $pretty seen twice";
		next;
	    }

	    t "setting type of $ch to $type";
	    $type{$ch} = $type;
	    t "setting pretty name of $ch to $pretty";
	    $pretty{$ch} = $pretty;
	}
	else {
	    warn "bad line in channels listing: $_\n";
	}
    }
    return (\%type, \%pretty);
}


# Usage message
my $shown_usage = 0;
sub usage() {
    return if $shown_usage++;
    my $msg = <<END
usage: $0 [--days N] channel-type...

A channel type is either a TV region or a method of broadcasting.  You
should choose the channel types you are able to receive.  The available
types are:

END
  ;
    $msg .= join("\n", sort values %type_pretty) . "\n";
    $msg .= <<END

You can abbreviate these names by giving a case-insensitive substring,
for example 'Tyne Tees' could be abbreviated to 'tyne'.  The special
value 'ALL' means get every available channel.
END
  ;
    warn $msg;
}
    

# Get data for a particular day.
# 
# Parameters:
#   date expected in file (in Date::Manip format)
#   channel id, used to check pretty name in file
#   'filename'
# 
# Uses global $ch_pretty hashref.
# 
# Returns: reference to list of programme details, or undef if error.
# These won't have proper start and stop times; instead they have a
# 'time' key and you should use date_programmes() or similar to fix up
# the list of programmes afterwards.  Also the channel is not
# included, you should add that to each programme (probably in RFC2838
# style) afterwards.
# 
sub get_file($$$) {
    my ($date_expected, $ch, $file) = @_;
    my $url =  "$A?show=$file";

    (my $data = get $url) or die "cannot get $url";

    my @lines = split /\n/, $data;
    foreach (@lines) { s/^\s+//; s/\s+$//; s/\#.*// }
    @lines = grep { length } @lines;

    if (not @lines) {
	# No non-comment lines.  This could be because the PHP script
	# is returning 'file not found'.  That happens if you request
	# the directory listing, it contains obsolete files which
	# (wrongly) are still around, and then your request for the
	# file itself is handled by a different box where the file is
	# in fact deleted.
	# 
	if ($data =~ /\n\# $file does not exist$/) {
	    warn "file $file does not exist on server, probably should be removed from dir\n";
	    return undef;
	}
	else {
	    warn "cannot get data from $url, returns:\n$data";
	    return undef;
	}
    }

    # Check the date.  According to Ananova's comment there's some odd
    # procedure you have to follow to make sure it is correct.
    # 
    my $page_date = shift @lines;
    if (not $page_date =~
/^((?:Sun|Mon|Tues|Wednes|Thurs|Fri|Satur)day)\|(\d\d)\|(\d\d)\|(\d\d\d\d)$/)
    {
	warn "bad date '$page_date' in file $url, skipping";
	return undef;
    }
    my ($weekday, $dd, $mm, $yyyy) = ($1, $2, $3, $4);
    t "got date: $weekday $yyyy-$mm-$dd";
    my $dp = ParseDate("$yyyy-$mm-$dd");
    if (not defined $dp) {
	warn "bad date '$page_date' in file $url, skipping";
	return undef;
    }
    t "parsed out date $dp, check it matches $weekday";
    if (UnixDate($dp, '%A') ne $weekday) {
	# Apparently you have to step backwards by one or two days
	# until the date matches the weekday given.
	# 
	my $found = 0;
	foreach (0, 1) {
	    $dp = DateCalc($dp, '- 1 day'); die if not defined $dp;
	    if (UnixDate($dp, '%A') eq $weekday) {
		$found = 1;
		last;
	    }
	}
	if (not $found) {
	    warn "weekday of $page_date is wrong in $url (even tried going back a couple of days)";
	    return undef;
        }
    }
    
    # But does it match what we expect?
    if (UnixDate($dp, '%Q') ne UnixDate($date_expected, '%Q')) {
	warn "date from page $url (" . UnixDate($dp, '%Q') . ") is wrong (probably an old file)\n";
	return undef;
    }

    # Check the channel name is as expected (if we know what the
    # pretty name should be for this channel).
    # 
    my $got_ch_pretty = shift @lines;
    my $expected_pretty_name = $ch_pretty->{$ch};
    if (defined $expected_pretty_name
	and $got_ch_pretty ne $expected_pretty_name) {
	if ($ch_pretty_definitive{$ch}) {
	    warn
"channel $ch changed name from '$expected_pretty_name' to '$got_ch_pretty'\n";
	}
	else {
	    # Not definitive, in other words the new name takes
	    # precedence (and is definitive).
	    # 
	    $ch_pretty->{$ch} = $got_ch_pretty;
	    $ch_pretty_definitive{$ch} = 1;
	}
    }
    else {
	# Currently no pretty name defined.  Probably because it's a
	# terrestrial channel and wasn't mentioned in the channels
	# file.  We check elsewhere for channels in show=dir that
	# aren't in show=channels, so here we needn't bother with
	# validating, we can just set the name and carry on happily.
	# 
	$ch_pretty->{$ch} = $got_ch_pretty;
    }

    my $copyright = pop @lines;
    if ($copyright !~ /^\(c\) Copyright/) {
	warn "strange copyright message: $copyright\n";
    }

    if (@lines and $lines[0] =~
	/^There are no listings available for this channel today\|\|/) {
	return [];
    }

    # Right, got that cruft out of the way, each remaining line is a
    # |-separated list of programme details.
    # 
    my @r;
    my $prev_time;
    foreach (@lines) {
	my @fields = split /\|/, $_, -1; # toothpicks ahoy!
	my $num_fields = scalar @fields;
	if ($num_fields == 1 and $fields[0] =~ /copyright/i) {
	    next;
	}
	if ($num_fields < 17 or $num_fields >= 22) {
	    warn "wrong number of fields ($num_fields, need 17..21) "
	      . "in line from $url: $_\n";
	    warn "fields are: " . join("\n", @fields) . "\n";
	    warn "skipping line\n";
	    next;
	}
	my ($title, $time, $when, $episode_num, $episode_name, $cast,
	    $director, $duration, $desc, $type, $subtitled, $bw,
	    $stereo, $mono, $new, $repeat, $digital)
	  = @fields;
	my %p;
	$p{title} = [ $title ];
	
	# The comment from Ananova says that the time is 'probably in
	# time zone existing at 5:00am of the correct file date'.  I
	# assume that means that it might not be, and it might instead
	# have an explicit timezone.  We'll just use the old
	# date-parsing routines to figure out the timezone.
	# 
	# That means that for now, we add an element 'time' to the
	# programme details, and later on, date_programmes() turns
	# this into a proper start and stop time.
	# 
	if (length $time) {
	    if (not $time =~ /^\d\d?:\d\d$/) {
		warn "bad time '$time' in line from page $url: $_";
		warn "skipping line";
		next;
	    }
	}
	else {
	    # No time was given for this programme.  This is probably
	    # because it's contained in the same 'clump' as the
	    # previous one, for example 'CBBC' at 6:45 is followed in
	    # the listings by 'Teletubbies' without a time.
	    # 
	    # For this case, we give the programme the same time as
	    # the previous one.  That's the way it appears in the
	    # Ananova user-visible pages and it's what add_clumpidx()
	    # expects.
	    # 
	    if (not defined $prev_time) {
		warn "no time for first line from page $url: $_";
		warn "skipping line";
		next;
	    }
	    $time = $prev_time;
	}

	# For sanity-checking the time against 'when',
	# comparing raw hours and minutes will probably be faster
	# than using Date::Manip.
	# 
	$time =~ /^(\d\d?):(\d\d)$/ or die;
	my ($hours, $minutes) = ($1, $2);
	if (length($hours) == 1) {
	    $hours = "0$hours";
	    $time = "$hours:$minutes";
	}
	$p{time} = $time;
	$prev_time = $time;
	
	# The 'when' attribute can be DAYTIME, EVENING or LATENIGHT.
	# It seems a bit redundant to me.  But on the principle that
	# no scrap of information should be thrown away, we check that
	# it's sensible.
	# 
	if ($when eq 'DAYTIME') {
	    if (5 <= $hours and $hours < 18) {
		# Daytime is between 05:00 and 18:00.  It overlaps
		# slightly with LATENIGHT.
		# 
	    }
	    else {
		warn "time $time is wrongly considered 'DAYTIME' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'EVENING') {
	    if (18 <= $hours) {
		# Evening is from 18:00 until midnight.
	    }
	    else {
		warn "time $time is wrongly considered 'EVENING' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'LATENIGHT') {
	    if ($hours < 7
		or ($hours == 7 and $minutes == 0)) {
		# Latenight is until 07:00 (or sometimes a programme
		# just beginning at that time is still latenight).
		# 
	    }
	    else {
		warn "time $time is wrongly considered 'LATENIGHT' "
		  . "in line from url $url: $_\n";
	    }
	}
	else {
	    warn "unknown 'when' specifier $when "
	      . "in line from url $url: $_";
	}

	# Episode number.
	if (length $episode_num) {
	    if ($episode_num =~ m!^[0-9/]+$!) {
		# Assume that Ananova numbers episodes from 1; but
		# XMLTV - like all good languages - counts from 0.
		# 
		$episode_num =~ s/^(\d+)/$1 - 1/e;
		$p{episode_num} = $episode_num;
	    }
	    else {
		warn "bad episode number '$episode_num' "
		  . "in line from url $url: $_";
	    }
	}

	# Epsiode name.  This corresponds to the badly named
	# 'sub-title' in XMLTV.
	# 
	if (length $episode_name) {
	    $p{sub_title} = [ $episode_name ];
	}

	# Cast.
	if (length $cast) {
	    foreach (split /\s*,\s*/, $cast) {
		push @{$p{credits}{actor}}, $_;
	    }
	}

	# Director.
	if (length $director) {
	    foreach (split /\s*,\s*/, $director) {
		push @{$p{credits}{director}}, $_;
	    }
	}
	
	# Ananova's idea of 'duration' is usually the original length
	# of a film - not the length it is shown at on TV.  Now we do
	# have a 'length' element in the XMLTV format, but that's
	# meant for the length _as shown_, just not including adverts
	# or other junk.  So we just discard duration.
	# 
	if ($duration ne '' and $duration !~ /^(\d+)\s+(?:mins|minutes)$/) {
	    warn "bad duration $duration "
	      . "in line from url $url: $_";
	}

	# Description.  Any special munging on this will happen later.
	if (length $desc) {
	    $p{desc} = [ $desc ];
	}

	# Programme type.
	if (length $type) {
	    foreach (split /\s*,\s*/, $type) {
		push @{$p{category}}, lc $_;
	    }
	}

	# Subtitles.  Assume that when Ananova say this, they mean
	# teletext (I don't know what happens for foreign films with
	# on-screen subtitles).
	# 
	if ($subtitled) {
	    $p{subtitles} = [ 'teletext' ];
	}
	
	# Black and white - in other words, not colour.
	if ($bw) {
	    $p{colour} = 0;
	}
	
	# Stereo or mono.
	if (not $stereo and not $mono) {
	    # Just don't set any of the flags.
	}
	elsif (not $stereo and $mono) {
	    $p{audio}{present} = 1;
	    $p{audio}{stereo} = 'mono';
	}
	elsif ($stereo and not $mono) {
	    $p{audio}{present} = 1;
	    $p{audio}{stereo} = 'stereo';
	}
	else {
	    warn "line in page $url has both stereo and mono: $_";
	}

	# Repeat or new.  I don't know whether these are necessarily
	# mutually exclusive - you might have an instant repeat of the
	# first episode of a new series have both.  So I won't bother
	# checking that both are not set.
	# 
	if ($repeat) {
	    $p{previously_shown} = 1;
	}
	if ($new) {
	    $p{new} = 1;
	}
	    
	# I don't know what the 'digital' flag is for: Ananova says
	# 'if known to be available on as digital transmission'.  Just
	# ignore it.
	# 

	# Finally there are four descriptions, with increasing levels
	# of detail.  It might be a good idea to extend the XMLTV
	# format to support several descriptions of differing length,
	# but for now we just sanity-check them.
	# 
	my @descs = @fields[17..20];
	foreach my $i (0 .. $#descs) {
	    next if not defined $descs[$i] or not length $descs[$i];
	    foreach my $j ($i+1 .. $#descs) {
		next if not defined $descs[$j] or not length $descs[$j];
		if (length $descs[$j] < length $descs[$i]) {
		    warn
"description $j ($descs[$j]) is shorter than description $i ($descs[$i]) "
		      . "in line from url $url: $_";
		}
	    }
	}
	# The most detailed description should be the same as the main
	# description.  Er, except when it is not present at all.
	# 
	if (defined $descs[3] and $descs[3] ne '' and $descs[3] ne $desc) {
	    warn "description 3 ($descs[3]) isn't the same as main desc ($desc) "
	      . "in line from url $url: $_";
	}

	# NB $p{channel} does not get set!

	# Source - used for debugging and written out only as a
	# comment in the output.
	# 
	$p{source} = $file;

	push @r, \%p;
    }
    return \@r;
}


# date_programmes()
# 
# Given a list of programme details (from extract_progs()) and the date
# of this listing, add proper time and date for each programme.  In UT.
# 
# Parameters:
#   reference to list of programme details
#   date in Date::Manip format
# 
# Modifies the list passed in, so that each programme no longer has
# {'time'} but has {'start'} instead.  If the programme has
# {'length'}, gets rid of that too and puts in {'stop'}.
# 
sub date_programmes($$) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_date) = @_;
    t 'adding date to programmes: ' . d $progs;
    t 'base date: ' . d $base_date;
    my $base_day = UnixDate($base_date, '%Q');
    die if not defined $base_day;
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;

    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my $current_tz = 0; # not undef, because of Memoize complaining
  
    foreach (@$progs) {
	t('adding date to programme ' . d($_));
	my $t = $_->{'time'};
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	if (defined gettz($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t "found explicit timezone $t, using for future progs";
	    $current_tz = gettz($t);
	}

	t "doing 24h UK time $t with base day $base_day";
	my $prog_date = parse_uk_date("$base_day $t", $current_tz);
	if (not defined $prog_date) {
	    # It's not a valid UK time.  Two reasons for this: it
	    # really isn't, or we're just confused about what day it
	    # is and need to 'jump' forward a day.
	    # 
	    t 'that date is bad, maybe need to jump a day?';
	    my $err;
	    my $new_base_day = UnixDate
	      DateCalc($base_day, $day_later, \$err),
	      '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    my $new_prog_date = parse_uk_date("$new_base_day $t", $current_tz);
	    die "bad base day + time '$t' (even tried next day)"
	      if (not defined $new_prog_date) or ($new_prog_date !~ /\S/);
	    t 'okay... assume we will jump a day (do it later)';
	}

	if ((not defined $prog_date)
	    or (defined $prev_date
		and (Date_Cmp($prev_date, $prog_date) > 0) ) )
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day - but see below.
	    # 
	    t 'time is lower than before';
	    my $prev_day = UnixDate $prev_date, '%Q';
	    t 'previous programme was at ' . d($prev_date);
	    my $threshold = ParseDate("$prev_day 12:00:00");
	    t 'threshold is ' . d($threshold);
	    if (Date_Cmp($prev_date, $threshold) < 0) {
		# I can't believe that one programme would last from
		# before 12:00 until after midnight on any day.  So
		# this seeming jump to the next day is bogus - it's
		# the same day but the time is a little bit earlier
		# for some reason.  (Probably UT/BST switching)
		# 
		t 'previous programme started before threshold, ' .
		  'cannot be next day';
	    }
	    else {
		t 'must be next day';
		my $err;
		$base_day = UnixDate
		  DateCalc($base_day, $day_later, \$err),
		  '%Q';
		die "error from DateCalc(): $err" if defined $err;
		$prog_date = parse_uk_date("$base_day $t", $current_tz);
		die "bad base day + time '$t'"
		  if (not defined $prog_date) or ($prog_date !~ /\S/);
		t 'new base day: ' . d($base_day);
	    }
	}

	delete $_->{'time'};
	$_->{'start'} = $prog_date;
	t 'new start time: ' . d($_->{start});
	$prev_date = $prog_date;

	if (defined(my $length = delete $_->{length})) {
	    # Try to calculate the stop time based on start time and length.
	    if (not defined $_->{stop}) {
		my $stop = DateCalc($_->{start}, "+ $length");
		if (defined $stop) {
		    $_->{stop} = $stop;
		}
		else {
		    warn "could not calculate stop time from $_->{start} + $length";
		}
	    }
	    else {
		warn 'programme has both length and stop';
	    }
	}
    }
}


# add_clumpidx()
# 
# Sometimes two programmes on a channel are given the same
# start time in the listings.  This seems to happen when the
# first is a 'mothership' containing several smaller things,
# for example '11:00 The Core, 11:00 Core News'.
# 
# We add a 'clumpidx' attribute to distinguish these
# programmes.  Eg 'The Core' has clumpidx '0/2' and 'Core
# News' has '1/2'.
# 
# See also special_split_title() which handles a similar problem.
# 
# Parameters:
#   a reference to a list of programmes for one channel, which will
#   be modified
# 
#   a reference to a 'relation' scalar.  Programmes sharing a clump are
#   in this relation together.  This scalar will be modified.
# 
sub add_clumpidx($$) {
    die "usage: add_clumpidx(ref to list of programmes, 'related' hashref)"
      if @_ != 2;
    my ($progs, $related) = @_;
    t('add_clumpidx() ENTRY');

    my $last_start;
    my %num_in_clump; # Maps start time to num. progs at that time
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	t '$start=' . d($start);
	$_->{clumpidx} = $num_in_clump{$start}++;
	t 'clumpidx now ' . d($_->{clumpidx});

	if ($num_in_clump{$start} > 1) {
	    if (not defined $last_start or $last_start ne $start) {
		warn <<END
more than one programme at $start on same channel, \
but not consecutive in listings (this is $_->{title})
END
				 ;
	    }
	}
	$last_start = $start;
    }
    
    # Okay, we've got clumpidx of '0', '1' where needed, but even
    # better would be '0/2', '1/2'.  We look at how many programmes
    # are in each clump: if only one, remove the clumpidx entirely.
    # If more than one, put the full 'x/y' clumpidx and additionally
    # make a note to updated the %{$related} hash.
    # 
    t "refine clumpidx's and build todo list";
    my %todo;
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	my $num = $num_in_clump{$start};
	die if not defined $_->{clumpidx};
	if ($num == 1) {
	    # Ordinary, sane programme not sharing its slot.  This
	    # would have a clumpidx of '0/1', which isn't worth
	    # putting in the output.
	    # 
	    t 'only programme in slot';
	    die if $_->{clumpidx} ne '0';
	    delete $_->{clumpidx};
	}
	elsif ($num > 1) {
	    t 'shares a slot';
	    $_->{clumpidx} .= "/$num";
	    t 'new clumpidx: ' . d($_->{clumpidx});
	    push @{$todo{$start}}, $_;
	    t "\$todo{$start} now " . d($todo{$start});
	}
	else { die }
    }

    # Update $related
    t 'updating $related from todo list';
    foreach (keys %todo) {
	t 'todo list for ' . d($_);
	my @l = @{$todo{$_}};
	t 'list of programmes: ' . d(\@l);
	foreach my $ai (0 .. $#l) {
	    foreach my $bi ($ai+1 .. $#l) {
		my $a = $l[$ai]; my $b = $l[$bi];
		t "$a and $b related";
		die if "$a" eq "$b";
		warn "$a, $b over-related" if related($related, $a, $b);
		relate($related, $a, $b);
	    }
	}
    }

    t 'add_clumpidx() EXIT';
}

# Given an Ananova internal channel id, return the output
# RFC2838-style name.  Where the name is not known, we invent one
# based on ananova.com (using global $ch_pretty).
# 
# Parameter: Ananova internal channel identifier
# Returns: funky domain name type string
# 
sub ch_output($) {
    local $Log::TraceMessages::On = 0;
    my $ch = shift;
    if (not defined $ch_to_output{$ch}) {
	my $pretty = $ch_pretty->{$ch};
	$pretty = $ch if not defined $pretty;
	my $munged = $pretty;
	for ($munged) {
	    t d $_;
	    tr/ _/-/s;
	    t d $_;
	    tr/a-zA-Z0-9-//cd;
	    t d $_;
	    tr/A-Z/a-z/;
	    t d $_;
	}
	my $new = "$munged.tv-listings.ananova.com";
	warn "don't know RFC2838-style name for $pretty ($ch), using $new\n";
	$ch_to_output{$ch} = $new;
    }
    return $ch_to_output{$ch};
}
	      
	      
# Return the list of what internal Ananova channel names map to what
# XMLTV internal channel names.  This isn't fetched from the site,
# it's just hardcoded here.
# 
sub get_ch_to_output() {
    %ch_to_output =
      ('adult' => 'theadultchannel.co.uk', # Adult Channel
       'anglia_0' => 'anglia.tv.co.uk', # Anglia
       'animalplanetdigital' => 'animalplanet.discoveryeurope.com', # Animal Planet (Digital)
       'asianet' => 'asianet-tv.com', # Asia.net
       'atlantic252' => 'atlantic252.com', # Atlantic 252
       'bbc1_2' => 'south-east.bbc1.bbc.co.uk', # BBC1
       'bbc1ea_0' => 'east.bbc1.bbc.co.uk', # BBC1 East Anglia
       'bbc1irish_12' => 'ireland.bbc1.bbc.co.uk', # BBC1 Ireland
       'bbc1mid_3' => 'midlands.bbc1.bbc.co.uk', # BBC1 Midlands
       'bbc1n_14' => 'north.bbc1.bbc.co.uk', # BBC1 North
       'bbc1ne_1' => 'north-east.bbc1.bbc.co.uk', # BBC1 North East
       'bbc1ne_11' => 'north-east.bbc1.bbc.co.uk', # BBC1 North East
       'bbc1nw_6' => 'north-west.bbc1.bbc.co.uk', # BBC1 North West
       'bbc1s_9' => 'south.bbc1.bbc.co.uk', # BBC1 South
       'bbc1scot_10' => 'scotland.bbc1.bbc.co.uk', # BBC1 Scotland
       'bbc1scot_5' => 'scotland.bbc1.bbc.co.uk', # BBC1 Scotland
       'bbc1se_15' => 'south-east.bbc1.bbc.co.uk', # BBC1 South East
       'bbc1sw_13' => 'south-west.bbc1.bbc.co.uk', # BBC1 South West
       'bbc1sw_4' => 'south-west.bbc1.bbc.co.uk', # BBC1 South West
       'bbc1w_8' => 'west.bbc1.bbc.co.uk', # BBC1 West
       'bbc1wales_7' => 'wales.bbc1.bbc.co.uk', # BBC1 Wales
       'bbc2_2' => 'south-east.bbc2.bbc.co.uk', # BBC2
       'bbc2ea_0' => 'east.bbc2.bbc.co.uk', # BBC2 East Anglia
       'bbc2irish_12' => 'ireland.bbc2.bbc.co.uk', # BBC2 Ireland
       'bbc2mid_3' => 'midlands.bbc2.bbc.co.uk', # BBC2 Midlands
       'bbc2n_14' => 'north.bbc2.bbc.co.uk', # BBC2 North
       'bbc2ne_1' => 'north-east.bbc2.bbc.co.uk', # BBC2 North East
       'bbc2ne_11' => 'north-east.bbc2.bbc.co.uk', # BBC2 North East
       'bbc2nw_6' => 'north-west.bbc2.bbc.co.uk', # BBC2 North West
       'bbc2s_9' => 'south.bbc2.bbc.co.uk', # BBC2 South
       'bbc2scot_10' => 'scotland.bbc2.bbc.co.uk', # BBC2 Scotland
       'bbc2scot_5' => 'scotland.bbc2.bbc.co.uk', # BBC2 Scotland
       'bbc2se_15' => 'south-east.bbc2.bbc.co.uk', # BBC2 South East
       'bbc2sw_13' => 'south-west.bbc2.bbc.co.uk', # BBC2 South West
       'bbc2sw_4' => 'south-west.bbc2.bbc.co.uk', # BBC2 South West
       'bbc2w_8' => 'west.bbc2.bbc.co.uk', # BBC2 West
       'bbc2wales_7' => 'wales.bbc2.bbc.co.uk', # BBC2 Wales
       'bbcchoice' => 'choice.bbc.co.uk', # BBC Choice
       'bbcknowledge' => 'knowledge.bbc.co.uk', # BBC Knowledge
       'bbcnews24' => 'news-24.bbc.co.uk', # BBC News 24
       'bbcparliament' => 'parliament.bbc.co.uk', # BBC Parliament
       # Just for fun we'll use the Boston Business
       # Consulting domain for the international (rather
       # than British) BBC channels.
       # 
       'bbcprime' => 'prime.bbc.com', # BBC Prime
       'bbcworld' => 'world-tv.bbc.com', # BBC World
       'bloomberg' => 'bloomberg.com', # Bloomberg TV
       'border_1' => 'border-tv.com', # Border
       # FIXME can't find domain name for 'Box'
       'box' => 'box.tv-listings.ananova.com',
       'bravodigital' => 'bravo.co.uk', # Bravo (Digital)
       'britisheurosport' => 'british.eurosport.com', # British Eurosport
       'bsb_movie' => 'sky-premier.sky.com', # Sky Premier
       'bsb_sports' => 'sky-sports-1.sky.com', # yes, really
       'carlton_2' => 'carlton.com', # Carlton
       'carltoncinema' => 'cinema.carlton.com', # Carlton Cinema
       'carltonfood' => 'food.carlton.com', # Taste CFN
       'cartoon' => 'uk.cartoonnetwork.com', # Cartoon Network
       'central_3' => 'central.carlton.com', # Central
       'ch4_0' => 'channel4.com', # Channel 4
       'ch4_1' => 'channel4.com', # Channel 4
       'ch4_10' => 'channel4.com', # Channel 4
       'ch4_11' => 'channel4.com', # Channel 4
       'ch4_12' => 'channel4.com', # Channel 4
       'ch4_13' => 'channel4.com', # Channel 4
       'ch4_14' => 'channel4.com', # Channel 4
       'ch4_15' => 'channel4.com', # Channel 4
       'ch4_2' => 'channel4.com', # Channel 4
       'ch4_3' => 'channel4.com', # Channel 4
       'ch4_4' => 'channel4.com', # Channel 4
       'ch4_5' => 'channel4.com', # Channel 4
       'ch4_6' => 'channel4.com', # Channel 4
       'ch4_7' => 'channel4.com', # Channel 4
       'ch4_8' => 'channel4.com', # Channel 4
       'ch4_9' => 'channel4.com', # Channel 4
       'ch5_0' => 'channel5.co.uk', # Channel 5
       'ch5_1' => 'channel5.co.uk', # Channel 5
       'ch5_10' => 'channel5.co.uk', # Channel 5
       'ch5_11' => 'channel5.co.uk', # Channel 5
       'ch5_12' => 'channel5.co.uk', # Channel 5
       'ch5_13' => 'channel5.co.uk', # Channel 5
       'ch5_14' => 'channel5.co.uk', # Channel 5
       'ch5_15' => 'channel5.co.uk', # Channel 5
       'ch5_2' => 'channel5.co.uk', # Channel 5
       'ch5_3' => 'channel5.co.uk', # Channel 5
       'ch5_4' => 'channel5.co.uk', # Channel 5
       'ch5_5' => 'channel5.co.uk', # Channel 5
       'ch5_6' => 'channel5.co.uk', # Channel 5
       'ch5_7' => 'channel5.co.uk', # Channel 5
       'ch5_8' => 'channel5.co.uk', # Channel 5
       'ch5_9' => 'channel5.co.uk', # Channel 5
       # FIXME: Ananova calls this 'Channel Islands'
       'channel_4' => 'channel-islands.tv-listings.ananova.com',
       'christian' => 'christian-channel-europe.god-digital.com', # God Channel
       'classicfm' => 'classicfm.co.uk', # Classic FM
       'cnbc' => 'europe.cnbc.com', # CNBC Europe
       'cnn' => 'europe.cnn.com', # CNN
       # FIXME cannot find domain for '.tv' - how do you type that into Google?
       'computer' => 'dot-tv.tv-listings.ananova.com',
       'cymru' => 'radio-cymru.bbc.co.uk', # Radio Cymru
       'discoverycivilisations' => 'civilisations.discoveryeurope.com', # Discovery Civilisations
       'discoverydigital' => 'discoveryeurope.com', # Discovery (Digital)
       'discoverykids' => 'kids.discoveryeurope.com', # Discovery Kids
       # Maybe 'Plus 1' means timewarped
       # by one hour.  There needs to be
       # some convention for that. 
       'discoveryplus1' => 'plus-1.discoveryeurope.com', # Discovery Plus 1
       'discoveryscitrek' => 'sci-trek.discoveryeurope.com', # Discovery Sci Trek
       'discoverytravel' => 'travel.discoveryeurope.com', # Discovery Travel & Adventure
       'discoverywings' => 'wings.discoveryeurope.com', # Discovery Wings
       'disney' => 'disneychannel.disney.co.uk', # The Disney Channel
       'e4' => 'e4.channel4.com', # E4
       'family_channeldigital' => 'challengetv.co.uk', # Challenge TV (Digital)
       'fantasy' => 'fantasy.televisionx.co.uk', # Fantasy Channel
       'filmfour' => 'filmfour.channel4.com', # Film on Four
       'filmfourextreme' => 'extreme.filmfour.channel4.com', # FilmFour Extreme
       'filmfourplus1' => 'plus-1.filmfour.channel4.com', # FilmFour+1
       'filmfourworld' => 'world.filmfour.channel4.com', # FilmFour World
       'foxdigital' => 'foxkids.co.uk', # Fox Kids Network (Digital)
       'foxplus1' => 'plus-1.foxkids.co.uk', # Fox Kids Plus 1
       'grampian_5' => 'grampiantv.co.uk', # Grampian
       'granada_6' => 'granadatv.co.uk', # Granada (site down ATM)
       'granada_breezeondigital' => 'breeze.granadatv.co.uk', # Granada Breeze
       'granada_men' => 'men.granadatv.co.uk', # Granada Men & Motors
       'granada_plus' => 'plus.granadatv.co.uk', # Granada Plus
       'historydigital' => 'thehistorychannel.co.uk', # History Channel (Digital)
       'htvwales_7' => 'wales.htv.co.uk', # HTV Wales
       'htvwest_8' => 'west.htv.co.uk', # HTV West
       'itv2' => 'itv2.itv.co.uk', # ITV2
       'itvsport' => 'sport.itv.co.uk', # ITV Sport
       'itvsportplus' => 'sport-plus.itv.co.uk', # ITV Sport
       'landscape' => 'landscapetv.com', # Landscape Channel
       'm2' => 'm2europe.com',	# M2
       'meridian_15' => 'meridian.tv.co.uk', # Meridian
       'meridian_9' => 'meridian.tv.co.uk', # Meridian
       'mtv' => 'mtv.co.uk',	# MTV
       'mtvbase' => 'base.mtv.co.uk', # MTV Base
       'mtvdance' => 'dance.mtv.co.uk', # MTV Dance
       'mtvextra' => 'hits.mtv.co.uk', # MTV Hits
       # musicchoice.co.uk is down
       'musicchoiceblues' => 'blues.musicchoice.co.uk', # Music Choice Blues
       'musicchoiceclassical' => 'classical.musicchoice.co.uk', # Music Choice Classical
       'musicchoicecountry' => 'country.musicchoice.co.uk', # Music Choice Country
       'musicchoicedance' => 'dance.musicchoice.co.uk', # Music Choice Dance
       'musicchoiceeasy' => 'easy.musicchoice.co.uk', # Music Choice Easy
       'musicchoicegold' => 'gold.musicchoice.co.uk', # Music Choice Gold
       'musicchoicehits' => 'hits.musicchoice.co.uk', # Music Choice Hits
       'musicchoicejazz' => 'jazz.musicchoice.co.uk', # Music Choice Jazz
       'musicchoicelove' => 'love.musicchoice.co.uk', # Music Choice Love
       'musicchoicerock' => 'rock.musicchoice.co.uk', # Music Choice Rock
       'mutv' => 'mutv.manutd.com', # MUTV
       'nagaeltachta' => 'rnag.ie', # Radio na Gaeltachta
       'nationalgeographicdigital' => 'nationalgeographic.co.uk', # National Geographic (Digital)
       'nickelodeon' => 'nickelodeon.co.uk', # Nickelodeon
       'nickelodeonjr' => 'jr.nickelodeon.co.uk', # Nickelodeon Jr
       'nickelodeonreplay' => 'replay.nickelodeon.co.uk', # Nickelodeon Replay
       'paramount' => 'paramountcomedy.com', # Paramount Comedy
       'performance' => 'performancetv.co.uk', # Performance
       'playboy' => 'playboy.com', # Playboy Channel
       'qvc' => 'qvcuk.com',	# QVC
       'racing' => 'racingchannel.com', # The Racing Channel
       'radio1' => 'radio-1.bbc.co.uk',
       'radio2' => 'radio-2.bbc.co.uk',
       'radio3' => 'radio-3.bbc.co.uk',
       'radio4' => 'radio-4.bbc.co.uk',
       'radio5mw' => 'radio-5-mw.bbc.co.uk',
       # Ananova internal name wrong
       'radioireland' => 'todayfm.com', # Today FM
       'radioscotland' => 'radio-scotland.bbc.co.uk', # Radio Scotland
       'radioulster' => 'radio-ulster.bbc.co.uk', # Radio Ulster
       'rte1_12' => 'rte-1.rte.ie', # RTE 1
       'rte2_12' => 'rte-2.rte.ie', # RTE 2
       'rteradio1' => 'radio-1.rte.ie', # RTE Radio 1
       'rteradio2' => '2-fm.rte.ie', # 2 FM
       'rteradiofm3' => 'lyric-fm.rte.ie', # Lyric FM
       's4c_7' => 's4c.co.uk',	# S4C (Welsh Channel 4)
       's4cdigital' => 'digital.s4c.co.uk', # Channel 4 - Wales (Digital)
       'scificable' => 'cable.uk.scifi.com', # Sci-Fi (Cable)
       'scifidigital' => 'digital.uk.scifi.com', # Sci-Fi (Digital)
       'scottish_10' => 'scottishtv.co.uk', # Scottish
       'shop' => 'shop-tv.co.uk', # Shop!
       'sky_boxofficedigital' => 'box-office-digital.sky.com', # Sky Box Office Digital
       'sky_channel' => 'sky-one.sky.com', # Sky One
       'sky_eurosport' => 'eurosport.sky.com', # Eurosport
       'sky_moviemax2' => '2.moviemax.sky.com', # Sky Moviemax 2
       'sky_moviemax3' => '3.moviemax.sky.com', # Sky Moviemax 3
       'sky_moviemax4' => '4.moviemax.sky.com', # Sky Moviemax 4
       'sky_moviemax5' => '5.moviemax.sky.com', # Sky Moviemax 5
       'sky_moviemaxondigital' => 'itvdigital.moviemax.sky.com', # Sky Moviemax - Ondigital
       'sky_movies' => 'moviemax.sky.com', # Sky Moviemax
       'sky_moviesgolddigital' => 'cinema.sky.com', # Sky Cinema (Digital)
       'sky_news' => 'sky-news.sky.com', # Sky News
       'sky_oneondigital' => 'ondigital.sky-one.sky.com', # Sky One (Ondigital)
       'sky_premier2' => '2.premier.sky.com', # Sky Premier 2
       'sky_premier3' => '3.premier.sky.com', # Sky Premier 3
       'sky_premier4' => '4.premier.sky.com', # Sky Premier 4
       'sky_premierondigital' => 'ondigital.premier.sky.com', # Sky Premier - Ondigital
       'sky_premierwidescreen' => 'widescreen.premier.sky.com', # Sky Premier - Widescreen
       'sky_sports2' => '2.sports.sky.com', # Sky Sports 2
       'sky_sports3' => '3.sports.sky.com', # Sky Sports 3
       'sky_sportsnews' => 'news.sports.sky.com', # Sky Sports.comTV
       'skycinema2' => '2.cinema.sky.com', # Sky Cinema 2
       'sonytv' => 'setindia.com', # Sony Entertainment TV Asia
       'talkradiouk' => 'talk-radio.co.uk', # Talk Sport, apparently
       'tara' => 'taratv.net',	# TARA
       'tcm' => 'tcm.turner.com', # TCM (Digital)
       'tlcdigital' => 'home.discoveryeurope.com', # Discovery Home & Leisure (Digital)
       'traveldigital' => 'travelchannel.co.uk', # The Travel Channel (Digital)
       'troubledigital' => 'trouble.co.uk', # Trouble (Digital)
       'tvasia' => 'tvasia.com', # ZEE TV (maybe not right)
       'tvtravelshop' => 'tvtravelshop.co.uk', # TV Travel Shop
       'tyne_11' => 'tttv.granadatv.co.uk', # North East
       'ukarena' => 'uk-drama.flextech.telewest.co.uk', # UK Drama
       'ukgold' => 'uk-gold.flextech.telewest.co.uk', # UK Gold
       'ukgoldclassics' => 'uk-gold-2.flextech.telewest.co.uk', # UK Gold 2
       'ukhorizons' => 'uk-horizons.flextech.telewest.co.uk', # UK Horizons
       'ukliving' => 'living.flextech.telewest.co.uk', # Living
       'ukplay' => 'play.flextech.telewest.co.uk', # Play UK
       'ukstyle' => 'uk-style.flextech.telewest.co.uk', # UK Style
       'ulster_12' => 'utv.co.uk', # Ulster
       'vh1' => 'vh1online.co.uk', # VH1
       'vh1classic' => 'classic.vh1online.co.uk', # VH1 Classic
       'virgin' => 'virginradio.co.uk', # Virgin
       'wales' => 'radio-wales.bbc.co.uk', # Radio Wales
       'wellbeing' => 'wellbeing.com', # Wellbeing
       'westcountry_13' => 'westcountry.carlton.com', # West Country
       'worldsvc' => 'world-svc.bbc.com', # World Service
       'ytv_14' => 'yorkshire.granadatv.co.uk', # Yorkshire
      );
    return %ch_to_output;
}	      


# Routines to handle a symmmetric 'relation'.  This is used to keep
# track of which programmes are sharing a clump so that fix_clumps()
# can sort them out if needed.
# 
# FIXME make this into a module.
# 
sub new_relation() {
    die 'usage: new_relation()' if @_;
    my %h; tie %h, 'Tie::RefHash';
    return \%h;
}
sub related($$$) {
    die 'usage: related(relation, a, b)' if @_ != 3;
    my ($rel, $a, $b) = @_;
    my $list = $rel->{$a};
    return 0 if not defined $list;
    foreach (@$list) {
	return 1 if "$_" eq "$b";
    }
    return 0;
}
sub relate($$$) {
    die 'usage: related(relation, a, b)' if @_ != 3;
    my ($rel, $a, $b) = @_;
    unless (related($rel, $a, $b)) {
	push @{$rel->{$a}}, $b;
	push @{$rel->{$b}}, $a;
    }
}
sub unrelate($$$) {
    die 'usage: related(relation, a, b)' if @_ != 3;
    my ($rel, $a, $b) = @_;
    die unless related($rel, $a, $b) and related($rel, $b, $a);
    @{$rel->{$a}} = grep { "$_" ne "$b" } @{$rel->{$a}};
    @{$rel->{$b}} = grep { "$_" ne "$a" } @{$rel->{$b}};
}    
sub nuke_from_rel($$) {
    die 'usage: nuke_from_rel(relation, a)' if @_ != 2;
    my ($rel, $a) = @_;
    die unless ref($rel) eq 'HASH';
    foreach (@{relatives($rel, $a)}) {
	die unless related($rel, $a, $_);
	unrelate($rel, $a, $_);
    }

    # Tidy up by removing from hash
    die if defined $rel->{$a} and @{$rel->{$a}};
    delete $rel->{$a};
}
sub relatives($$) {
    die 'usage: relatives(relation, a)' if @_ != 2;
    my ($rel, $a) = @_;
    die unless ref($rel) eq 'HASH';
    if ($rel->{$a}) {
	return [ @{$rel->{$a}} ]; # make a copy
    }
    else {
	return [];
    }
}
