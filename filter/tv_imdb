#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_imdb - Augment XMLTV listings files with imdb.com data.

=head1 SYNOPSIS

tv_imdb --imdbdir <dir> [--help] [--quiet][[--prepStage (1-5,all)]| [--stats][--output FILE] [FILE...]]

=head1 DESCRIPTION

Very similar to tv_cat in symantics (see tv_cat)
except whenever a programme appears with "date" entry the
title and date are used to look up extra data by using the
XMLTV::IMDB package.

B<--output FILE> write to FILE rather than standard output

B<--quiet> disable all status messages (that normally appear on stderr).

B<--stats> force output of grab stats (stats output disabled in --quiet mode).

Warning, only programmes date fields in the form of 4 digit years qualify
for movie look ups. Look ups are case insensitive, when a case mismatch occurs,
the titleE<39>s case, as defined by imdb.com will be used.

All programs that donE<39>t have a E<39>dateE<39> field are now looked up as being
possible tv series. In the case of an exact match, we donE<39>t update the
E<39>dateE<39> field, and only update the E<39>directorE<39> field if only one is listed
with imdb.com

Currently inserts actors (in billing order), directors (in name order),
category (based on imdb.com categorized match), url (to www.imdb.com for
program) and updates date entries and titles to be exact matches of
what we found on imdb.com site.

=head1 HOWTO
In order to use tv_imdb, you need:

B<1.> choose a directory location to use for the tv_imdb database (youE<39>ll
need about 1/2 GB of free space),

B<2.> run E<39>tv_imdb --imdbdir <dir> --prepStage allE<39>, it will fail,
giving you a list of files you need to download from imdb.com.

B<3.> download the list files (what imdb.com calls their E<39>plain textE<39> interface)n
(see http://www.imdb.com/interfaces for locations etc).

B<4.> rerun tv_imdb with --prepStage all. This stage sucks a bit of memeory, but
you can run each prepStage separately by running --preStage with each of the
stages (see --help for details).

Once you have the database loaded try
E<39>cat tv.xml | tv_imdb --imdbdir <dir> > tv1.xmlE<39>.

Feel free to report any problems with these steps to xmltv-devel@lists.sf.net.
=head1 BUGS

For now, tv_imdb uses a system call to look(1) to search the tv_imdb
created indexes. A future version may support a platform independent
approach.

Could use a --configure step just like the grabbers so you do not have
to specify the --imdbdir on the command line every time. Also this could
step you through the prep stages with more description of what is being
done and what is required. Configure could also control the number of
actors to add (since some movies have an awful lot), currently we are
adding the top 3.

Needs some more controls for fine tuning "close" matches. For instance,
currently it looks like the tv_grab_na grabber only has date entries for
movies, but the imdb.com data contains tv series and tv mini series
information so its possible to get the wrong data to be inserted. In this
case we may want to say "ignore tv series" and "ignore tv mini series".
Along with this, weE<39>d want to define what a "close" match is. For instance
does a movie by the same title with a date out by 1 year or 2 years considered
a match (currently weE<39>re using 2).

Nice to haves include: verification/addition of programe MPAA/VCHIP ratings,
addition of imdb.com user ratings (by votes) to programes. Potenially we
could expand to include "country of origin", "description", "writer" and
"producer" credits, maybe even "commentator".

Heh, if the XMLTV.dtd supported it, we could even include urls to head
shots of the actors :)

=head1 SEE ALSO

L<xmltv(5)>, L<look(1)>

=head1 AUTHOR

Jerry Veldhuis, jerry@matilda.com

=cut

use strict;
use Data::Dumper;
use Getopt::Long;

use XMLTV;
use XMLTV::Usage <<END
$0: augment listings with data from imdb.com
usage: $0 --imdbdir <dir>  [--help] [--quiet] [[--prepStage (1-5,all)]| [--stats][--output FILE] [FILE...]]
END
;
use XMLTV::IMDB;

my ($opt_help, $opt_output, $opt_prepStage, $opt_imdbDir, $opt_quiet, $opt_stats);
GetOptions('help' => \$opt_help,
	   'output=s' => \$opt_output,
	   'prepStage=s' => \$opt_prepStage,
	   'imdbdir=s' => \$opt_imdbDir,
	   'quiet' => \$opt_quiet,
	   'stats' => \$opt_stats) or usage(0);

usage(1) if $opt_help;
usage(1) if ( not defined($opt_imdbDir) );

$opt_quiet=(defined($opt_quiet));
if ( !defined($opt_stats) ) {
    $opt_stats=!$opt_quiet;
}
else {
    $opt_stats=(defined($opt_stats));
}

if ( defined($opt_prepStage) ) {
    if ( $opt_prepStage eq "all" ) {
	for (my $stage=1 ; $stage <= 5 ; $stage++ ) {
	    my $n=new XMLTV::IMDB::Crunch('imdbDir' => $opt_imdbDir,
					  'verbose' => !$opt_quiet);
	    if ( !$n ) {
		exit(1);
	    }
	    my $ret=$n->crunchStage($stage);
	    if ( $ret != 0 ) {
		exit($ret);
	    }
	}
	print "database load complete, let the games begin !\n" if ( !$opt_quiet);
	exit(0);
    }
    else {
	my $n=new XMLTV::IMDB::Crunch('imdbDir' => $opt_imdbDir,
				      'verbose' => !$opt_quiet);
	if ( !$n ) {
	    exit(1);
	}
	my $ret=$n->crunchStage(int($opt_prepStage));
	if ( $ret == 0 && int($opt_prepStage) == 5 ) {
	    print "database load complete, let the games begin !\n" if ( !$opt_quiet);
	}
	exit($ret);
    }
}

my $imdb=new XMLTV::IMDB('imdbDir' => $opt_imdbDir,
			 'verbose' => !$opt_quiet,
			 'cacheLookups' => 1);

#$imdb->{verbose}++;

if ( my $errline=$imdb->sanityCheckDatabase() ) {
    print STDERR "$errline";
    print STDERR "tv_imdb: you need to use --prepStage to rebuild\n";
    exit(1);
}

# test that movie database works okay
my %w_args = ();
if (defined $opt_output) {
    my $fh = new IO::File ">$opt_output";
    die "cannot write to $opt_output\n" if not $fh;
    %w_args = (OUTPUT => $fh);
}

my $numberOfFilesProcessed=0;
my $numberOfSeenChannels=0;
my $numberOfSeenPrograms=0;

my $w;

sub encoding_cb( $ ) {
    die if defined $w;
    $w = new XMLTV::Writer(%w_args, encoding => shift);
}

sub credits_cb( $ ) {
    $w->start(shift);
    $numberOfFilesProcessed++;
}

my %seen_ch;
sub channel_cb( $ ) {
    my $c = shift;
    my $id = $c->{id};
    if (not defined $seen_ch{$id}) {
	$w->write_channel($c);
	$seen_ch{$id} = $c;
	$numberOfSeenChannels++;
    }
    elsif (Dumper($seen_ch{$id}) eq Dumper($c)) {
	# They're identical, okay.
    }
    else {
	warn "channel $id may differ between two files, "
	  . "picking one arbitrarily\n";
    }
}

sub programme_cb( $ ) {
    my $prog=shift;
    my $title=$prog->{title}->[0]->[0];
    
    $numberOfSeenPrograms++;

    # we only add movie information to programmes
    # that have a 'date' element defined (since we need
    # a year to work with when verifing we got the correct
    # hit in the imdb data)
    if ( defined($prog->{date}) &&
	 $prog->{date}=~m/^\d\d\d\d$/o ) {
	my $nprog=$imdb->addMovieInfo($prog, $title, $prog->{date});
	if ( defined($nprog) ) {
	    $prog=$nprog;
	}
    }
    else {
	my $nprog=$imdb->addTVSeriesInfo($prog, $title);
	if ( defined($nprog) ) {
	    $prog=$nprog;
	}
    }
    $w->write_programme($prog);
}

@ARGV = ('-') if not @ARGV;

XMLTV::parsefiles_callback(\&encoding_cb, \&credits_cb,
			   \&channel_cb, \&programme_cb,
			   @ARGV);
$w->end();

if ( $opt_stats ) {
    print STDERR $imdb->getStatsLines($numberOfFilesProcessed, $numberOfSeenChannels, $numberOfSeenPrograms);
}
exit(0);
