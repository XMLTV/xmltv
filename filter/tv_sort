#!/usr/bin/perl -w

=head1 NAME

tv_sort - Sort XMLTV listings files by date, and add stop times.

=head1 SYNOPSIS

tv_sort [--help] [--by-channel] [--output FILE] [FILE...]

=head1 DESCRIPTION

Read XMLTV data and write out the same data sorted in date order.
Where stop times of programmes are missing, guess them from the start
time of the next programme on the same channel.

Tv_sort also performs some sanity checks such as making sure no
two programmes on the same channel overlap.

B<--output FILE> write to FILE rather than standard output

B<--by-channel> sort first by channel id, then by date within each
                channel.

The time sorting is by start time, then by stop time.  Without
B<--by-channel>, if start times and stop times are equal then two
programmes are sorted by internal channel id.  With B<--by-channel>,
channel id is compared first and then times.

You can think of tv_sort as converting XMLTV data into a canonical
form, useful for diffing two files.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Ed Avis, ed@membled.com

=cut

use strict;
use XMLTV::Version '$Id$ ';
use Date::Manip; Date_Init('TZ=UTC');
use Data::Dumper;
use Getopt::Long;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

use XMLTV;
use XMLTV::Usage <<END
$0: sort listings by time, sanity-check and add stop time to programmes
usage: $0 [--help] [--by-channel] [--output FILE] [FILE...]
END
;

# Memoize some subroutines if possible
eval { require Memoize };
unless ($@) {
    foreach (qw/Date_Cmp pd programme_eq/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    # clumpidx_cmp() isn't memoized, since it uses undef arguments and
    # they cause warnings.
    #
}

# Prototype declarations
sub programme_cmp();
sub chan_cmp( $$ );
sub clumpidx_cmp( $$ );
sub overlap( $$ );
sub add_stop( $ );
sub programme_eq( $$ );
sub data_eq( $$ );
sub pd( $ );

my ($opt_help, $opt_output, $opt_by_channel);
GetOptions('help' => \$opt_help, 'output=s' => \$opt_output,
	   'by-channel' => \$opt_by_channel)
  or usage(0);
usage(1) if $opt_help;
@ARGV = ('-') if not @ARGV;
my ($encoding, $credits, $channels, $progs) = @{XMLTV::parsefiles(@ARGV)};
my @progs = @$progs;

# We really want the sort to be stable, so that tv_sort can be
# idempotent.  Since the manual page claims that tv_sort produces a
# 'canonical form', it would be embarrassing otherwise.  Okay, it's
# not really important what to do with clearly stupid listings having
# two different programmes on at exactly the same time on the same
# channel, but since the XMLTV format still allows this we should do
# something sensible.
#
# Accordingly, we use the original ordering of programmes as a
# comparison of last resort.
#
# TODO: use sort 'stable'; pragma with perl 5.8.
#
# This function takes a reference to a list of elements, and a
# comparison function f.  It returns a comparison function f' which
# agrees with f, except that where f would return 0 for two elements,
# f' orders them according to their original position in the list.  In
# other words you can turn any sort into a stable sort.  (Expects the
# sort function to use $a and $b, not function parameters.)
#
sub make_stable_sort_fn( $$ ) {
    use vars '@orig'; local *orig = shift;
    my $f = shift;
    my %orig_order;
    for (my $i = 0; $i < @orig; $i++) {
	$orig_order{$orig[$i]} = $i;
    }
    return sub() {
	my $r = &$f;
	return $r if $r;
	return $orig_order{$a} <=> $orig_order{$b};
    };
}

# Check that a list is sorted according to a given comparison
# function.  Used for debugging.
#
use Carp;
sub check_sorted( $$ ) {
    my $f = shift; die if ref $f ne 'CODE';
    die if ref $_[0] ne 'ARRAY';
    use vars '@l'; local *l = shift;
    use vars '$a'; use vars '$b';
    foreach my $i (0 .. @l - 2) {
	($a, $b) = ($l[$i], $l[$i + 1]);
	if ($f->() > 0) {
	    local $Log::TraceMessages::On = 1;
	    t 'not sorted elements: ' . d($a);
	    t '...and: ' . d($b);
	    croak 'failed to sort correctly';
	}
    }
}

# Split up programmes according to channel
my %chan;
foreach (@progs) {
    push @{$chan{$_->{channel}}}, $_;
}

# Sort each channel individually, and guess stop times.
foreach (keys %chan) {
    my $f = make_stable_sort_fn($chan{$_}, \&programme_cmp);
    @{$chan{$_}} = sort { $f->() } @{$chan{$_}};
    check_sorted(\&programme_cmp, $chan{$_});
    add_stop($chan{$_});
    check_sorted(\&programme_cmp, $chan{$_});
}

# Remove duplicates and sanity-check that there is no overlap on a
# channel.
#
foreach (keys %chan) {
    my $progs = $chan{$_};
    my @new_progs;
    die if not @$progs;

    # Sanity check that no programme starts after it begins.  As with
    # the 'overlapping programmes' check below, this should really be
    # moved into a separate tv_semantic_check or whatever.
    #
    foreach (@progs) {
	next if not defined $_->{stop};
	if (Date_Cmp(pd($_->{start}), pd($_->{stop})) > 0) {
	    warn <<END
programme on channel $_->{channel} stops before it starts: $_->{start}, $_->{stop}
END
  ;
	}
    }

    my $first = shift @$progs;
    while (@$progs) {
	my $second = shift @$progs;
	die if not defined $first or not defined $second;
	t 'testing consecutive programmes to see if the same';
	t 'first: ' . d $first;
	t 'second: ' . d $second;
	if (overlap($first, $second)) {
	    t 'they overlap, are they really identical?';
	    if (programme_eq($first, $second)) {
		# Quietly drop the duplicate.  We could have done the
		# programme_eq() step first but I thought (perhaps
		# wrongly) that it would be expensive, and best called
		# only when we know there is an overlap.  No overlap
		# implies not equal.
		#
		t 'programme_eq() says the same, drop the duplicate';
		next;
	    }
	    else {
		local $^W = 0;
		warn <<END
overlapping programmes on channel $_:
    $first->{title}->[0]->[0]\tat $first->{start}-|$first->{stop}
and $second->{title}->[0]->[0]\tat $second->{start}-|$second->{stop}
END
  ;
	    }
	}
	push @new_progs, $first;
	$first = $second;
    }
    # Got to the last element.
    push @new_progs, $first;
    $chan{$_} = \@new_progs;
    check_sorted(\&programme_cmp, $chan{$_});
}

# Combine the channels back into a big list.
@progs = ();
foreach (sort keys %chan) {
    push @progs, @{$chan{$_}};
}
unless ($opt_by_channel) {
    # Sort again.  (Could use merge sort.)
    my $f = make_stable_sort_fn(\@progs, \&programme_cmp);
    @progs = sort { $f->() } @progs;
    check_sorted(\&programme_cmp, \@progs);
}

# Write out the new document
t 'writing out data';
t 'new programmes list: ' . d \@progs;
my %w_args = ();
if (defined $opt_output) {
    my $fh = new IO::File ">$opt_output";
    die "cannot write to $opt_output\n" if not $fh;
    %w_args = (OUTPUT => $fh);
}
XMLTV::write_data([ $encoding, $credits, $channels, \@progs ], %w_args);
exit();


# Compare two programme hashes.
sub programme_cmp() {
    my $xa = $a; my $xb = $b;
    my $r;

    # Assume that {start} is always there, as it should be.
    my ($a_start, $b_start) = (pd($xa->{start}), pd($xb->{start}));
    $r = Date_Cmp($a_start, $b_start);
    t "compare start times: " . d $r;
    return $r if $r;

    # But {stop} is optional.  If both progs have stop we sort on it,
    # otherwise it is not used.  (It doesn't seem right to have
    # undefined values taking part in sort comparisons, and besides,
    # it stops tv_sort from being idempotent.)
    #
    my ($a_stop_u, $b_stop_u) = ($xa->{stop}, $xb->{stop});
    if (defined $a_stop_u and defined $b_stop_u) {
	my ($a_stop, $b_stop) = (pd($a_stop_u), pd($b_stop_u));
	$r = Date_Cmp($a_stop, $b_stop);
	t "compare stop times: " . d $r;
	return $r if $r;
    }

    # Channel.  Ideally would sort on pretty name, but no big deal.
    $r = $xa->{channel} cmp $xb->{channel};
    t "compare channels: " . d $r;
    return $r if $r;

    $r = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
    t "compare clumpidxes: " . d $r;
    return $r if $r;

    t 'do not sort';
    return 0;
}


# Compare indexes-within-clump
sub clumpidx_cmp( $$ ) {
    my ($A, $B) = @_;

    if (not defined $A and not defined $B) {
	return 0; # equal
    }
    elsif ((not defined $A and defined $B)
	   or (defined $A and not defined $B)) {
	warn "mismatching clumpidxs: one programme has, one doesn't";
	return undef;
    }
    elsif (defined $A and defined $B) {
	$A =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $A";
	my ($ai, $num_in_clump) = ($1, $2);
	$B =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $B";
	my $bi = $1;
	if ($2 != $num_in_clump) {
	    warn "clumpidx's $A and $B don't match";
	    return undef;
	}
	
	return $ai <=> $bi;
    }
    else { die }
}


# Test whether two programmes overlap in time.  This takes account of
# start time and stop time, and clumpidx (so two programmes with the same
# start and stop times, but different places within the clump, are not
# considered to overlap).
#
sub overlap( $$ ) {
    my ($xa, $xb) = @_;

    my ($xa_start, $xb_start) = (pd($xa->{start}), pd($xb->{start}));
    my ($xa_stop, $xb_stop);	
    for ($xa->{stop}) {
	if (defined) {
	    $xa_stop = pd($_);
	}
    }
    for ($xb->{stop}) {
	if (defined) {
	    $xb_stop = pd($_);
	}
    }

    # If we don't know the stop times we can't do an overlap test; if
    # we know only one stop time we can do only one half of the
    # test.  We assume no overlap if we can't prove otherwise.
    #
    # However, obviously two _identical_ start times on the same
    # channel must overlap, if we make the sensible assumption of
    # nonzero length.
    #
    { local $^W = 0;
      t "xa: $xa_start -| $xa_stop"; t "xb: $xb_start -| $xb_stop" }
    if ((
	 # XB starts while XA on
	 defined $xa_stop and Date_Cmp($xa_start, $xb_start) <= 0
	 and Date_Cmp($xb_start, $xa_stop) < 0
	)
	or (
	    # XA starts while XB on
	    defined $xb_stop and Date_Cmp($xb_start, $xa_start) <= 0
	    and Date_Cmp($xa_start, $xb_stop) < 0
	   )
	or (
	    # XB starts while XA on - because it starts at the same time
	    Date_Cmp($xa_start, $xb_start) == 0
	   )
       ) {
	my $cmp = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
	if (not defined $cmp) {
	    # No clumpidxes, so must overlap.  (Also happens if
	    # the two indexes were not comparable - but that will
	    # have been warned about already.)
	    #
	    t 'no clumpidxes, overlap';
	    return 1;
	}
	t 'compared clumpidxes: same? ' . not $cmp;
	return not $cmp;
    }
    t 'no time overlap, returning 0';
    return 0;
}


# Add 'stop time' to a list of programmes (hashrefs).
# The stop time of a programme is the start time of the next.
#
# Parameters: reference to list of programmes, sorted by date, to be
# shown consecutively (except for 'clumps').
#
# Modifies the list passed in.
#
sub add_stop( $ ) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: add_stop(ref to list of programme hashrefs)' if @_ != 1;
    use vars '@l'; local *l = shift;
  P: for (my $i = 0; $i < @l; $i++) {
	my $p = $l[$i];
	next if defined $p->{stop};
	t 'programme without stop time: ' . d $p;
	my @following = @l[$i + 1 .. $#l];
	t 'following programmes: ' . d \@following;
	t 'looking for first following with different start time';
	foreach my $f (@following) {
	    my $cmp = Date_Cmp(pd($f->{start}), pd($p->{start}));
	    if ($cmp < 0) {
		die 'strange, programmes not sorted in add_sort()';
	    }
	    elsif ($cmp == 0) {
		# The following programme has the same start time as
		# this one.  Don't use it as a stop time, that would
		# make this one be zero length.
		#
	    }
	    elsif ($cmp > 0) {
		$p->{stop} = $f->{start};
		next P;
	    }
	    else { die }

	    if (defined $f->{stop}) {
		$p->{stop} = $f->{stop};
		next P;
	    }
	}
	# Well, there really is nothing we can guess a time from.
    }
}


# Equality of two programmes.  Probably the biggest failing of Perl
# is that it has no simple way to ask: are these two data structures
# equal?  Previously I was using Data::Dumper to stringify and compare
# the resulting strings, but some versions of that module don't
# list hash keys in a consistent order (so two equal hashes
# become different strings).  Aargh...
#
# TODO: move this code into an XMLTV library, or better, into a CPAN
# module.  I can't believe there isn't one already.
#
sub data_eq( $$ ) {
    my ($a, $b) = @_;
    my ($da, $db) = (defined $a, defined $b);
    if (not $da and not $db) {
	# Two undefined values are equal.
	return 1;
    }
    elsif (not $da and $db) {
	return 0;
    }
    elsif ($da and not $db) {
	return 0;
    }
    elsif ($da and $db) {
	# Proceed.
    }
    else { die }

    my ($ra, $rb) = (ref $a, ref $b);
    return 0 if $ra ne $rb;

    if (not $ra) {
	return ($a eq $b);
    }
    elsif ($ra eq 'REF') {
	return data_eq($$a, $$b);
    }
    elsif ($ra eq 'SCALAR') {
	return data_eq($$a, $$b);
    }
    elsif ($ra eq 'ARRAY') {
	return 0 if @$a != @$b;
	foreach (0 .. $#$a) {
	    return 0 if not data_eq($a->[$_], $b->[$_]);
	}
	return 1;
    }
    elsif ($ra eq 'HASH') {
	my @ka = sort keys %$a;
	my @kb = sort keys %$b;
	return 0 if not data_eq(\@ka, \@kb);
	foreach (@ka) {
	    return 0 if not data_eq($a->{$_}, $b->{$_});
	}
	return 1;
    }
    elsif ($ra eq 'CODE') {
	die 'cannot compare code references';
    }
    elsif ($ra eq 'GLOB') {
	# Ugh.
	die 'cannot compare references to typeglobs';
    }
    else {
	die "cannot compare $ra, $rb objects";
    }
}
sub programme_eq( $$ ) {
    t 'comparing programmes ' . d($_[0]) . ' and ' . d($_[1]);
    return data_eq($_[0], $_[1]);
}

# Wrapper for ParseDate().
sub pd( $ ) {
    for ($_[0]) {
	return undef if not defined;
	my $r = ParseDate($_);
	die "bad date $_" if not defined $r;
	return $r;
    }
}
