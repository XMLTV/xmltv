#!/usr/bin/perl -w
#
# $Id$
#
# tv_sort
#
# Sort the programmes in an XMLTV file according to:
#   - start time, or
#   - stop time, or
#   - internal channel name
#
# and guess stop time for each programme if it isn't already given.
# This converts an XMLTV listing into a kind of 'canonical form'.
#
# Usage: tv_sort [filename]
#
# See release notes and/or cvs logs entries for module history
#
# -- Ed Avis, epa98@doc.ic.ac.uk, 2001-12-11
#

use strict;
use XMLTV;
use Date::Manip; Date_Init(); # we call ParseDate() while sorting
use Log::TraceMessages qw<t d>; Log::TraceMessages::check_argv(); $| = 1;
use Data::Dumper;
use Getopt::Long;


# Memoize some subroutines if possible
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
}
else {
    foreach (qw/Date_Cmp ParseDate programme_eq/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    # clumpidx_cmp() isn't memoized, since it uses undef arguments and
    # they cause warnings.
    #
}

# Prototype declarations
sub programme_cmp();
sub chan_cmp( $$ );
sub clumpidx_cmp( $$ );
sub overlap( $$ );
sub add_stop( $ );
sub programme_eq( $$ );
sub usage( ;$ );

my ($opt_help, $opt_output);
GetOptions('help' => \$opt_help, 'output=s' => \$opt_output);
usage(1) if $opt_help;
my $filename;
if (@ARGV == 0) {
    $filename = '-';
}
elsif (@ARGV == 1) {
    $filename = $ARGV[0];
}
elsif (@ARGV >= 2) {
    usage();
}
else { die }

my ($encoding, $credits, $channels, $progs) = @{XMLTV::read_data($filename)};
my @progs = @$progs;

# Split up programmes according to channel
my %chan;
foreach (@progs) {
    push @{$chan{$_->{channel}}}, $_;
}

# Sort each channel individually, and guess stop times.
foreach (keys %chan) {
    @{$chan{$_}} = sort programme_cmp @{$chan{$_}};
    add_stop($chan{$_});
}

# Remove duplicates and sanity-check that there is no overlap on a
# channel.
#
foreach (keys %chan) {
    my $progs = $chan{$_};
    my @new_progs;
    die if not @$progs;
    my $first = shift @$progs;
    while (@$progs) {
	my $second = shift @$progs;
	die if not defined $first or not defined $second;
	if (overlap($first, $second)) {
	    if (programme_eq($first, $second)) {
		# Quietly drop the duplicate.  We could have done the
		# programme_eq() step first but I thought (perhaps
		# wrongly) that it would be expensive, and best called
		# only when we know there is an overlap.  No overlap
		# implies not equal.
		#
		next;
	    }
	    else {
		local $^W = 0;
		warn <<END
overlapping programmes on channel $_:
    $first->{title}->[0]->[0]\tat $first->{start}-|$first->{stop}
and $second->{title}->[0]->[0]\tat $second->{start}-|$second->{stop}
END
  ;
	    }
	}
	push @new_progs, $first;
	$first = $second;
    }
    # Got to the last element.
    push @new_progs, $first;
    $chan{$_} = \@new_progs;
}


# Mix the channels back into a big list and sort again (could use
# merge sort).
#
@progs = ();
foreach (keys %chan) {
    push @progs, @{$chan{$_}};
}
@progs = sort programme_cmp @progs;

# Write out the new document
t 'writing out data';
t 'new programmes list: ' . d \@progs;
my %w_args = ();
if (defined $opt_output) {
    my $fh = new IO::File ">$opt_output";
    die "cannot write to $opt_output\n" if not $fh;
    %w_args = (OUTPUT => $fh);
}
XMLTV::write_data([ $encoding, $credits, $channels, \@progs ], %w_args);
exit();


# Compare two programme hashes.
sub programme_cmp() {
    my $xa = $a; my $xb = $b;
    my $r;

    # Assume that {start} is always there, as it should be.
    my ($a_start, $b_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    if (not defined $a_start) {
	die "cannot parse start time: $xa->{start}";
    }
    if (not defined $b_start) {
	die "cannot parse start time: $xb->{start}";
    }
    $r = Date_Cmp($a_start, $b_start);
    t "compare start times: " . d $r;
    return $r if $r;

    # But {stop} is optional.  If both progs have stop we sort on it,
    # otherwise it is not used.  (It doesn't seem right to have
    # undefined values taking part in sort comparisons, and besides,
    # it stops tv_sort from being idempotent.)
    #
    my ($a_stop_u, $b_stop_u) = ($xa->{stop}, $xb->{stop});
    if (defined $a_stop_u and defined $b_stop_u) {
	my ($a_stop, $b_stop) = (ParseDate($a_stop_u), ParseDate($b_stop_u));
	if (not defined $a_stop) {
	    die "cannot parse stop time: $a_stop_u";
	}
	if (not defined $b_stop) {
	    die "cannot parse stop time: $b_stop_u";
	}
	$r = Date_Cmp($a_stop, $b_stop);
	t "compare stop times: " . d $r;
	return $r if $r;
    }

    # Channel.  Ideally would sort on pretty name, but no big deal.
    $r = $xa->{channel} cmp $xb->{channel};
    t "compare channels: " . d $r;
    return $r if $r;

    $r = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
    t "compare clumpidxes: " . d $r;
    return $r if $r;

    t 'do not sort';
    # No warning, because we'll be weeding out duplicates later.  This
    # routine should just do what it's told and compare.
    #
    return 0;
}


# Compare indexes-within-clump
sub clumpidx_cmp( $$ ) {
    my ($A, $B) = @_;

    if (not defined $A and not defined $B) {
	return 0; # equal
    }
    elsif ((not defined $A and defined $B)
	   or (defined $A and not defined $B)) {
	warn "mismatching clumpidxs: one programme has, one doesn't";
	return undef;
    }
    elsif (defined $A and defined $B) {
	$A =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $A";
	my ($ai, $num_in_clump) = ($1, $2);
	$B =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $B";
	my $bi = $1;
	if ($2 != $num_in_clump) {
	    warn "clumpidx's $A and $B don't match";
	    return undef;
	}
	
	return $ai <=> $bi;
    }
    else { die }
}


# Test whether two programmes overlap in time.  This takes account of
# start time and stop time, and clumpidx (so two programmes with the same
# start and stop times, but different places within the clump, are not
# considered to overlap).
#
sub overlap( $$ ) {
    my ($xa, $xb) = @_;

    my ($xa_start, $xb_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    die "cannot parse start time: $xa->{start}" if not defined $xa_start;
    die "cannot parse start time: $xb->{start}" if not defined $xb_start;
    my ($xa_stop, $xb_stop);	
    for ($xa->{stop}) {
	if (defined) {
	    $xa_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xa_stop;
	}
    }
    for ($xb->{stop}) {
	if (defined) {
	    $xb_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xb_stop;
	}
    }

    # If we don't know the stop times we can't do an overlap test; if
    # we know only one stop time we can do only one half of the
    # test.  We assume no overlap if we can't prove otherwise.
    #
    { local $^W = 0;
      t "xa: $xa_start -| $xa_stop"; t "xb: $xb_start -| $xb_stop" }
    if ((
	 # XB starts while XA on
	 defined $xa_stop and Date_Cmp($xa_start, $xb_start) <= 0
	 and Date_Cmp($xb_start, $xa_stop) < 0
	) or (
	      # XA starts while XB on
	      defined $xb_stop and Date_Cmp($xb_start, $xa_start) <= 0
	      and Date_Cmp($xa_start, $xb_stop) < 0
	     )
       ) {
	my $cmp = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
	if (not defined $cmp) {
	    # No clumpidxes, so must overlap.  (Also happens if
	    # the two indexes were not comparable - but that will
	    # have been warned about already.)
	    #
	    t 'no clumpidxes, overlap';
	    return 1;
	}
	t 'compared clumpidxes: same? ' . not $cmp;
	return not $cmp;
    }
    t 'no time overlap, returning 0';
    return 0;
}


# Add 'stop time' to a list of programmes (hashrefs).
# The stop time of a programme is the start time of the next.
#
# Parameters: reference to list of programmes, sorted by date, to be
# shown consecutively (except for 'clumps').
#
# Modifies the list passed in.
#
sub add_stop( $ ) {
    die 'usage: add_stop(ref to list of programme hashrefs)' if @_ != 1;
    my $l = shift;

    my $this_start; # Start time of current clump
    my $next_start; # Start time of next clump
    my $next_next_start; # Start time of next-but-one clump
    for (my $i = $#$l; $i >= 0; $i--) {
	my $this = $l->[$i];
	my $clumpidx = $this->{clumpidx};
	$clumpidx = '0/1' if not defined $clumpidx;
	$clumpidx =~ s!/\d+$!!; # not interested in clump size
	$clumpidx =~ m!^\d+$! or die "bad clumpidx '$_->{clumpidx}'";
	
	$this_start = $this->{start};
	if (not defined $this->{stop} and defined $next_start) {
	    if ($next_start ne $this_start) {
		$this->{stop} = $next_start;
	    }
	    else {
		# Special handling for overlapping programmes: going
		# backwards in time and finding one programme
		# immediately before another with the same start time.
		# We should guess the stop time to be the same as the
		# stop time for the overlapping programme.
		#
		# This is for the case you have the following three
		# programmes:
		#   A from 00 to ?
		#   A from 00 to ?
		#   B from 01 to 02
		# We need to make the two As have the same stop time.
		#
		$this->{stop} = $next_next_start
		  if defined $next_next_start;
	    }
	}

	if ($clumpidx == 0) {
	    # First programme in clump - we're going backwards, so
	    # next time we will move on to the previous clump.
	    #
	    if (not defined $next_start
		or $this_start ne $next_start) {
		($next_start, $next_next_start) = ($this_start, $next_start);
	    }
	}
    }
}


# Equality of two programmes.  The programme details are just text, so
# we can stringify the whole data structure and compare that.  We do
# assume that Data::Dumper will list hashes in a consistent order.  We
# don't care what the order is, just as long as it's the same each
# time.
#
sub programme_eq( $$ ) {
    t 'comparing programmes ' . d($_[0]) . ' and ' . d($_[1]);
    my $r = Dumper($_[0]) eq Dumper($_[1]);
    t "equal? $r";
    return $r;
}


# If optional parameter true, is 'help message'.
sub usage( ;$ ) {
    my $is_help = shift;
    my $msg = <<END
$0: sort listings by time, sanity-check and add stop time to programmes
usage: $0 [--help] [--output FILE] [FILE]
END
;
    if ($is_help) {
	print $msg;
	exit(0);
    }
    else {
	print STDERR $msg;
	exit(1);
    }
}
