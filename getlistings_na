#!/usr/bin/perl -w
#
# $Id$
#
# This script scrapes www.zap2it.com tv listings, producing
# xmltv.dtd and channels.dtd compliant output. Zap2it supports
# both Canadian and US listings.
#
# Feel free to contact me with comments, contributions,
# and the like. jerry@matilda.com 
#
# Known Bugs
#  - no longer supports --startHour and --endHour parameters
#    defaults to scraping an entire day's schedules. 
#  - not all program qualifiers have been defined, so sometimes
#    program descriptions include qualifiers that are unidentified
#    These should be reported to the author
#
# See release notes and/or cvs logs entries for module history
#

my $VersionMajor="2";
my $VersionMinor="0";

my $VersionID="getlistings_na V$VersionMajor\.$VersionMinor";

#
# define name of getlistings_na config file
#
my $ConfigFileName_g=".xmltv_na";
my $ConfigPathName_g;

# default location of config file is $HOME or ./ if HOME not set
if ( defined($ENV{HOME}) ) {
    $ConfigPathName_g="$ENV{HOME}/$ConfigFileName_g";
}
else {
    $ConfigPathName_g="./$ConfigFileName_g";
}

use strict;

package myConfig;

sub new
{
    my($type) = shift;
    my $self={ @_ };            # remaining args become attributes
    
    bless($self, $type);
    return($self);
}

sub setValue($$$)
{
    my ($self, $key, $value)=@_;
    $self->{$key}=$value;
    if ( $key ne "option_postalcode" &&
	 $key ne "option_zipcode" &&
	 $key ne "option_provider" &&
	 $key ne "option_provider_desc" ) {
	die "attempt to set invalid key $key to $value";
    }
}

sub unsetValue($$$)
{
    my ($self, $key, $value)=@_;
    delete($self->{$key}) if ( defined($self->{$key}));
}

#
# get list of stations in display-name order
#
# sad but true, I can't figure a better way of
# doing this, but then again I don't care - jv
#
sub stationsInDisplayOrder($)
{
    my $self=shift;

    # create reverse hash with key/values swapped
    my @nums;
    foreach my $station (keys (%{$self->{channels}})) {
	my $key=0;
	if ( $station=~m/^\s*(\d+)/o ) {
	    $key=$1;
	}
	# seems very odd, but occasionally, you get two channels with the
	# same channel # on the dial
	if ( defined($nums[$key]) ) {
	    $nums[$key]="$nums[$key],$station";
	}
	else {
	    $nums[$key]="$station";
	}
    }
    
    my @ret;
    for (my $n=0; $n<scalar(@nums) ; $n++ ) {
	if ( defined($nums[$n]) ) {
	    push(@ret, sort (split(',', $nums[$n])))
	}
    }
    return(@ret);
}

sub haveAnyChannels($)
{
    my $self=shift;
    return(defined($self->{channels}));
}

sub stationRemove($$)
{
    my ($self, $station)=@_;
    delete($self->{channels}->{$station});
}

sub stationExists($$)
{
    my ($self, $station)=@_;
    return(defined($self->{channels}->{$station}));
}

sub setStationIncluded($$$)
{
    my ($self, $station, $in)=@_;
    $self->{channels}->{$station}->{in}=$in;
}

sub stationIncluded($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{in});
}

sub stationIcon($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{icon});
}

sub setStationIcon($$$)
{
    my ($self, $station, $icon)=@_;
    $self->{channels}->{$station}->{icon}=$icon;
}

sub setStationTransientFlag($$$$)
{
    my ($self, $station, $flag, $value)=@_;
    $self->{channels}->{$station}->{transient}->{$flag}=$value;
}

sub getStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    return($self->{channels}->{$station}->{transient}->{$flag});
}

sub removeStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    delete($self->{channels}->{$station}->{transient}->{$flag});
}

sub save($$)
{
    my ($self, $file)=@_;

    open(FD, "> $file") || return(-1);
    print FD "# config file: getlistings_na $VersionMajor.$VersionMinor\n";
    print FD "#\n";
    print FD "# this file is generated by running getlistings_na --configure\n";
    print FD "# the only change you should make is prefixing 'channel:' lines\n";
    print FD "# with a '#' to signal that they should be ignored during the\n";
    print FD "# grab step\n";
    print FD "#\n";
    if ( defined($self->{option_postalcode})) {
	print FD "postal code: $self->{option_postalcode}\n";
    }
    if ( defined($self->{option_zipcode}) ) {
	print FD "zip code: $self->{option_zipcode}\n";
    }
    print FD "provider: $self->{option_provider} \# ".
	$self->{option_provider_desc}."\n";
    
    foreach my $station ($self->stationsInDisplayOrder()) {
	if ( $self->stationIncluded($station) ) {
	    print FD "channel: $station\n"
	}
	else {
	    print FD "#channel: $station\n";
	}
    }
    close(FD);
    return(0);
}

sub load($$$)
{
    my ($self, $file, $debug)=@_;

    my $majorVersion;
    open(FD, "< $file") || return(-1);
    while (<FD>) {
	s/\n$//o;

	# auto-upgrading from version 1 to 2
	if ( defined($majorVersion) && $majorVersion == 1 ) {
	    if ( m/^\#+channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="#channel: $2";
	    }
	    elsif ( m/^channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="channel: $2";
	    }
	}

	if ( $. == 1 ) {
	    if ( m/^\#\s+config\s+file:\s*getlistings_na (\d+)\.(\d+)/o ) {
		$majorVersion=$1;
		if ( $1 == 1 ) {
		    print STDERR "$file: older format identified, coping, re-run --configure to upgrade\n";
		}
		elsif ( $1 != $VersionMajor || $2 > $VersionMinor ) {
		    print STDERR "$0: $file:$.: $1\.$2 is an unsupported version number\n";
		    close(FD);
		    return(-1);
		}
	    }
	    else {
		print STDERR "$0: $file:$.: unsupported version header\n";
		close(FD);
		return(-1);
	    }
	}
	elsif ( m/^postal code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_postalcode", $1);
	}
	elsif ( m/^zip code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_zipcode", $1);
	}
	elsif ( m/^provider:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->setValue("option_provider", $1);
	    $self->setValue("option_provider_desc", $2);
	}
	elsif ( m/^\#+channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 0);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 1);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^#/o ) {
	    next;
	}
	elsif ( m/^\s*$/o ) {
	    # ignore empty lines
	}
	else {
	    print STDERR "$0: $file:$.: invalid\n";
	    close(FD);
	    return(-1);
	}
	   
    }
    close(FD);
    if ( defined($self->{option_postalcode}) && defined($self->{option_zipcode})) {
	print STDERR "$0: $file: corrupt, only one of postal or zip can be defined\n";
	return(-1);
    }
    return(0);
}

1;

package main;

use strict;
#use diagnostics;
use Fcntl qw(:DEFAULT);
use XML::Writer;
use IO;
use Getopt::Long;
use ZapListings;
use Date::Manip;
use File::Basename;

#
# How this grabber works:

# Step 1 - Configure
#  
#   The configure step is meant to be run interactively.
#   You can use 'getlistings_na --configure --help' to see
#   how to run non-interactively, providing information on
#   the command line.

#   run 'getlistings_na --configure'
#
#   Follow the prompts to provide the necessary information.
#
#   When finished, configure will create a file $HOME/$ConfigFileName_g
#   which contains the postal/zip code, the provider id
#   and a line for each channel that provider supplies.
#   This file is what you specify with the --config command
#   line option to "Step 2 Grabbing Data". See Step 2 for details
#   of how this file is interpreted.
#

sub ConfigureUsage
{
    print "usage $0 --configure [options]\n";
    print "where options are:\n";
    print "   --help\n";
    print "     print configure help\n";
    print "\n";
    print "   --debug\n";
    print "     turn on debugging\n";
    print "\n";
    print "   --postalcode XXXXXX\n";
    print "     specify postal code, don't use with --zipcode\n";
    print "\n";
    print "   --zipcode YYYYYY\n";
    print "     specify zip code, don't use with --postalcode\n";
    print "\n";
    print "   --provider ZZZZZZZ\n";
    print "     specify provider id\n";
    print "\n";
    print "   --config <file>\n";
    print "     write results of configure to <file> instead of \$HOME/$ConfigFileName_g\n";
    print "\n";
    print "If any neccessary options are given, interactive mode is enabled\n";
    print "Result of running configure is a xml formated configuration file\n";
    print "\$HOME/$ConfigFileName_g (use --config to override location).\n";
}

# Step 2 - Grab
#   
#   The grab step uses the information collected during
#   configuration to get tv listings.
#  
#
#

sub Usage
{
    print "usage $0 [--help|--configure [configure-options] |[grab-options]]\n";
    print "command line options are:\n";
    print "   --help\n";
    print "     print this help\n";
    print "     use --configure --help for configure help or\n";
    print "     use --grab --help for grab help\n";
    print "\n";
    print "   --configure\n";
    print "     run configuration step, see --configure --help for more info\n";
    print "\n";
    print "grab-options are:\n";
    print "   --debug\n";
    print "     turn on debugging\n";
    print "\n";
    print "   --config <file>\n";
    print "     specify file that contains config information, default in \$HOME/$ConfigFileName_g\n";
    print "     (created by using --configure)\n";
    print "\n";
    print "   --listings <file>\n";
    print "       specify listings.xml filename(s) for channel & program info\n";
    print "       <file> may contain Date::Manip::Unix substitutions\n";
    print "       for instance, use --listings \"listings-%d%m%Y.xml\" to separate output by day.\n";
    print "       similarily, %postalcode, %zipcode, are also substituted from settings\n";
    print "       current configuration.\n";
    print "       The filename is only re-evaluated when a new days listings is started.\n";
    print "       if no --listings is specified stdout is used\n";
    print "\n";
    print "   --output <file>\n";
    print "       synonym for --listings\n";
    print "\n";
    print "   --days n\n";
   print "       specify number of days to include in output (default 7)\n";
}


# First lets check to see if someone asked for help.
# this is easier to do here than later.
my $configure=0;
if ( @ARGV ) {
    foreach my $arg (@ARGV) {
	$configure=1 if ( $arg=~m/^--configure/o );
        if ( $arg=~m/^--debug/o ) { $SIG{__WARN__} = sub { die $_[0] }; }
    }
}

sub ask($)
{
    print "$_[0]";
    my $result=<>;
    chop($result) if ( defined($result) );
    return($result);
}

sub askyesorno($$)
{
    my ($def, $question)=@_;
    while ( 1 ) {
	my $res=ask("$question [$def] ");
	if ( !defined($res) || $res eq "" ) {
	    return($def);
	}
	$res=~tr/[A-Z]/[a-z]/;
	if ( $res eq "yes" ) {
	    return("yes");
	}
	elsif ( $res eq "no" ) {
	    return("no");
	}
	else {
	    print STDERR "invalid response, please use yes or no\n";
	    print STDERR "\n";
	}
    }
}

if ( $configure ) {
    use vars qw/$opt_configure $opt_help $opt_postalcode $opt_zipcode $opt_provider $opt_config $opt_debug/;

    $opt_debug=0;

    if ( ! GetOptions('configure', 'help', 'postalcode=s', 'zipcode=s', 'provider=s', 'config=s', 'debug') ) {
	ConfigureUsage();
	exit(1);
    }

    if ( defined($opt_help) ) {
	ConfigureUsage();
	exit(0);
    }

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config) ) {
	$configfile=$opt_config;
    }

    if ( -f $configfile && $config->load($configfile, $opt_debug) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	exit(1);
    }

    if ( defined($opt_postalcode) && defined($opt_zipcode) ) {
	print STDERR "$0: only one of --postalcode and --zipcode is allowed\n";
	exit(1);
    }

    # command line arguments
    if ( defined($opt_postalcode) ) {
	$config->setValue("option_postalcode", $opt_postalcode);
	$config->unsetValue("option_zipcode");
	$config->unsetValue("option_provider");
    }

    if ( defined($opt_zipcode) ) {
	$config->setValue("option_zipcode", $opt_zipcode);
	$config->unsetValue("option_postalcode");
	$config->unsetValue("option_provider");
    }
    
    if ( defined($opt_provider) ) {
	$config->setValue("option_provider", $opt_provider);
	$config->setValue("option_provider_desc", ""); # unknown so reset to ''
    }

    # sanity check
    if ( defined($config->{option_postalcode}) && defined($config->{option_zipcode})) {
	print STDERR "$0: only one of postal or zip code can be defined\n";
	exit(1);
    }

    #
    # Go interactive to collect what we don't have
    #

    my $msg="Welcome to XMLTV $VersionID for Canada and US tv listings";
    print "$msg\n";
    print "-" x length($msg);
    #for (my $i=0; $i<length($msg); $i++ ) {print "-";};
    print "\n";
    print "Please report any problems, bugs or suggestions to:\n";
    print "\txmltv-users\@lists.sourceforge.net\n";
    print "For more information consult http://xmltv.sourceforge.net\n\n";
    print "starting manual configuration process..\n";
    print "\n";
  
    # if we have no postal code or zip code, the prompt for it
    if ( !defined($config->{option_postalcode}) && !defined($config->{option_zipcode})) {
	my $res=ask('what is your postal/zip code ?');
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	   # $res=~tr/[a-z]/[A-Z]/;
	    if ( $res=~m/^[a-zA-Z]/o ) {
		$config->setValue("option_postalcode", $res);
	    }
	    else {
		$config->setValue("option_zipcode", $res);
	    }
	}
	else {
	    print STDERR "$0: failed to get postal/zip code\n";
	    exit(1);
	}
    }
    
    # get list of providers and give them the choice
    if ( !$config->{option_provider} ) {

	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	print STDERR "\ngetting list of providers for postal/zip code $code, be patient..\n";
	my @providers=ZapListings::getProviders($config->{option_postalcode},
						$config->{option_zipcode},
						$opt_debug);
	if ( ! @providers || !defined($providers[0]) ) {
	    #print STDERR "$0: failed to get list of providers for postal/zip code $code\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}

	while ( !$config->{option_provider} ) {
	    print "\n";
	    print "Id   \tService Provider\n";
	    print "-----\t---------------------------\n";
	    for my $p (@providers) {
		print "$p->{id}\t$p->{description}\n";
	    }
	    print "\n";
	    my $res=ask("Choose a service provider by id (use '0' to cancel):");
	    if ( defined($res) ) {
		if ( $res eq '0' ) {
		    print "operation cancelled by user\n";
		    exit(0);
		}
		for my $p (@providers) {
		    if ( $res eq $p->{id} ) {
			$config->{option_provider}=$p->{id};
			$config->{option_provider_desc}=$p->{description};
		    }
		}
	    }
	}
    }

    # if we're in the configure step, lets refresh the list of channels
    # being careful to warn about additions and deletions
    
    if ( $config->haveAnyChannels() ) {
	print STDERR "\nchecking for changes to channel list, be patient..\n";
    }
    else {
	print STDERR "\ngetting channel list, be patient..\n";
    }

    my @channels=ZapListings::getChannelList($config->{option_postalcode},
					     $config->{option_zipcode},
					     $config->{option_provider},
					     $opt_debug);
    
    if ( ! @channels || !defined($channels[0]) ) {
	#print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
	#print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	exit(1);
    }

    my $channelsUpdated=0;

    # notify user about update channel ids and new channels
    foreach my $channel (@channels) {
	my $station=$channel->{description};
	if ( $config->haveAnyChannels() ) {
	    if ( $config->stationExists($station) ) {
		$config->setStationTransientFlag($station, 'found', 1);
	    }
	    else {
		my $res=askyesorno('yes', "add channel $station ?");
		$res=~tr/[A-Z]/[a-z]/;
		$config->setStationIncluded($station, ($res eq 'yes'));
		$config->setStationTransientFlag($station, 'found', 1);
		#$config->setStationDescription($station, $channel->{description});
		$channelsUpdated++;
	    }
	}
	else {
	    my $res=askyesorno('yes', "add channel $station ?");
	    $res=~tr/[A-Z]/[a-z]/;
	    $config->setStationIncluded($station, ($res eq 'yes'));
	    $config->setStationTransientFlag($station, 'found', 1);
	    #$config->setStationDescription($station, $channel->{description});
	    $channelsUpdated++;
	}
    }

    # warn about channel declarations we didn't find
    foreach my $station ($config->stationsInDisplayOrder()) {
	if ( defined($config->getStationTransientFlag($station, 'found')) ) {
	    $config->removeStationTransientFlag($station, 'found');
	}
	else {
	    my $res=askyesorno('yes', "drop no-longer available channel $station ?");
	    $res=~tr/[A-Z]/[a-z]/;
	    if ( $res eq 'yes' ) {
		#print STDERR "warning: didn't find channel id: $station \#".
		#    $config->stationDescription($station)."\n";
		$config->stationRemove($station);
		$channelsUpdated++;
	    }
	}
    }

    if ( $channelsUpdated == 0 ) {
	if ( $config->haveAnyChannels() ) {
	    print STDERR "\nchannel line-up hasn't changed\n";
	}
	else {
	    print STDERR "\nno channels added\n";
	}
    } 

    # write out config file
    print STDERR "\nupdating $configfile..\n";
    if ( $config->save($configfile) != 0 ) {
	print STDERR "$0: $configfile save failed\n";
	exit(1);

    }

    print STDERR "\nconfiguration step complete, let the games begin !\n";
    exit(0);
}

# in grabber mode - yeah !

use vars qw/$opt_help $opt_config $opt_debug $opt_programs $opt_channels $opt_listings $opt_output $opt_days/;

$opt_debug=0;

if ( ! GetOptions('help', 'config=s', 'debug', 'programs=s', 'channels=s', 'listings=s', 'output=s', 'days=i') ) {
    Usage();
    exit(1);
}

# throw error for invalid use of both --listings and --output
if ( defined($opt_output) && defined($opt_listings) ) {
    print STDERR "getlistings_na: only one of --listings or --output can be used at once\n";
    exit(1);
}

# implement --output as synonym for --listings
if ( defined($opt_output) ) {
    $opt_listings=$opt_output;
    undef($opt_output);
}

if ( defined($opt_help) ) {
    Usage();
    exit(0);
}

#
# detect old style usage
#
if ( defined($opt_programs) || defined($opt_channels) ) {
    print STDERR "getlistings_na: new xmltv.dtd format, use --listings instead of\n";
    print STDERR "                --programs and/or --channels\n";
    exit(1);
}

# set defaults if they didn't appear on command line
$opt_listings="" if ( !defined($opt_listings) );
$opt_days=7 if ( !defined($opt_days) );

if ( $opt_days < 0 || $opt_days > 14 ) {
    print STDERR "specified days must be between 1 and 14\n";
    Usage();
    exit(1);
}

STDOUT->autoflush(1);

my @FilesWeOpened_g;

my $failed=grab();

if ( $failed ) {
    print STDERR "cleaning up after failure..\n";
    if ( @FilesWeOpened_g ) {
	for my $file (@FilesWeOpened_g) {
	    if ( -f $file ) {
		#print STDERR "   removing $file\n";
		unlink($file);
	    }
	}
    }
    exit(1);
}
exit(0);

sub writeListingsXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date                  =>Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      'source-info-url'     =>"http://www.zap2it.com",
		      'source-info-name'    =>"Zap2It",
		      'source-data-url'     =>"http://tvlistings2.zap2it.com/textall.asp",
		      'generator-info-name' =>"$VersionID",
		      'generator-info-url'  =>'http://www.sourceforge.net/projects/xmltv');
}

sub writeListingsXMLFooter($)
{
    my $writer=shift;
    $writer->endTag('tv');
}

sub mkpathtofile($$)
{
    my ($file, $debug)=@_;
    my @paths;

    my $path=dirname($file);
    if ( -d $path ) {
	return(1);
    }
    print STDERR "making path: $path..\n" if ( $debug );
    while (length($path)!=0 && $path ne "." && $path ne "/" ) {
	push(@paths, $path);
	$path=dirname($path);
    }

    foreach my $dir (@paths) {
	if ( ! -d $dir ) {
	    print STDERR "mkdir($dir, 0775)\n" if ( $debug > 1 );
	    mkdir($dir, 0775) || return(-1);
	}
	else {
	    print STDERR "$dir exists, not making\n" if ( $debug > 1);
	}
    }
    return(1);
}

sub grab
{
    # initalize global XML::Writer if we're writting listings to stdout
    # or if all listings are to being output'd to a single file.
    # The later allows us to use --listings tv.xml with more than one days listings.
    my $writer_g;

    # output_g is only used if we are writting all Listings to the same file.
    my $output_g;

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config) ) {
	if ( ! -f $opt_config ) {
	    print STDERR "$0: specified config file '$opt_config' does not exist, run --configure\n";
	    return(1);
	}
	$configfile=$opt_config;
    }
    else {
	if ( ! -f $configfile ) {
	    print STDERR "$0: config file '$configfile' does not exist, run --configure\n";
	    return(1);
	}
    }

    if ( $config->load($configfile, $opt_debug) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	return(1);
    }
    
    # collect information about channels.
    if ( 1 ) {
	
	print STDERR "double checking channel information, be patient..\n";

	my @channels=ZapListings::getChannelList($config->{option_postalcode},
						 $config->{option_zipcode},
						 $config->{option_provider},
						 $opt_debug);
    
	if ( ! @channels || !defined($channels[0]) ) {
	    #print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}
	
	my $channelsUpdated=0;

	# notify user about update channel ids and new channels
	foreach my $channel (@channels) {
	    my $station=$channel->{description};
	    if ( $config->haveAnyChannels() ) {
		if ( $config->stationExists($station) ) {
		    $config->setStationTransientFlag($station, 'found', 1);

		    # save zap2it channel id for grabbing url usage
		    $config->setStationTransientFlag($station, 'zap2it-id', $channel->{stationid});
		    
		    if ( defined($channel->{icon}) ) {
			$config->setStationIcon($station, $channel->{icon});
		    }
		}
		else {
		    print STDERR "Noticed new station available ($station), re-run --configure\n";
		}
	    }
	    else {
		print STDERR "Noticed new station available ($station), re-run --configure\n";
	    }
	}

	# warn about channel declarations we didn't find
	foreach my $station ($config->stationsInDisplayOrder()) {
	    if ( defined($config->getStationTransientFlag($station, 'found')) ) {
		$config->removeStationTransientFlag($station, 'found');
	    }
	    else {
		print STDERR "Noticed station unavailable ($station), re-run --configure\n";
		$config->setStationTransientFlag($station, 'notavailable', 1);
	    }
	}

	if ( $channelsUpdated++ ) {
	    print STDERR "some channel information is out of date, re-run --configure\n";
	}
    }

    my $stats;

    $stats->{num_channels}=0;
    $stats->{num_programs}=0;
    $stats->{num_days}=0;

    # start time only includes programming grabs, no channel detail grab
    my $startTime=time();

    # do %postalcode and %zipcode substitutions now since they can't change
    # if they don't appear, we remove them
    if ( defined($config->{option_postalcode}) ) {
	$opt_listings=~s/%(postal|zip)code/$config->{option_postalcode}/og;
    }
    elsif ( defined($config->{option_zipcode}) ) {
	$opt_listings=~s/%(postal|zip)code/$config->{option_zipcode}/og;
    }
    else {
	$opt_listings=~s/%(postal|zip)code//og;
    }

    if ( !length($opt_listings) ) {
	print STDERR "writing listings to stdout\n";
	$writer_g = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 2 );
    }
    elsif ( UnixDate("now","$opt_listings") eq $opt_listings ) {
	mkpathtofile($opt_listings, $opt_debug) || die "mkdir $opt_listings:$!";
	print STDERR "writing listings to $opt_listings\n";
	$output_g = new IO::File("> $opt_listings") || die "$opt_listings: $!";
	push(@FilesWeOpened_g, $opt_listings);
	$writer_g = new XML::Writer(OUTPUT=>$output_g,
				     DATA_MODE => 1, DATA_INDENT => 2 );
    }
    
    if ( defined($writer_g) ) {
	writeListingsXMLHeader($writer_g);
	$stats->{num_channels}=writeOutChannels($config, $writer_g);
    }

    my $failedCount=0;
    my ($y,$m,$d,$h,$mn,$s)=Date::Manip::Date_Split(ParseDateString("now"));
    my $startNDay=Date_DayOfYear($m,$d,$y);
    my $tz=Date_TimeZone();

    #
    # So that the output a day at a time, this allows for separate files per day
    #
    my $year=$y;
    my $runNDayOfYear=$startNDay;
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	my $writer;
	my $output;

	# handle cross-year listings
	if ( $runNDayOfYear+$nday > Date_DaysInYear($year) ) {
	    $runNDayOfYear-=Date_DaysInYear($year);
	    $year++;
	}
	

	$stats->{num_days}++;;

	my $dateStr=createDateString(0, $runNDayOfYear+$nday, $year, 0, $tz);

	if ( defined($writer_g) ) {
	    $writer=$writer_g;
	}
	else {
	    my $filename=UnixDate($dateStr, "$opt_listings");
	    if ( $opt_listings eq $filename ) {
		die "This case should have been caught before here";
	    }
	    
	    mkpathtofile($filename, $opt_debug) || die "mkdir $opt_listings:$!";
	    print STDERR "writing listings to $filename\n";
	    $output = new IO::File("> $filename") || die "$filename: $!";
	    push(@FilesWeOpened_g, $filename);
	    $writer = new XML::Writer(OUTPUT=>$output,
					 DATA_MODE => 1, DATA_INDENT => 2 );
	    writeListingsXMLHeader($writer);
	    $stats->{num_channels}=writeOutChannels($config, $writer);
	}
	
	my $lg=new ZapListings::Scraper('PostalCode'=> $config->{option_postalcode},
					'ZipCode'   =>$config->{option_zipcode},
					'ProviderID'=>$config->{option_provider},
					'Debug'     =>$opt_debug);

	foreach my $station ($config->stationsInDisplayOrder()) {
	    
	    next if ( !$config->stationIncluded($station) );
	    
	    if ( defined($config->getStationTransientFlag($station, 'notavailable')) ) {
		print STDERR "skipping unavailable channel $station\n";
		next;
	    }

	    if ( !defined($config->getStationTransientFlag($station, 'zap2it-id')) ) {
		warn "ignoring channel without zap2it channel id $station\n";
		next;
	    }

	    my ($Year,$month,$day,$hr,$min,$sec)=Date::Manip::Date_NthDayOfYear($year, $runNDayOfYear+$nday);
	    
	    if ( $lg->readSchedule($config->getStationTransientFlag($station, 'zap2it-id'),
				   $station,
				   $day, $month, $Year) == -1 ) {
		warn("readSchedule failed for $Year-$month-$day for station $station");
		$failedCount++;
	    }
	    else {
		# set time zone for date conversions
		#Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
		#Date::Manip::Date_Init();
		
		$stats->{num_programs}+=writeOutPrograms($lg, $runNDayOfYear+$nday, $Year, $tz, $writer, $station);
	    }
	}
	
	if ( !defined($writer_g) || $writer != $writer_g ) {
	    writeListingsXMLFooter($writer);
	    $writer->end();
	    $output->close();
	}
    }

    if ( defined($writer_g) ) {
	writeListingsXMLFooter($writer_g);
	$writer_g->end();
	$output_g->close() if ( defined($output_g) );
    }

    my $endTime=time();
    printf(STDERR "Grabbed %d programs on %d channels over %d day(s) in %d seconds\n",
	   $stats->{num_programs},
	   $stats->{num_channels},
	   $stats->{num_days},
	   $endTime-$startTime);

    printf(STDERR "  not too bad, that's %.2f programs/sec and %.2f seconds/www page\n",
	   $stats->{num_programs}/($endTime-$startTime),
	   ($endTime-$startTime)/($stats->{num_days}*$stats->{num_channels}));
	    
    return($failedCount);
}

# create a conversion string
sub createDateString($$$$$)
{
    my ($minuteOfDay, $dayOfYear, $year, $additionalMin, $time_zone)=@_;
    
    if ( $additionalMin != 0 ) {
	$minuteOfDay+=$additionalMin;

	# deal with case where additional minutes pushes us over end of day
	if ( $minuteOfDay > 24*60 ) {
	    $minuteOfDay-=24*60;
	    $dayOfYear++;

	    # check and deal with case where this pushes us past end of year
	    my $isleap=Date_LeapYear($year);
	    if ($dayOfYear >= ($isleap ? 367 : 366)) {
		$year++;
		$dayOfYear-=($isleap ? 367 : 366);
	    }
	}
    }

    # account for end of year boundaries
    if ( $dayOfYear > Date_DaysInYear($year) ) {
	$dayOfYear-=Date_DaysInYear($year);
	$year++;
    }

    # calculate year,month and day from nth day of year info
    my ($pYEAR,$pMONTH,$pDAY,$pHR,$pMIN,$pSEC)=Date::Manip::Date_NthDayOfYear($year, $dayOfYear);

    # set HR and MIN to what they should really be
    $pHR=int($minuteOfDay/60);
    $pMIN=$minuteOfDay-($pHR*60);

    return(sprintf("%4d%02d%02d%02d%02d00 %s", $pYEAR, $pMONTH, $pDAY, $pHR, $pMIN, $time_zone));
}

sub writeOutPrograms($$$$$$)
{
    my ($lg, $dayOfYear, $year, $mytz, $writer, $channel)=@_;
    my $IncludePartialPrograms=0;

    my @programs=$lg->getPrograms();

    for my $prog (@programs) {

	$prog->{start}=createDateString(($prog->{start_hour}*60+$prog->{start_min}), $dayOfYear, $year, 0, $mytz);
	delete($prog->{start_hour});
	delete($prog->{start_min});
	if ( $prog->{end_hour} >= 24 ) {
	    $prog->{end}=createDateString((($prog->{end_hour}-24)*60+$prog->{end_min}), $dayOfYear+1, $year, 0, $mytz);
	}
	else {
	    $prog->{end}=createDateString(($prog->{end_hour}*60+$prog->{end_min}), $dayOfYear, $year, 0, $mytz);
	}
	delete($prog->{end_hour});
	delete($prog->{end_min});

	my $title=$prog->{title};
	    
	#print STDERR "storing $title..\n";

	if ( defined($prog->{contFromPreviousListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which starts previous to listing\n";
		next;
	    }
	    $title="(<-cont) $title";
	}
	if ( defined($prog->{contToNextListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which ends past listing boundaries\n";
		next;
	    }
	    $title="$title (cont->)";
	}
	
	$writer->startTag('programme', start=> $prog->{start}, 
			  stop => $prog->{end}, channel=> "$channel");
	$writer->dataElement('title', $title);
	$writer->dataElement('sub-title', $prog->{subtitle}) if ( defined($prog->{subtitle}) );
	$writer->dataElement('desc', $prog->{desc}) if ( defined($prog->{desc}) );
		
	if ( defined($prog->{director}) || defined($prog->{actors}) ) {
	    $writer->startTag('credits');
	    $writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
	    if ( defined($prog->{actors}) ) {
		foreach my $actor (@{$prog->{actors}}) {
		    $writer->dataElement('actor', $actor);
		}
	    }
	    $writer->endTag('credits');
	}
	$writer->dataElement('date', $prog->{year}) if ( defined($prog->{year}) );
	
	if ( defined($prog->{category}) ) {
	    foreach my $cat(@{$prog->{category}}) {
		$writer->dataElement('category', $cat);
	    }
	}
	# hunt for things in the "qualifiers bucket" where alot of things fall.
	if ( defined($prog->{qualifiers}) ) {
	    if ( defined($prog->{qualifiers}->{PaidProgram}) ) {
		# FIXME I don't that payment counts as a
		# 'category'.  Though there should probably be
		# some way to include it.  -- epa98@doc.ic.ac.uk
		# 
		$writer->dataElement('category', "advertisement");
	    }
	    if ( defined($prog->{qualifiers}->{Language}) ) {
		if ( defined($prog->{qualifiers}->{Dubbed}) ) {
		    $writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		    $writer->dataElement('language', $prog->{qualifiers}->{Dubbed});
		}
		else {
		    $writer->dataElement('language', $prog->{qualifiers}->{Language});
		}
	    }
	    
	    if ( defined($prog->{qualifiers}->{Taped}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{InProgress}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		# nowhere to put this
		# comes in the form of "Part 1 of 2"
	    }
	    if ( defined($prog->{qualifiers}->{Live}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{CallIn}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{Animated}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{HDTV}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		$writer->startTag('video');
		$writer->dataElement('colour', 'no');
		$writer->endTag('video');
	    }
	    if ( defined($prog->{qualifiers}->{InStereo}) ) {
		$writer->startTag('audio');
		# The 'stereo' element requires some text inside it,
		# so you have to say <stereo>stereo</stereo>.  :-P.
		$writer->dataElement('stereo', 'stereo');
		$writer->endTag('audio');
	    }
	    if ( defined($prog->{qualifiers}->{PreviouslyShown}) ) {
		# Write as <previously-shown /> to indicate there is
		# no textual content, not even the empty string :-).
		$writer->emptyTag('previously-shown');
	    }
	    if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		$writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
	    }
	    if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		$writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
	    }

	    if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		$writer->startTag('subtitles', 'type' => 'onscreen');
		if ( defined($prog->{qualifiers}->{Subtitles}->{Language}) ) {
		    $writer->dataElement('language', $prog->{qualifiers}->{Subtitles}->{Language});
		}
		$writer->endTag('subtitles');
	    }
	    elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		# Write as <subtitles></subtitles> to show that there
		# _could_ be subelements, they're just not there.
		$writer->dataElement('subtitles', '', 'type' => "teletext");
	    }
	}
	if ( defined($prog->{ratings_VCHIP}) ) {
	    $writer->startTag('rating', system => 'VCHIP');
	    if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		$writer->dataElement('value', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}");
	    }
	    else {
		$writer->dataElement('value', $prog->{ratings_VCHIP});
	    }
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_MPAA}) ) {
	    $writer->startTag('rating', 'system' =>'MPAA');
	    $writer->dataElement('value', $prog->{ratings_MPAA});
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_ESRB}) ) {
	    $writer->startTag('rating', 'system' => 'ESRB');
	    $writer->dataElement('value', $prog->{ratings_ESRB});
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_Warnings}) ) {
	    my %hash;
	    foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		$hash{$k}=1;
	    }
	    foreach my $k ( keys %hash ) {
		$writer->startTag('rating', 'system' => 'General Warning');
		$writer->dataElement('value', $k);
		$writer->endTag('rating');
	    }
	}
	if ( defined($prog->{star_rating}) ) {
	    # comes in the form of a rating out fraction X/Y (X out of Y)
	    $writer->startTag('star-rating');
	    $writer->dataElement('value', $prog->{star_rating});
	    $writer->endTag('star-rating');
	}
	$writer->endTag('programme');
    }
    return(scalar(@programs));
}

# write the channels in xml format
sub writeOutChannels($$)
{
    my ($config, $writer)=@_;

    my $count=0;
    foreach my $station ($config->stationsInDisplayOrder()) {
	
	next if ( defined($config->getStationTransientFlag($station, 'notavailable')) );
	next if ( !$config->stationIncluded($station));

	$writer->startTag('channel', id=> $station);

	$writer->dataElement('display-name', "Channel $station");
	if ( defined($config->stationIcon($station)) ) {
	    # Write as empty tag because icon can never contain anything.
	    $writer->emptyTag('icon', 'src'=>$config->stationIcon($station));
	}

	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
	$count++;
    }

    return($count);
}

1;
