#!/usr/bin/perl -w
#
# $Id$
#
# tvcheck
#
# This script searches a channel GUIDE for shows in a show list and alerts when
# a listed show is missing from it's time slot, or shows up at other days or times.
#
# The show list is a custom XML format.
# The channel guide needs to be in XMLTV format.
#
# syntax
#       tvcheck --listings=file --show=file (--configure|--scan (--output))) 
#
# (C)2001 - Robert Eden, free to use under the GNU License.
#
#  Robert Eden - reden@cpan.org
#  	
#     See cvs logs entries for module history
#
#
use Tk;
use Tk::TableMatrix;
use XML::Simple;
use Date::Manip;
use Data::Dumper;
use Getopt::Long;
use XMLTV;
use Lingua::Preferred qw(which_lang);

#
# Define constants
#
select STDERR; $|=1;
select STDOUT; $|=1;
@WEEKDAY  = qw (Sun Mon Tue Wed Thu Fri Sat);
$WEEKDAY  = "SunMonTueWedThuFriSat   ";

#    COL_TYPE  1:List 2:Entry 3:checkbox
@COL       = qw(day channel hhmm len title chanonly dayonly timeonly neartime);
@COL_TYPE  = qw(1         1    2   2     1       3       3         3        3);

$CONFIGURE= 0;
$GUIDE_XML= 'guide.xml';
$SHOW_XML = 'shows.xml';
$OUTPUT_FILE = undef;
$TODAY    = $WEEKDAY[(localtime())[6]];

#
# Global Vars
#
@SHOWS        = (); # raw show data
$SHOW_TABLE   = ""; # stores pointer to SHOW_TABLE
@SHOW_DATA    = (); # pointer to raw by SHOW_TABLE row
%SHOW_DATA    = (); # data for SHOW_TABLE
%SHOW_WIDTH   = (); # column widths for SHOW_TABLE

$SHOW_CHANGED = 0;  # updated if show needs to be saved
$SHOW_SORT    = 4;  # column to sort SHOW_TABLE
$SHOW_ROW     = 0;  # last selected row

@GUIDE     = ();    # episode list
%GUIDE     = ();    # episode indexes

@CHAN      = ();    # channel list (sorted)
%CHAN      = ();    # channel list ( channel-id key )

@SELECT    = ();    # array of selector widgits

$ADD_BUTTON = "";
$DELETE_BUTTON = "";
$UPDATE_BUTTON = "";
$CLEAR_BUTTON  = "";

@LANG         = ();    # preferred languages

$COL_VALUE[$_] = "" foreach (0..$#COL);

#
# Step 1, Parse Parameters -------------------------------------------------------
#
# First lets check to see if someone asked for help.
# this is easier to do here than later.
{
    my $scan=0;
    if ( ! GetOptions('configure'        => \$CONFIGURE,
                      'scan'             => \$scan,
                      'shows=s'          => \$SHOW_XML,
                      'output=s'         => \$OUTPUT_FILE,
                      'guide|listings=s' => \$GUIDE_XML))
    {
        print " tvcheck v \$Revision\$\n\n";
        print " part of the xmltv toolkit ( http://xmltv.sourceforge.net )\n\n";
        print "usage $0 (--configure|--scan) [--options] [--output=file]\n";
        print "where --options are:\n";
        print "   --shows <file>\n";
        print "     xml files with show info (default shows.xml )\n";
        print "\n";
        print "   --listings <file>\n";
        print "     xml files with guide info (default guide.xml )\n";
        print "\n";
        print "   --configure\n";
        print "     run configuration GUI instead of checking listings\n";
        print "\n";
    	exit(1);
    } # HelpUsage

    die "Please select either --scan, --configure, or --help\n" if ($CONFIGURE+$scan != 1);
    if (defined $OUTPUT_FILE)
    {
           print STDERR "Sending output to $OUTPUT_FILE\n";
           open(STDOUT,">$OUTPUT_FILE") or die "Can't open for output $OUTPUT_FILE\n";
    }

} # get params

load_shows($SHOW_XML);
load_guide($GUIDE_XML);

#
# Step 3, is it time to CONFIGURE?  --------------------------------------------------------
#
if ($CONFIGURE)
{
#
# create main window!
#

$TOP = MainWindow->new;

#
# configure menu bar
#
{
my $menubar = $TOP->Menu(-type => 'menubar');

$TOP->OnDestroy( sub{
                      return if changed_check(1);
                      $TOP -> destroy();
                    }
                );

$TOP->configure(-menu => $menubar );

my $f = $menubar->cascade(-label => '~File', -tearoff => 0);
$f->command(-label   => 'New',
            -underline => 0,
            -command => sub {
                             $SHOW_XML='';
                             @SHOWS=();
                             load_show_table();
                             });

$f->command(-label   => 'Open...',
            -underline => 0,
            -command => sub {
                            return if changed_check();
                        	my $file = $TOP->getOpenFile(-filetypes => [["XML Files",".xml"]],
                                       -title => 'Open Show File');
                            load_shows($file) if defined $file;
                            });


$f->command(-label   => 'Save',
            -underline => 0,
            -command => \&Save_shows );

$f->command(-label   => 'Save As...',
            -underline => 5,
            -command => sub {
                              my $file = $TOP->getSaveFile( -filetypes => [["XML Files",".xml"]],
	                                                            -title => 'Save show file');
                              if (defined $file)
                              {
                                 $SHOW_XML=$file;
                                 Save_shows();
                              }
                            });

$f->command(-label   => 'Listings...',
            -underline => 0,
            -command => sub {
                        	my $file = $TOP->getOpenFile(-filetypes => [["XML Files",".xml"]],
             	                                         -title => 'Open Listing File' );
                            load_guide($file) if defined ($file);
                            });


$f->command(-label   => 'Exit',
            -underline => 1,
            -command => sub {
                              return if changed_check();
                              $TOP -> destroy();
                             });

my $h = $menubar->cascade(-label => '~Help', -tearoff => 0);
$h->command(-label   => 'Help',
            -underline => 0,
            -command => \&help_popup );

$h->command(-label   => 'About',
            -underline => 0,
            -command => \&help_about );

} # menu bar

#
# create show table
#
$SHOW_TABLE = $TOP->Scrolled('TableMatrix',
                  -cols => ($#COL+1),
                  -rows => ($#SHOWS > 8 ? $#SHOWS+2 : 10 ),
                  -height   => 10,
   	              -titlerows => 1,
                  -variable => \%SHOW_DATA,
                  -roworigin =>  0,  -colorigin  => 0, 
		          -colstretchmode => 'all',
                  -selecttype => 'row',
                  -sparsearray => 1,
			      -state => 'disabled',
                  -anchor => 'w',
                  -exportselection => 0,
                  );
$SHOW_TABLE->colWidth( %SHOW_WIDTH );
$SHOW_TABLE->pack(-expand => 1, -fill => 'both');
$SHOW_TABLE->bind('<1>', sub {
            my $w   = shift;
            my $Ev  = $w->XEvent;
            my $row = $w->index('@'.$Ev->x.",".$Ev->y,"row");
            my $col = $w->index('@'.$Ev->x.",".$Ev->y,"col");
            
            $w->selectionClear('all');
            $SHOW_ROW=0;
            $UPDATE_BUTTON -> configure ( -state => "disabled" );
            $DELETE_BUTTON -> configure ( -state => "disabled" );

            if ($row)
            {
                return unless $SHOW_DATA{"$row,4"}; # title must exist
                $SHOW_ROW=$row;
		        $UPDATE_BUTTON -> configure ( -state => "normal" );
		        $DELETE_BUTTON -> configure ( -state => "normal" );
                $w->selectionSet("$row,0","$row,".($#COL+1));
                for $col (0..$#COL)   # load selection pane
                {
                    $COL_VALUE[$col] = $SHOW_DATA{"$row,$col"};
                } 
            }
            else
            {
                $SHOW_SORT = ($SHOW_SORT == $col ? -$col : $col);
                load_show_table();
            }
}); # show table click bind

my $selframe = $TOP->Frame->pack(-side => 'bottom');
#
# Control Buttons
#
{
    my $frame=$selframe->Frame()->pack( -side => 'left' );
    $CLEAR_BUTTON = 
        $frame->Button( -text    => "Clear Selection",
                       -command => sub{
				     $SHOW_ROW=0;
                     $SHOW_TABLE->selectionClear('all');
				     $UPDATE_BUTTON -> configure ( -state => "disabled" );
				     $DELETE_BUTTON -> configure ( -state => "disabled" );
                                    for $col (0..$#COL)
                                    {
                                        $COL_VALUE[$col]="";
                                    }
                                    load_selection_items();
                                    }) -> pack(-fill => 'x');

    $ADD_BUTTON = 
    $frame->Button( -text    => "Add Selection",
                       -command => sub{
				     $SHOW_ROW=0;
                     $SHOW_TABLE->selectionClear('all');
				     $UPDATE_BUTTON -> configure ( -state => "disabled" );
				     $DELETE_BUTTON -> configure ( -state => "disabled" );
		                     return unless $COL_VALUE[4];
                                    my $row = $#SHOWS+1;
                                    for $col (0..$#COL)
                                    {
                                        my $val=$COL_VALUE[$col];
                            			$val=~ s/^\s+|\s+$//g if defined $val;
                                        $SHOWS[$row]{$COL[$col]}=$val;
                                    }
                                    load_show_table();
                                    $SHOW_CHANGED=1;                                    
				    $COL_VALUE[4]='';
                                    }) -> pack(-fill => 'x');
    $UPDATE_BUTTON =
    $frame->Button( -text    => "Update Show",
		    -state   => "disabled",
                    -command => sub{
                                    return unless $SHOW_ROW;
                                    return unless $COL_VALUE[4];
                                    for $col (0..$#COL)
                                    {
                                        my $val=$COL_VALUE[$col];
                    					$val=~ s/^\s+|\s+$//g if defined $val;
                                        $SHOW_DATA[$SHOW_ROW]{$COL[$col]}=$val;
                                    }
                                    $SHOW_CHANGED=1;
                                    load_show_table();
                                    }) -> pack(-fill => 'x');

    $DELETE_BUTTON =
    $frame->Button( -text    => "Delete Show",
		    -state   => "disabled",
                    -command => sub{
                                    return unless $SHOW_ROW;
                                    $SHOW_DATA[$SHOW_ROW]{title}=undef;
                                    load_show_table();
                                    $SHOW_CHANGED=1;
                                    }) -> pack(-fill => 'x');

} # control buttons

#
# Selector Widgets
# Type 1 ( listbox )
#
foreach $col (0..$#COL)
{
    next unless $COL_TYPE[$col] == 1;
    my $frame =$selframe->Frame()->pack( -side => 'left' );
    my $label =$frame->Label(-text => $COL[$col])->pack();
    my $entry =$frame->Entry(-textvariable => \$COL_VALUE[$col])->pack();
    my $list  =$frame->Scrolled('Listbox',
                         -setgrid    => 1,
                         -height     =>12,
                         -selectmode => 'row',
                         -exportselection => 0,
                         -scrollbars => 'w');
    $list -> {SubWidget} -> {scrolled} -> privateData('Entry') -> {Entry} = $entry;
    $list -> {SubWidget} -> {scrolled} -> privateData('Entry') -> {Col} = $col;
    $list -> pack(qw/-side left -expand yes -fill both/);
    $list -> bind('<ButtonRelease 1>' => sub  {
                            my $w = shift;
                            my $entry = $w->privateData('Entry') -> {Entry};
                            my $col   = $w->privateData('Entry') -> {Col};
			    my $val   = $w->get('active');
print STDERR "Storing ($val) into $col\n";
		     $COL_VALUE[$col]=$val;
             load_selection_items();
             },
          );
    $SELECT[$col]= { frame => $frame,
                     label => $label,
                     entry => $entry,
                     list  => $list };
} # type 1 selectors 

#
# Selector Widgets
# Type 2 ( entry )
# Note: Type 2 and Type 3 share a frame 
#
my $selframe2 =$selframe->Frame()->pack( -side => 'left' );
foreach $col (0..$#COL)
{
    next unless $COL_TYPE[$col] == 2;

    my $frame = $selframe2;
    my $label =$frame->Label(-text => $COL[$col])->pack();
    my $entry =$frame->Entry(-textvariable => \$COL_VALUE[$col])->pack();
    $frame->Label(-text => " ")->pack();

    $SELECT[$col]= { frame => $frame,
                     label => $label,
                     entry => $entry,
                   };
} # type 2 selectors

#
# Selector Widgets
# Type 3 ( checkbox  )
# Note: Type 2 and Type 3 share a frame 
#
foreach $col (0..$#COL)
{
    next unless $COL_TYPE[$col] == 3;

    my $frame = $selframe2;
    my $check = $frame->Checkbutton( -text => $COL[$col],
                                     -variable => \$COL_VALUE[$col],
                                   ) -> pack();

    $SELECT[$col]= { frame => $frame,
                     check => $check,
                   };
} # type 3 selectors 

load_selection_items();

#
# let the games begin!
#
print STDERR "GUI running\n";
Tk::MainLoop;
} # CONFIGURE

#
# Step 3, do an actual tvcheck --------------------------------------------------------
#
else
{

#
# Build show_time index
#
print STDERR "Computing show time index\n";
my $unique=1;
foreach $show (@SHOW_DATA)
{
    my $start;
    
    if ($show->{day})  # deal with shows without a specific day ( phase 2 only )
    {
        $show->{day} = $WEEKDAY[$show->{day}] if ($show->{day} =~ /\d/);
        if ($TODAY eq $show->{day})
        {
           $start=ParseDate(sprintf("Today at %s:%s",substr($show->{hhmm},0,2),
                                                     substr($show->{hhmm},2,2)));
        }
        else
        {
           $start=ParseDate(sprintf("next %s at %s:%s",$show->{day},
                                                       substr($show->{hhmm},0,2),
                                                       substr($show->{hhmm},2,2)));
        }
        ($show->{mmdd},$show->{start}) = UnixDate( $start, "%m%d","%Y%m%d");
     }
     else
     {
        $start="9999".($unique++);
        $show->{mmdd} = "";
     }
    
    unless ($start)
    {
        warn "Unable to get time for $show->{title}\n";
        next;
    }

    $show->{channel}="" unless exists $show -> {channel};
    $SHOW_TIME{$start}{$show->{channel}} = $show;
} #build SHOW_TIME index

#
# let the games begin... process shows!
#
print STDERR "Processing shows\n\n";
foreach $start (sort keys %SHOW_TIME)
{
    foreach $chan (sort keys %{$SHOW_TIME{$start}})
    {
        my $show = $SHOW_TIME{$start}{$chan};
	next unless $show->{title};
#
# See what episode is on at that time
#
    if ( $show -> {mmdd} ) # skip this phase for certain shows
    {
        my $ep = find_episode($show);
        if (!defined $ep)
        {
           printf "%-60s **** NO GUIDE DATA ****\n",sh_summary($show).opt_summary($show);
        }
        elsif ( get_text($ep->{title}) ne $show->{title} )
        {
           printf "%-50s **** wrong show in slot **** \n",sh_summary($show).opt_summary($show);
           print " "x10,ep_summary($ep),"\n";
        }
        else
        {
            $ep->{displayed}=$show;
            print ep_summary($ep),opt_summary($show),"\n";

            if ( $show->{hhmm} ne $ep->{hhmm} )
            {
                print "     ***** Start Time Alert ***** Expected $show->{hhmm} got $ep->{hhmm}\n";
            }
            if ( !$show->{anylen} && $show->{len} ne $ep->{len} )
            {
                print "     ***** LENGTH ALERT ***** Expected $show->{len} got $ep->{len}\n";
            }
        }
    }
    else
    {
       print sh_summary($show),"\n";
    }

#
# See if the show is on at other times
#
    foreach $ep ( @{$GUIDE{all}{$show->{title}}})
    {
        next if $ep->{displayed} eq $show;
        $ep->{displayed}=$show;

        gen_episode_dates($ep) unless $ep->{day};
    
#
# check channel
#
        next if ( $show->{chanonly} && $chan ne $ep->{channel} );


#
# check day
#
        next if ( $show->{dayonly}  && $show->{day} ne $ep->{day});

#
# check time
#
        next if ( $show->{timeonly} && $show->{hhmm} ne $ep->{hhmm});
        if ( $show -> {neartime})
        {
            my $delta = abs( substr($show->{hhmm},0,2) -
                             substr(  $ep->{hhmm},0,2) );
            next unless $delta < 3;
        }

#
# ok, guess we're interested in it, print it
#
        print " "x5,ep_summary($ep,1),"\n";
    } # extra episode scan

  print "\n";
  } # show chan loop
} # show time loop
} # tvcheck scan

#
# That's it, have a nice day
#
print STDERR "Exiting\n";
exit 0;

#
# Support subroutines -------------------------------------------------------
#

sub opt_summary
{
    my $show=shift;
    my @options=();
    foreach (0..$#COL)
    {
        next unless $COL_TYPE[$_] == 3;
        push @options,$COL[$_] if $show->{$COL[$_]};
    }
    return '{'.join(",",@options).'}' if @options;
    return "";
} #opt_summary
    
#
# ep_summary
#
# Print a one-line summary of the specified episode  ( in a subroutine to make changes easier )
#
sub ep_summary
{
    my $ep   = shift || die "ep_summary, how about a episode fella!";
    my $flag = shift || 0;
    
#
# XMLTV format does some wierd things (IMHO) for multi-part episodes. let's deal with it
#
    my $desc = get_text($ep ->{"sub-title"});# || get_text($ep->{desc});
    my $part = "";
    if (exists $ep->{"episode-num"})
    {
      my $text = $ep->{"episode-num"}->[0];
      if ($text =~ m!Part *(\d+) *of *(\d+)!i)
      {
        $part = "$1/$2";
      }
      elsif ($text =~ m!\.\s*(\d+)\s*/\s*(\d+)\s*$!)
      {
        $part = ($1+1)."/$2";
      }
      elsif ($text =~ m!\.\s*(\d+)\s*$!)
      {
	$part = $1+1;
      }
      else
      {
        warn "bad episode-num content $text";
      }
    }
    
    gen_episode_dates($ep) unless $ep->{day};
    
    return join(" ",$ep->{day},
                   $ep->{mmdd},
                   "$ep->{hhmm}/$ep->{len}",
                   get_text($CHAN{ $ep->{channel}}->{'display-name'}),
        		   ($flag ? "" : get_text( $ep->{title} ) ),
        		    "\"$desc\" $part",
        			($ep->{"previously-shown"} ? "(R)" : "" ));
} # ep_summary

#
# sh_summary
#
# Print a one-line summary of the specified show  ( in a subroutine to make changes easier )
#
sub sh_summary
{
    my $show = shift;
    if ($show-> {day})
    {
          return join(" ",$show->{day},
                          $show->{mmdd},
                          "$show->{hhmm}/$show->{len}",
                          get_text($CHAN{ $show->{channel}}->{'display-name'}),
                          $show->{title},
                     );
    }
    else
    {
          return "$show->{title} (title-scan only)";
    }
} #sh_summary

#
# find_episode
#
# given a pointer to a show ( with channel/date/time info) see what's playing then.
# Scan through start times on a specified day and report the last episode not greater than our start time.
#
# There are midnight issues there ( a 2 hour 11pm show will not be found for a requested midnight start ), but
# I'm not sure it's worth the performance penalty of scanning through multiple days.
#
# Returns undef if no episodes are found (or all are greater, see above)  This is signifies no guide info
#
sub find_episode
{
    my $show = shift || die "find_episode(show), show to match please";
    my $chan = $show->{channel};
    my $mmdd = $show->{mmdd};
    my $hhmm = $show->{hhmm};

    my $a;
#print "scanning GUIDE{$chan}{$mmdd}\n";
    foreach $key ( sort keys %{$GUIDE{$chan}{$mmdd}} )
    {
#print "Checking $key,$hhmm\n";
        last if $key gt $hhmm;
        $a=$key;
    }

    return undef unless defined $a;
    return $GUIDE{$chan}{$mmdd}{$a};
} # find_episode

#
# get_text
#
# Given a pointer to an array of [text,lang] pairs, return the best value for our langauge
# Note, if more than one value exists for a language, only the first is returned.
#
# @lang should point to a list of languages in order of preferences
#
sub get_text
{
   my $txt_ptr=shift || return "";
   my %values;

   foreach (@$txt_ptr)
   {
      my $key = $_->[1] || "unknown";
      next if exists $values{$key}; # only keep first value for a language
      $values{$key} = $_->[0];
   }
   return $values{ which_lang( \@LANG, [ keys %values ] ) };

} #get_text

####################################################################
sub load_show_table
{

%SHOW_DATA=();
%SHOW_WIDTH=();
#
# Table headings
#
foreach $col (0..$#COL)
{
    $SHOW_DATA{"0,$col"}=(abs($SHOW_SORT) == $col ? uc("_$COL[$col]_") : lc($COL[$col]));
    $SHOW_WIDTH{$col}   = length($COL[$col]);
}

#
# build sort key of table data
#
my %sort_keys=();
foreach $show (@SHOWS)
{
    next unless defined $show -> {title}; # skip deleted records
    my $key = $show->{$COL[abs($SHOW_SORT)]} || 0;

#
# special sort... by day
#
    if ( $SHOW_SORT == 0 )
    {
        $key=index($WEEKDAY,$key)/3;
        $key=9 if $key < 0;
        $key=int($key);
    }
#
# special sort.. channel 
#
    elsif ( abs($SHOW_SORT) == 1 )
    {
        $key=sprintf("%03d",$1) if $key =~ /^(\d+)/;
    }

#
# save value
#
        push    @{$sort_keys{lc($key)}},$show;
} # build sort keys
#
# display table data sorted by key
#
my $row=0;
my @keys=sort keys %sort_keys;
   @keys = reverse @keys if $SHOW_SORT<0;
foreach $key (@keys)
{
   foreach $show (@{$sort_keys{$key}})
   {
      $row++;
      $SHOW_DATA[$row]=$show;
      foreach $col (0..$#COL)
      {
        next unless $show->{$COL[$col]};
        $SHOW_DATA{"$row,$col"}= $show->{$COL[$col]};
        $SHOW_WIDTH{$col}      = length($show->{$COL[$col]}) if ($SHOW_WIDTH{$col}<length($show->{$COL[$col]}));
      }
   }
}
$SHOW_ROW=0;

$SHOW_WIDTH{$_} += 3 foreach keys %SHOW_WIDTH;
if ($SHOW_TABLE)
{
    $SHOW_TABLE -> configure (-rows => ($#SHOWS > 8  ? $#SHOWS+2 : 10 ));
    $SHOW_TABLE -> clearCache if $SHOW_TABLE;
    $SHOW_TABLE -> selectionClear('all');
    $TOP->title("tvcheck config -".( $SHOW_XML || '(untitled)' ));

    $SHOW_ROW=0;
    $UPDATE_BUTTON -> configure ( -state => "disabled" );
    $DELETE_BUTTON -> configure ( -state => "disabled" );
}
} # load_show_table

#
# load selection values
#
sub load_selection_items
{

#
# load Day list
#
    $SELECT[0]{list} -> delete(0,"end");
    $SELECT[0]{list} -> insert(0,"",@WEEKDAY);

#
# load Channel list
#
    $SELECT[1]{list} -> delete(0,"end");
    $SELECT[1]{list} -> insert(0,"",@CHAN);

    my $day   = $COL_VALUE[0];
    my $chan  = $COL_VALUE[1];
    my $title = $COL_VALUE[4];

    my $match = undef;

    $day   = "" unless defined $day;
    $chan  = "" unless defined $chan;
    $title = "" unless defined $title;

    $day   =~ s/^\s+|\s+$//g;
    $chan  =~ s/^\s+|\s+$//g;
    $title =~ s/^\s+|\s+$//g;

#
# load Title list ( also fill hhmm and day if known )
#
    $SELECT[4]{list} -> delete(0,"end");
    if (length($day) && length($chan))
    {
        $SELECT[4]{list} -> insert(0,"",sort keys %{$GUIDE{$day}{$chan}});
        $match = $GUIDE{$day}{$chan}{$title};
    }
    elsif (length($day))
    {
        $SELECT[4]{list} -> insert(0,"",sort keys %{$GUIDE{day}{$day}} );
        $match=$GUIDE{day}{$day}{$title};
    }
    elsif (length($chan))
    {
        $SELECT[4]{list} -> insert(0,"",sort keys %{$GUIDE{chan}{$chan}} );
        $match=$GUIDE{chan}{$chan}{$title};
    }
    else
    {
        $SELECT[4]{list} -> insert(0,"",sort keys %{$GUIDE{all}} );
        $match=$GUIDE{all}{$title};
    }

#
# if we have a match, fill all fields
#
    if ($match)
        {
	     $COL_VALUE[0] = $match->[0]->[0];
	     $COL_VALUE[1] = $match->[0]->[1];
	     $COL_VALUE[2] = $match->[0]->[2];
	     $COL_VALUE[3] = $match->[0]->[3];
        }

} #load_selection_items

#
# help popup
#
sub help_popup
{
    my $help = MainWindow->new;
    $help->title("tvcheck help");
    $help->Label(-wraplength => '4i' ,
                -justify    => 'left',
                -text       => "
This is a program to create/maintain a show XML file for use with tvcheck.

I hope it's fairly intuitive.  One thing that can get you is the aggressive nature
of the autofill of the selection fields. The good news is the routine only kicks
off when you click a listbox.  Don't click in a listbox and you can edit the raw
data all like.

Don't forget to check out README.tvcheck

Good Luck!
Robert Eden
rmeden\@cpan.org
")->pack();
} # help_popup

sub help_about
{
    my $help = MainWindow->new;
    $help->title("tvcheck about");
    $help->Label(-wraplength => '4i' ,
                -justify    => 'left',
                -text       => '

tvcheck $Revision$
(C) 2002 Robert Eden
rmeden@cpan.org

This program can be used/distributed on the same terms as the XMLTV distribution.

http://xmltv.sourceforge.net
')->pack;
} # help_about

#
# Error popup
#
sub error_popup
{
    my $msg = shift;

    print STDERR "\nerror: $msg\n";

    $TOP->messageBox( -icon => 'error',
                      -type => 'ok',
                     -title => 'Tvcheck error',
                   -message => $msg) if $TOP;
} #error popup

#
# load show array
#
sub load_shows
{
    my $file = shift;
    unless (-e $file)
    {
        error_popup("show file not found ($file)");
        return;
    }
    
    $SHOW_XML = $file;
    print STDERR "Loading xml show info ($SHOW_XML)\n";

    my $xml = XMLin($SHOW_XML, searchpath => ".", forcearray => 1 );
    if ( exists $xml->{shows} )
    {
        @SHOWS=@{$xml->{shows}};
    }
    else
    {
        error_popup("File ($file) is not a show file");
    }

    @LANG= @{$xml->{lang}}  if exists $xml->{lang};
    printf STDERR "Loaded  xml show file ($SHOW_XML) (%d/%d)\n",$#SHOWS+1,$#LANG+1;

#
# fix numeric weekday in old shows file
#
    foreach $show (@SHOWS)
    {
        next unless $show->{day};
        $show->{day}=$WEEKDAY[$1] if $show->{day} =~ /^(\d+)/;
    }
    
    unless (@SHOWS)
    {
        error_popup("$SHOW_XML does not appear to be a show xml file");
    }

    load_show_table();

    if ($SHOW_TABLE)
    {
        $SHOW_TABLE->pack('forget');
        $SHOW_TABLE->pack(-side => 'top', -expand => 1, -fill => 'both');
    }
    $SHOW_CHANGED=0;
} #load_show

    
#
# load channel guide
#
sub load_guide
{
    my $file = shift;

    unless (-e $file)
    {
        error_popup("Guide file not found ($file)");
        return;
    }

    
    my $st=time();
    my $c=0;
    $GUIDE_XML = $file;
    print STDERR "Loading xml guide info ($file) ";
    $xml = XMLTV::read_data($file);
    %CHAN   = %{$xml->[2] };
    @GUIDE  = @{$xml->[3] };
    %GUIDE  = ();
    print STDERR $#GUIDE+1," recs / ",(time()-$st)," secs\n";
    unless (@GUIDE)
    {
       error_popup("Listings file ($file) invalid or empty");
    } 

    #
    # Build channel sort
    #
    my %sorting;
    foreach (keys %CHAN )
    {
        my $key = $_;
           $key=sprintf("%03d",$1) if /^(\d+)/;
        $sorting{$key}=$_;
    }
    @CHAN=();
    map { push @CHAN,$sorting{$_}; } sort keys %sorting;

    #
    # Build indexes for Episode Data
    #
    $st=time();
    $c=0;
    print STDERR "Building Episode Indexes ";
    foreach $ep (@GUIDE)
    {
       print STDERR "." unless $c++ % 1000;
       my $title = get_text($ep->{title});
       my $chan  = $ep->{channel} || "" ;

       $ep->{start}    =~ s/://g;
       $ep->{displayed}="";

       if ($CONFIGURE)
       {
        gen_episode_dates($ep);
        my $array = [$ep->{day},$ep->{channel},$ep->{hhmm},$ep->{len}]; 

        push @{$GUIDE{all}       {$title}             }    ,$array; # all titles
        push @{$GUIDE{chan}      {$chan}      {$title}}    ,$array; # titles by chan
        push @{$GUIDE{day}       {$ep->{day}} {$title}}    ,$array; # titles by day
        push @{$GUIDE{$ep->{day}}{$chan}      {$title}}    ,$array; # titles by chan by day
        }
        else
        {
            push @{$GUIDE{all}{$title}},$ep;    # all titles

            if ( $ep->{start} =~ /^(\d{4})(\d{4})(\d{4})/ )
            {            
               $GUIDE{$chan}{$2}{$3}=$ep; # index by chan, date, time
             }
        }
    } # building guide indexes
    print STDERR " $c recs / ",time()-$st,"secs \n";
  error_popup("guide file $GUIDE_XML does not appear to be valid") unless @GUIDE;

  load_selection_items() if $SELECT[0];  
} #load_guide


#
# Generate XML to save current show array
#
sub Save_shows
{
    unless ($SHOW_XML)
    {
        error_popup("no show file defined, data will be lost, aborting");
        return 1;
    }

#
# recreate show array dropping deleted elements
#
    my @newshow;
    foreach $show (@SHOWS)
    {
        next unless $show -> {title};
        foreach $item ( keys %$show )
        {
            delete $show -> {$item} unless $show->{$item};
        }
        push @newshow,$show;
    }

#
# dump xml
#
        print STDERR "saving shows to $SHOW_XML\n";
        my $string = XMLout( { shows => \@newshow,
                               lang  => \@LANG,
                             },
                         rootname      => 'tvcheck',
                         outputfile    => $SHOW_XML,
                       );
        warn "Error outputing XML\n" unless $string;
        $SHOW_CHANGED=0;
} # Save_shows
    
#
# give chance to save file before losing changes
#
sub changed_check
{
    my $nocan = shift || 0;
    if ($SHOW_CHANGED)
    {
        my $button = $TOP->messageBox( -icon => 'warning',
                                       -type => ( $nocan ? 'YesNo' : 'YesNoCancel'),
                                       -title => 'File Change Warning',
                                       -message => "Show data changed. Do you want to save?");
        if    ($button eq 'yes')     { Save_shows(); }
        elsif ($button eq 'cancel' ) { return 1;    }
        elsif ($button ne 'no' )     { die "Button returned unexpected value <$button>\n"};
    }
    return 0;
} # changed_check

sub gen_episode_dates
{
   my $ep = shift;
   
   my $date1= ParseDate($ep->{start});
   my $date2;
   $date2 = ParseDate($ep->{stop}) if defined $ep -> {stop};
   $date2 = $date1 unless $date2;
   my ($hhmm, $day, $mmdd ) = UnixDate( $date1,"%H%M","%a","%m%d");
   my $len                  = Delta_Format( DateCalc( $date1, $date2), 0,"%mh");

   $ep->{hhmm} = $hhmm;
   $ep->{day}  = $day;
   $ep->{mmdd} = $mmdd;
   $ep->{len}  = $len;

} # gen_episode_dates

