#!/usr/bin/perl -w
# 
# listings_to_latex
# 
# Convert TV listings to LaTeX source.
# 
# Usage: listings_to_latex [filename]
# 
# XML listings data will be read from filename, or from stdin if no
# filename is given.  LaTeX source will be written to stdout.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2000-08-16
# 

use strict;
use XML::DOM;
use IO::File;
use Date::Manip;
use POSIX 'tmpnam';
use XMLTV;
use UK_TZ;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Lingua::Preferred qw(which_lang);

die "usage: $0 [filename]" if @ARGV >= 2;

my $ch = read_channels();
my $ch_name = find_preferred_names($ch);
t 'preferred names: ' . d $ch_name;

########
# Configuration
#

# Width of programme title
my $WIDTH = '0.7\textwidth';

# Number of programmes in each table (should fit onto a page)
my $CHUNK_SIZE = 30;

########
# End of configuration
# 

# Memoize some subroutines if possible
my $memoize_avail;
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
    $memoize_avail = 0;
}
else {
    foreach (qw/start_date ParseDate UnixDate gettz ParseDate_PreservingTZ/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    $memoize_avail = 1;
}

# Prototype declarations
sub chunk($$);
sub start_date($);
sub get_u8_to_latin1();
sub quote($);                                                            
sub find_preferred_names($);

# Reference to sub converting UTF-8 to Latin-1
my $u8_to_latin1 = get_u8_to_latin1();
$u8_to_latin1 = Memoize::memoize($u8_to_latin1) if $memoize_avail;

# Print the start of the LaTeX document
print <<'END';
\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\begin{document}
\sf
\begin{flushleft}
END

# Parse stdin and make it into chunks of programmes
my $filename = @ARGV ? $ARGV[0] : '-';
my %credits;
if ($filename ne '-') {
    %credits = read_credits($filename);
}
else {
    warn "cannot include credits when reading from stdin\n";
}
my $progs = read_programmes($filename);
my @chunks = @{chunk($CHUNK_SIZE, $progs)};

# Print each chunk as a table
my ($curr_date, $curr_tz);
foreach (@chunks) {
    my @programmes = @$_;
    
    my $chunk_date = start_date($programmes[0]);
    if (not defined $curr_date or $curr_date ne $chunk_date) {
	my $df = UnixDate($chunk_date, "%m-%d (%A)");
	print "\\section*{\\sf $df}\n";
	$curr_date = $chunk_date;
    }

    print "\\begin{tabular}{r\@{--}lp{$WIDTH}r} \n";
    my $top_of_table = 1;
    foreach (@programmes) {
	my %h = %$_;
	my ($start, $stop, $channel) = @h{qw(start stop channel)};

	# Title and sub-title can be multi-valued, so they're a list
	my $title = join(' / ', @{$h{title}});
	my $sub_title = join(' / ', @{$h{sub_title}});
	
	# Convert date-and-time to just hhmm, adding explicit timezone
	# whenever it changes.
	# 
	my $start_tz = gettz($start) || 'UT';
	my $start_p = ParseDate_PreservingTZ($start)
	  or die "bad date '$start'";
	my $start_h = UnixDate($start_p, '%R');

	if ($top_of_table and not defined $curr_tz) {
	    # Assume that the first listing on a page doesn't need an
	    # explicit timezone.  (FIXME not perfect)
	    # 
	    $curr_tz = $start_tz;
	}
	$top_of_table = 0;

	my $stop_h;
	if (defined $stop) {
	    # Stop time is defined, sort out its timezone too
	    my $stop_tz = gettz($stop) || 'UT';
	    my $stop_p = ParseDate_PreservingTZ($stop)
	      or die "bad date '$stop'";
	    $stop_h = UnixDate($stop_p, '%R');
	    
	    if ((not defined $curr_tz)
		or ($curr_tz ne $start_tz)
		or ($start_tz ne $stop_tz) )
	    {
		  # The timezone has changed somehow - make it explicit.
		  $start_h .= " $start_tz";
		  $stop_h .= " $stop_tz";
		  undef $curr_tz;
	    }
	    
	    if ($start_tz eq $stop_tz) {
		# The programme starts and stops in the same TZ - we
		# can assume that this is the one to use from now on.
		# 
		$curr_tz = $start_tz;
	    }
	}
	else {
	    # Missing stop time.  Still need to check the timezone.
	    if ((not defined $curr_tz) or ($curr_tz ne $start_tz)) {
		$start_h .= " $start_tz";
		undef $curr_tz;
	    }
	}

	# Look up pretty name of channel
	if (defined $ch_name->{$channel}) {
	    $channel = $ch_name->{$channel};
	}

	$channel = quote($channel);
	$title .= " // $sub_title" if $sub_title ne '';
	$title = quote($u8_to_latin1->($title));

	# Apparently, you have to put \smallskip _before_ each line
	# (even the first) in order to get consistent spacing.  The
	# blank line after $title is to explicitly end the paragraph,
	# so that \raggedright takes effect.
	# 
	# Er, this needs fixing.  See my post to comp.text.tex.
	# 
	die 'no start'   if not defined $start_h;
	$stop_h = '' if not defined $stop_h;
	die 'no title'   if not defined $title;
	die 'no channel' if not defined $channel;

	print <<END;
\\smallskip
$start_h & $stop_h &
{ \\small \\raggedright
$title
} & $channel \\\\
END
    }

print "\\end{tabular} \\\\ \n";
}
print "\\end{flushleft}\n";

# Acknowledgements
my $g = $credits{'generator-info-name'}; $g =~ s!/(\d)! $1!;
my $s = $credits{'source-info-name'};
if (not defined $g and not defined $s) {
    # No acknowledgement since unknown source.
}
elsif (not defined $g and defined $s) {
    print 'Generated from \textbf{', quote($s), "}.\n";
}
elsif (defined $g and not defined $s) {
    print 'Generated by \textbf{', quote($g),  "}.\n";
}
elsif (defined $g and defined $s) {
    print 'Generated from \textbf{', quote($s), '} by \textbf{', quote($g), "}.\n";
}
else { die }
print "\\end{document}\n";


# chunk()
# 
# Split up a list of programmes into chunks of a certain maximum size,
# also starting a new chunk for each day.
# 
sub chunk($$) {
    die 'usage: chunk(chunk size, ref to list of programmes)'
      if @_ != 2;
    my ($chunksize, $list) = @_;

    my @r;
    my @currchunk = ();
    while (@$list) {
	push @currchunk, scalar (shift @$list);

	if (@currchunk == $chunksize
	    or @$list == 0
	    or start_date($currchunk[-1]) ne start_date($list->[0]) )
        {
	    push @r, [ @currchunk ];
	    @currchunk = ();
	}
    }
    return \@r;
}


# start_date()
# 
# Returns the day on which a programme starts, in the form YYYYMMDD.
# 
sub start_date($) {
    my $prog = shift;
    die "bad programme" if not defined $prog->{title};
    die "no start date for $prog->{title}"
      if not defined $prog->{start};

    my $p = ParseDate_PreservingTZ($prog->{start});
    die "bad start date for programme" if not defined $p or $p eq '';
    return UnixDate($p, '%Q');
}


# get_u8_to_latin1()
# 
# Do some poking around and try to come up with a subroutine that
# converts UTF-8 strings to Latin-1 encoded strings.  What gets used
# will depend on what the user has installed.
# 
sub get_u8_to_latin1() {
    die 'usage: get_u8_to_latin1()' if @_;
    
    # First preference is for Unicode::String.  With perl 5.6 we could
    # probably use the internal Unicode support, but I'm still using
    # an older version.
    # 
    unless ($u8_to_latin1) {
	eval { require Unicode::String };
	if ($@) {
	    warn "could not load Unicode::String, trying alternatives";
	}
	else {
	    $u8_to_latin1 = sub {
		Unicode::String::utf8($_[0])->latin1()
	    };
	}
    }
    
    # The next best thing is to run GNU recode.  Slow but it works.
    unless ($u8_to_latin1) {
	my $RECODE = 'recode UTF-8..ISO-8859-1';
	chomp(my $r = `echo test | $RECODE`);
	if ($r ne 'test') {
	    warn "GNU recode doesn't seem to work, trying alternatives";
	}
	else {
	    $u8_to_latin1 = sub {
		my $tmp = tmpnam();
		my $fh = new IO::File(">$tmp")
		  or die  "cannot open $tmp for writing: $!";
		print $fh $_[0] or die  "cannot write to $tmp: $!";
		close $fh or warn "cannot close $tmp: $!";
		
		chomp(my $r = `$RECODE <$tmp`);
		return $r;
	    };
	}
    }
    
    # Finally we just strip non-ASCII characters.
    unless ($u8_to_latin1) {
	warn "stripping all non-ASCII characters";
	$u8_to_latin1 = sub {
	    local $_ = shift;
	    tr/\000-\177//cd;
	    return $_;
	};
    }
}


# quote()
# 
# Quote at least some characters which do funny things in LaTeX
# 
# Parameters: string to quote
# Returns: quoted version
# 
# Copied from <http://www.doc.ic.ac.uk/~epa98/work/apps/dtd2latex/>;
# should put something like this into a 'LaTeX' module some day.
# 
sub quote($) {
    die 'usage: quote(string)' if @_ != 1;
    local $_ = shift;

    # Quote characters
    s/\\/\\(\\backslash\\)/g;
    foreach my $ch ('_', '#', '%', '{', '}', '&') {
	s/$ch/\\$ch/g;
    }
    s/\$/\\\$/g;
    foreach my $ch ('<', '>') {
	s/$ch/\\($ch\\)/g;
    }
    s/~/\\(\\sim\\)/;
    s/\^/\\(\\hat{}\\)/;

    # Lines of dots
    s/\.{3,}\s*$/\\dotfill/mg;

    return $_;
}

# find_preferred_names()
# 
# Work out the best human-readable name to use for each channel.  This
# isn't quite as simple as calling Lingua::Preferred::which_lang(),
# because we want to include the display names with language undef -
# this means they are channel numbers or identifiers suitable for any
# language.  Also, we want to choose the shortest possible name to
# avoid wasting ink :-).
# 
# Parameter: refhash of channels data from read_channels()
# Returns: ref to hash mapping channel id to printable channel name
# 
sub find_preferred_names($) {
    my $wanted_langs = (defined $ENV{LANG}) ? [ $ENV{LANG} ] : [];
    my $h = shift;
    my %r;
    foreach my $id (keys %$h) {
	my @names = @{$h->{$id}};
	if (not @names) {
	    warn "channels hash has no name for $id";
	    next;
	}
	my @avail_langs;
	my (%seen_lang, $seen_undef);
	foreach (map { $_->[0] } @names) {
	    if (defined) {
		next if $seen_lang{$_}++;
	    }
	    else {
		next if $seen_undef++;
	    }
	    push @avail_langs, $_;
	}
	my $pref_lang = which_lang($wanted_langs, \@avail_langs);
	my ($shortest_so_far, $shortest_so_far_length);
	foreach (@names) {
	    my ($lang, $text) = @$_;
	    next unless (not defined $lang) or ($lang eq $pref_lang);
	    my $length = length $text;
	    if (not defined $shortest_so_far
		or $length < $shortest_so_far_length) {
		$shortest_so_far = $text;
		$shortest_so_far_length = $length;
	    }
	}
	if (not defined $shortest_so_far) {
	    die "couldn't get name for channel $id";
	}

	# There's no need to warn about more than one channel having
	# the same human-readable name: that's deliberate (eg regional
	# variants of the same channel may all have the same number).
	# Maybe it could be checked when the channel id is actually
	# looked up to get the name, that the name hasn't been used
	# for a different channel id.  But we won't even do that for
	# now.
	# 
	$r{$id} = $shortest_so_far;
    }
    return \%r;
}
