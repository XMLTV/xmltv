# -*- perl -*-
package XMLTV;

use strict;
use base 'Exporter'; use vars qw(@EXPORT @EXPORT_OK);
@EXPORT = ();
@EXPORT_OK = qw(read_data parse parsefile write_data
		best_name list_channel_keys list_programme_keys);

# FIXME store version number centrally.
use vars qw($VERSION);
$VERSION = '0.5';

=pod

=head1 NAME

XMLTV - Perl extension to read and write TV listings in XMLTV format

=head1 SYNOPSIS

  use XMLTV;
  my $data = XMLTV::parsefile('tv.xml');
  my ($encoding, $credits, $ch, $progs) = @$data;
  my $langs = [ 'en', 'fr' ];
  print 'source of listings is: ', $credits->{'source-info-name'}, "\n"
      if defined $credits->{'source-info-name'};
  foreach (values %$ch) {
      my ($text, $lang) = @{XMLTV::best_name($langs, $_->{'display-name'})};
      print "channel $_->{id} has name $text\n";
      print "...in language $lang\n" if defined $lang;
  }
  foreach (@$progs) {
      print "programme on channel $_->{channel} at time $_->{start}\n";
      next if not defined $_->{desc};
      foreach (@{$_->{desc}}) {
          my ($text, $lang) = @$_;
          print "has description $text\n";
          print "...in language $lang\n" if defined $lang;
      }
  }

The value of $data will be something a bit like:

  [ 'UTF-8',
    { 'source-info-name' => 'Ananova', 'generator-info-name' => 'XMLTV' },
    { 'radio-4.bbc.co.uk' => { 'display-name' => [ [ 'en',  'BBC Radio 4' ],
						   [ 'en',  'Radio 4'     ],
						   [ undef, '4'           ] ],
			       'id' => 'radio-4.bbc.co.uk' },
      ... },
    [ { start => '200111121800', title => [ [ 'Simpsons', 'en' ] ],
        channel => 'radio-4.bbc.co.uk' },
      ... ] ]

=head1 DESCRIPTION

This module provides an interface to read and write files in XMLTV
format (a TV listings format defined by xmltv.dtd).  In general element
names in the XML correspond to hash keys in the Perl data structure.
You can think of this module as a bit like B<XML::Simple>, but
specialized to the XMLTV file format.

The Perl data structure corresponding to an XMLTV file has four
elements.  The first gives the character encoding used for text data,
typically UTF-8 or ISO-8859-1.  The second gives the attributes of the
root <tv> element, which give information about the source of the TV
listings.  The third element is a list of channels, each list element
being a hash corresponding to one <channel> element.  The fourth element
is similarly a list of programmes.  More details about the data
structure are given later.  The easiest way to find out what it looks
like is to load some small XMLTV files and use B<Data::Dumper> to
print out the resulting structure.

=head1 USAGE

=over

=cut

use XML::DOM;
use XML::Writer;
use Date::Manip;
use Carp;
use Data::Dumper;

# Use Lingua::Preferred if available, else kludge a replacement.
sub my_which_lang { return $_[1]->[0] }
BEGIN {
    eval { require Lingua::Preferred };
    *which_lang = $@ ? \&my_which_lang : \&Lingua::Preferred::which_lang;
}

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
    }
}

# Handlers and multiplicity for different subelements of channel.
#
# The ordering of this list gives the order in which these elements
# must appear in the DTD.  In fact, this just duplicates information
# in the DTD and adds details of what handlers to call.
#
use vars '@Channel_Handlers'; @Channel_Handlers =
  (
   [ 'display-name', 'with-lang', '+' ],
   [ 'icon',         'icon',      '*' ],
   [ 'url',          'scalar',    '*' ],
  );

# Same for <programme> elements.
use vars '@Programme_Handlers'; @Programme_Handlers =
  (
   [ 'title',            'with-lang',          '+' ],
   [ 'sub-title',        'with-lang',          '*' ],
   [ 'desc',             'with-lang',          '*' ],
   [ 'credits',          'credits',            '?' ],
   [ 'date',             'scalar',             '?' ],
   [ 'category',         'with-lang',          '*' ],
   [ 'language',         'with-lang',          '?' ],
   [ 'orig-language',    'with-lang',          '?' ],
   [ 'length',           'length',             '?' ],
   [ 'icon',             'icon',               '*' ],
   [ 'url',              'scalar',             '*' ],
   [ 'country',          'with-lang',          '*' ],
   [ 'episode-num',      'episode-num',        '?' ],
   [ 'video',            'video',              '?' ],
   [ 'audio',            'audio',              '?' ],
   [ 'previously-shown', 'previously-shown',   '?' ],
   [ 'premiere',         'with-lang-or-empty', '?' ],
   [ 'last-chance',      'with-lang-or-empty', '?' ],
   [ 'new',              'presence',           '?' ],
   [ 'subtitles',        'subtitles',          '*' ],
   [ 'rating',           'rating',             '*' ],
   [ 'star-rating',      'star-rating',        '?' ],
  );

# And a hash mapping names like 'with-lang' to pairs of subs.
use vars '%Handlers'; %Handlers = ();

# Undocumented interface for adding extensions to the XMLTV format:
# first add an entry to @XMLTV::Channel_Handlers or
# @XMLTV::Programme_Handlers with your new element's name, 'type' and
# multiplicity.  The 'type' should be a string you invent yourself.
# Then $XMLTV::Handlers{'type'} should be a pair of subroutines, a
# reader and a writer.  (Unless you want to use one of the existing
# types such as 'with-lang' or 'scalar'.)
#
# Note that elements and attributes beginning 'x-' are skipped over
# _automatically_, so you can't parse them with this method.  A better
# way to add extensions is needed - doing this not encouraged but is
# sometimes necessary.
#

# read_data() is a deprecated name for parsefile().
sub read_data( $ ) { # FIXME remove altogether
    warn "XMLTV::read_data() deprecated, use XMLTV::parsefile() instead\n";
    &parsefile;
}

=pod

=item parse(document)

Takes an XMLTV document (a string) and returns the Perl data
structure.  It is assumed that the document is valid XMLTV; if not
the routine may die() with an error (although the current implementation
just warns and continues for most small errors).

The first element of the listref returned will always be 'UTF-8',
since XML parsing in Perl always returns results in UTF-8 encoding.

Attributes and elements in the XML file whose names begin with 'x-'
are skipped silently.  You can use these to include information which
is not currently handled by the XMLTV format, or by this module.

=cut
sub parse( $ ) {
    my $str = shift;
    my $p = new XML::DOM::Parser;

    # Expat doesn't handle really basic failures that easily; so we
    # sanity-check first.  We don't do this with parsefile() because
    # that would mean opening the file twice.
    #
    if ($str !~ /<tv/) {
	croak "no <tv> element found";
    }

    my $doc = $p->parse($str);
    die "string passed in is not XML" if not defined $doc;
    return parse_doc($doc);
}

=pod

=item parsefile(filename)

Like C<parse()> but takes a filename or URL instead of a whole
document.  Supports the same URLs as B<XML::DOM::Parser>.

=cut
sub parsefile( $ ) {
    my $filename = shift;
    my $p = new XML::DOM::Parser;
    my $doc = $p->parsefile($filename);
    die "$filename is not XML" if not defined $doc;
    return parse_doc($doc);
}

# Private.  Convert a DOM tree to XMLTV data structures.
sub parse_doc( $ ) {
    my $doc = shift;
    # We assume that the XMLTV document is valid, but some errors are
    # caught anyway.  Running the file through this is a good
    # thing to do *in addition to* validating with nsgmls.
    #

    # Encoding.
    my $encoding = 'UTF-8';

    # Get the source info - attributes of <tv>.
    my $nodes = $doc->getElementsByTagName('tv');
    die "document should have exactly one 'tv' element"
      if $nodes->getLength() != 1;
    my $tv = $nodes->item(0);
    my $credits = get_attrs($tv);

    # Channels.
    $nodes = $doc->getElementsByTagName('channel');
    my $n = $nodes->getLength();
    my %channels;
    for (my $i = 0; $i < $n; $i++) {
	my $node = $nodes->item($i);
	my $channel = node_to_channel($node);
	my $id = $channel->{id};
	warn "channel with id $id seen twice"
	  if defined $channels{$id};
	$channels{$id} = $channel;
    }

    # Finally the programmes themselves.
    my @programmes;
    $nodes = $doc->getElementsByTagName('programme');
    $n = $nodes->getLength();
    for (my $i = 0; $i < $n; $i++) {
	my $node = $nodes->item($i);
	push @programmes, node_to_programme($node);
    }

    return [ $encoding, $credits, \%channels, \@programmes ];
}

=pod

=item write_data(data, options...)

Takes a data structure and writes it as XML to standard output.  Any
extra arguments are passed on to XML::WriterE<39>s constructor, for example

    my $f = new IO::File '>out.xml'; die if not $f;
    write_data($data, OUTPUT => $f);

The encoding used for the output is given by the first element of the
data.

Normally, there will be a warning for any Perl data which is not
understood and cannot be written as XMLTV, such as strange keys in
hashes.  But as an exception, any hash key beginning with an
underscore will be skipped over silently.  You can store 'internal use
only' data this way.

If a programme hash contains a key beginning with 'debug', this key
and its value will be written out as a comment inside the <programme>
element.  This lets you include small debugging messages in the XML
output.

=cut
sub write_data( $;@ ) {
    my $data = shift;
    my $writer = new XMLTV::Writer(encoding => $data->[0], @_);
    $writer->start($data->[1]);
    $writer->write_channels($data->[2]);
    $writer->write_programme($_) foreach @{$data->[3]};
    $writer->end();
}


# Private.
#
# get_attrs()
#
# Given a node, return a hashref of its attributes.  Skips over
# the 'x-whatever' attributes.
#
sub get_attrs( $ ) {
    my $node = shift;
    my $attrs = $node->getAttributes();
    my $num_attrs = $attrs->getLength();
    my %r;
    for (my $i = 0; $i < $num_attrs; $i++) {
	my $node = $attrs->item($i);
	die if not defined $node;
	my $name = get_name($node);
	warn "seen attribute $name twice" if exists $r{$name};
	$r{$name} = $node->getValue() unless $name =~ /^x-/;
    }
    return \%r;
}


# Private.
#
# get_text()
#
# Given a node containing only text, return that text (with
# whitespace either side stripped).
#
sub get_text( $ ) {
    my $node = shift;
    my $child = $node->getFirstChild();
    if (not defined $child) {
	# Decided that it's okay to call get_text() on an empty
	# element; it should return the empty string.
	#
	return '';
    }
    if ($child->getNodeTypeName() ne 'TEXT_NODE') {
	warn 'first child of text node has wrong type';
	return undef;
    }
    my $text = $child->getData();
    die if ref $text;
    $text =~ s/^\s+//; $text =~ s/\s+$//;
    return $text;
}


# Private.
#
# get_subelements()
#
# Return a list of all subelements of a node.  Whitespace is
# ignored; anything else that isn't a subelement is warned about.
# Skips over elements with name 'x-whatever'.
#
sub get_subelements( $ ) {
    local $Log::TraceMessages::On = 0;
    my $node = shift;
    my @r;
    foreach ($node->getChildNodes()) {
	my $type = $_->getNodeTypeName();
	t "\$type=$type";
	if ($type eq 'ELEMENT_NODE') {
	    t 'element node';
	    my $name = get_name($_);
	    push @r, $_ unless $name =~ /^x-/;
	}
	elsif ($type eq 'TEXT_NODE') {
	    # We allow whitespace between elements.
	    t 'text node, check is whitespace and skip';
	    my $content = $_->getData();
	    if ($content !~ /^\s*$/) {
		warn "ignoring text '$content' where element expected";
	    }
	    next;
	}
	elsif ($type eq 'COMMENT_NODE') {
	    # Ignore.
	    next;
	}
	else {
	    t 'unknown node type, warn and skip';
 	    warn "ignoring node of type $type where element expected";
	    next;
	}
    }
    return @r;
}

# Private.
#
# get_name()
#
# Return the element name of a node.
#
sub get_name( $ ) { $_[0]->getNodeName() }
	
# Private.
#
# dump_node()
#
# Return some information about a node for debugging.
#
sub dump_node( $ ) {
    my $n = shift;
    my $r = '';
    $r .= 'type: ' . $n->getNodeTypeName() . "\n";
    $r .= 'name: ' . get_name($n) . "\n";
    for (trunc($n->getNodeValue())) {
	$r .= "value: $_\n" if defined;
    }
    return $r;
}
# Private.  Truncate a string to a reasonable length and add '...' if
# necessary.
#
sub trunc {
    local $_ = shift;
    return undef if not defined;
    if (length > 1000) {
	return substr($_, 0, 1000) . '...';
    }
    return $_;
}

=pod

=item best_name(languages, pairs [, comparator])

The XMLTV format contains many places where human-readable text is
given an optional 'lang' attribute, to allow mixed languages.  This is
represented in Perl as a pair [ text, lang ], although the second
element may be missing or undef if the language is unknown.  When
several alernatives for an element (such as <title>) can be given, the
representation is a list of [ text, lang ] pairs.  Given such a list,
what is the best text to use?  It depends on the userE<39>s preferred
language.

This function takes a list of acceptable languages and a list of [string,
language] pairs, and finds the best one to use.  This means first finding
the appropriate language and then picking the 'best' string in that
language.

The best is normally defined as the first one found in a usable
language, since the XMLTV format puts the most canonical versions
first.  But you can pass in your own comparison function, for example
if you want to choose the shortest piece of text that is in an
acceptable language.

The acceptable languages should be a reference to a list of language
codes looking like 'ru', or like 'de_DE'.  The text pairs should be a
reference to a list of pairs [ string, language ].  (As a special case
if this list is empty or undef, that means no text is present, and the
result is undef.)  The third argument if present should be a cmp-style
function that compares two strings of text and returns 1 if the first
argument is better, -1 if the second better, 0 if theyE<39>re equally
good.

Returns: [s, l] pair, where s is the best of the strings to use and l
is its language.  This pair is 'live' - it is one of those from the
list passed in.  So you can use C<best_name()> to find the best pair
from a list and then modify the content of that pair.

(This routine depends on the C<Lingua::Preferred> module being
installed; if that module is missing then the first available
language is always chosen.)

Example:

    my $langs = [ 'de', 'fr' ]; # German or French, please

    # Say we found the following under $p->{title} for a programme $p.
    my $pairs = [ [ 'La Cité des enfants perdus', 'fr' ],
                  [ 'The City of Lost Children', 'en_US' ] ];

    my $best = best_name($langs, $pairs);
    print "chose title $best->[0]\n";

=cut
sub best_name( $$;$ ) {
#    local $Log::TraceMessages::On = 1;
    my ($wanted_langs, $pairs, $compare) = @_;
    t 'best_name() ENTRY';
    t 'wanted langs: ' . d $wanted_langs;
    t '[text,lang] pairs: ' . d $pairs;
    t 'comparison fn: ' . d $compare;
    return undef if not defined $pairs;
    my @pairs = @$pairs;

    my @avail_langs;
    my (%seen_lang, $seen_undef);
    # Collect the list of available languages.
    foreach (map { $_->[1] } @pairs) {
	if (defined) {
	    next if $seen_lang{$_}++;
	}
	else {
	    next if $seen_undef++;
	}
	push @avail_langs, $_;
    }

    my $pref_lang = which_lang($wanted_langs, \@avail_langs);

    # Gather up [text, lang] pairs which have the desired language.
    my @candidates;
    foreach (@pairs) {
	my ($text, $lang) = @$_;
	next unless ((not defined $lang)
		     or (defined $pref_lang and $lang eq $pref_lang));
	push @candidates, $_;
    }

    return undef if not @candidates;

    # If a comparison function was passed in, use it to compare the
    # text strings from the candidate pairs.
    #
    @candidates = sort { $compare->($a->[0], $b->[0]) } @candidates
      if defined $compare;

    # Pick the first candidate.  This will be the one ordered first by
    # the comparison function if given, otherwise the earliest in the
    # original list.
    #
    return $candidates[0];
}


=item list_channel_keys(), list_programme_keys()

Some users of this module may wish to enquire at runtime about which
keys a programme or channel can contain.  This subroutine returns a
hash mapping key to handler name and multiplicity.  This lets you know
what data types can be expected under each key.  See L<"DATA
STRUCTURE"> for details on what a handler is.

It is not possible to find out which keys are mandatory and which
optional, only a list of all those which might possibly be present.
An example use of these routines is the L<tv_grep(1)> program, which
creates its allowed command line arguments from the names of programme
subelements.

=cut
# Private.
sub list_keys( $ ) {
    my %r;
    foreach (@{shift()}) {
	my ($k, $h_name, $mult) = @$_;
	$r{$k} = [ $h_name, $mult ];
    }
    return \%r;
}
# Public.
sub list_channel_keys() { list_keys(\@Channel_Handlers) }
sub list_programme_keys() { list_keys(\@Programme_Handlers) }

=pod

=item cat(data, ...)

Concatenate (and merge) listings data.  Programmes are catenated
together, channels are merged, for credits we just take the first
and warn if the others differ.

See L<tv_cat(1)> which is just a wrapper around this routine.

=cut
sub cat( @ ) {
#    local $Log::TraceMessages::On = 1;
    my $all_credits;
    my %all_channels;
    my @all_progs;

    foreach (@_) {
	t 'doing arg: ' . d $_;
	die 'usage: cat([ encoding, credits, channels, progs ]...)'
	  if ref ne 'ARRAY';
	my ($encoding, $credits, $channels, $progs) = @$_;
	die if $encoding ne 'UTF-8';

	if (not defined $all_credits) {
	    $all_credits = $credits;
	}
	elsif (Dumper($credits) ne Dumper($all_credits)) {
	    warn "different files have different credits, taking from first file\n";
	}

	foreach (keys %$channels) {
	    if (not defined $all_channels{$_}) {
		$all_channels{$_} = $channels->{$_};
	    }
	    elsif (Dumper($all_channels{$_}) ne Dumper($channels->{$_})) {
		warn "channel $_ differs between two files, taking first appearance\n";
	    }
	}

	push @all_progs, @$progs;
    }
    $all_credits = {} if not defined $all_credits;

    return [ 'UTF-8', $all_credits, \%all_channels, \@all_progs ];
}



# For each subelement of programme, we define a subroutine to read it
# and one to write it.  The reader takes an node for a single
# subelement and returns its value as a Perl scalar (warning and
# returning undef if error).  The writer takes an XML::Writer, an
# element name and a scalar value and writes a subelement for that
# value.  Note that the element name is passed in to the writer just
# for symmetry, so that neither the writer or the reader have to know
# what their element is called.
#
=pod

=back

=head1 DATA STRUCTURE

For completeness, we describe more precisely how channels and
programmes are represented in Perl.  Each element of the channels list
is a hashref corresponding to one <channel> element, and likewise for
programmes.  The possible keys of a channel (programme) hash are the
names of attributes or subelements of <channel> (<programme>).  The
values for attributes are not processed in any way.  But for
subelements, there is further processing needed to turn the XML
content of a subelement into Perl data.  What is done depends on what
type of data is stored under that subelement.  Also, if a certain
element can appear several times then the hash key for that element
points to a list of values rather than just one.

The conversion of a subelementE<39>s content to and from Perl data is
done by a handler.  The most common handler is I<with-lang>, used for
human-readable text content plus an optional 'lang' attribute.  There
are other handlers for other data structures in the file format.
Often two subelements will share the same handler, since they hold the
same type of data.  The handlers defined are as follows; note that
most of them will silently strip leading and trailing whitespace in
element content.  Look at the DTD itself for an explanation of the
whole file format.

=over

=item I<credits>

Turns a list of credits (for director, actor, writer, etc.) into a
hash mapping 'role' to a list of names.  The names in each role are
kept in the same order.

=cut
$Handlers{credits}->[0] = sub( $ ) {
    my $node = shift;
    my @roles = qw(director actor writer adapter producer presenter
		   commentator guest);
    my %known_role; ++$known_role{$_} foreach @roles;
    my %r;
    foreach (get_subelements($node)) {
	my $role = get_name($_);
	unless ($known_role{$role}++) {
	    warn "unknown thing in credits: $role";
	    next;
	}
	push @{$r{$role}}, get_text($_);
    }
    return \%r;
};
$Handlers{credits}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_; die if not defined $v;
    my %h = %$v;
    return if not %h; # don't write empty element
    t 'writing credits: ' . d \%h;
    $w->startTag($e);
    foreach (qw[director actor writer adapter producer presenter
		commentator guest] ) {
	next unless defined $h{$_};
	my @people = @{delete $h{$_}};
	foreach my $person (@people) {
	    die if not defined $person;
	    $w->dataElement($_, $person);
	}
    }
    $w->endTag($e);
    foreach (keys %h) {
	warn "unknown credit: $_" unless /^_/;
    }
};

=pod

=item I<scalar>

Reads and writes a simple string as the content of the XML element.

=cut
$Handlers{scalar}->[0] = sub( $ ) {
    my $node = shift;
    return get_text($node);
};
$Handlers{scalar}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    t 'scalar';
    $w->dataElement($e, $v);
};

=pod

=item I<length>

Converts the content of a <length> element into a number of seconds
(so <length units="minutes">5</minutes> would be returned as 300).  On
writing out again tries to convert a number of seconds to a time in
minutes or hours if that would look better.

=cut
$Handlers{length}->[0] = sub( $ ) {
    my $node = shift;
    my %attrs = %{get_attrs($node)};
    my $d = get_text($node);
    if ($d =~ /^\s*$/) {
	warn "empty 'length' element";
	return undef;
    }
    if ($d !~ tr/0-9// or $d =~ tr/0-9//c) {
	warn "bad content of 'length' element: $d";
	return undef;
    }
    my $units = $attrs{units};
    if (not defined $units) {
	warn "missing 'units' attr in 'length' element";
	return undef;
    }
    # We want to return a length in seconds.
    if ($units eq 'seconds') {
	# Okay.
    }
    elsif ($units eq 'minutes') {
	$d *= 60;
    }
    elsif ($units eq 'hours') {
	$d *= 60 * 60;
    }
    else {
	warn "bad value of 'units': $units";
	return undef;
    }
    return $d;
};
$Handlers{length}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    t 'length';
    my $units;
    if ($v % 3600 == 0) {
	$units = 'hours';
	$v /= 3600;
    }
    elsif ($v % 60 == 0) {
	$units = 'minutes';
	$v /= 60;
    }
    else {
	$units = 'seconds';
    }
    $w->dataElement($e, $v, units => $units);
};

=pod

=item I<episode-num>

The representation in Perl of XMLTVE<39>s odd episode numbers is as a
pair of [ content, system ].  As specified by the DTD, if the system is
not given in the file then 'onscreen' is assumed.  Whitespace in the
'xmltv_ns' system is unimportant, so on reading it is normalized to
a single space on either side of each dot.

=cut
$Handlers{'episode-num'}->[0] = sub( $ ) {
    my $node = shift;
    my %attrs = %{get_attrs($node)};
    my $system = $attrs{system};
    $system = 'onscreen' if not defined $system;
    my $content = get_text($node);
    if ($system eq 'xmltv_ns') {
	# Make it look nice.
	$content =~ s/\s+//g;
	$content =~ s/\./ . /g;
    }
    return [ $content, $system ];
};
$Handlers{'episode-num'}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    t 'episode number';
    my ($content, $system) = @$v;
    $w->dataElement($e, $content, system => $system);
};

=pod

=item I<video>

The <video> section is converted to a hash.  The <present> subelement
corresponds to the key 'present' of this hash, 'yes' and 'no' are
converted to Booleans.  The same applies to <colour>.  The content of
the <aspect> subelement is stored under the key 'aspect'.  These keys
can be missing in the hash just as the subelements can be missing in
the XML.

=cut
$Handlers{video}->[0] = sub ( $ ) {
    my $node = shift;
    my %r;
    foreach (get_subelements($node)) {
	my $name = get_name($_);
	my $value = get_text($_);
	if ($name eq 'present') {
	    warn "'present' seen twice" if defined $r{present};
	    $r{present} = decode_boolean($value);
	}
	elsif ($name eq 'colour') {
	    warn "'colour' seen twice" if defined $r{colour};
	    $r{colour} = decode_boolean($value);
	}
	elsif ($name eq 'aspect') {
	    warn "'aspect' seen twice" if defined $r{aspect};
	    $value =~ /^\d+:\d+$/ or warn "bad aspect ratio: $value";
	    $r{aspect} = $value;
	}
    }
    return \%r;
};
$Handlers{video}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    t "'video' element";
    my %h = %$v;
    return if not %h; # don't write empty element
    $w->startTag($e);
    if (defined (my $val = delete $h{present})) {
	$w->dataElement('present', encode_boolean($val));
    }
    if (defined (my $val = delete $h{colour})) {
	$w->dataElement('colour', encode_boolean($val));
    }
    if (defined (my $val = delete $h{aspect})) {
	$w->dataElement('aspect', $val);
    }
    foreach (sort keys %h) {
	warn "unknown key in video hash: $_" unless /^_/;
    }
    $w->endTag($e);
};

=pod

=item I<audio>

This is similar to I<video>.  <present> is a Boolean value, while
the content of <stereo> is stored unchanged.

=cut
$Handlers{audio}->[0] = sub( $ ) {
    my $node = shift;
    my %r;
    foreach (get_subelements($node)) {
	my $name = get_name($_);
	my $value = get_text($_);
	if ($name eq 'present') {
	    warn "'present' seen twice" if defined $r{present};
	    $r{present} = decode_boolean($value);
	}
	elsif ($name eq 'stereo') {
	    warn "'stereo' seen twice" if defined $r{stereo};
	    if ($value eq '') {
		warn "empty 'stereo' element not permitted, should be <stereo>stereo</stereo>";
		$value = 'stereo';
	    }
	    warn "bad value for 'stereo': '$value'"
	      if ($value ne 'mono' and $value ne 'stereo'
		  and $value ne 'surround');
	    $r{stereo} = $value;
	}
    }
    return \%r;
};
$Handlers{audio}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    my %h = %$v;
    return if not %h; # don't write empty element
    $w->startTag($e);
    if (defined (my $val = delete $h{present})) {
	$w->dataElement('present', encode_boolean($val));
    }
    if (defined (my $val = delete $h{stereo})) {
	$w->dataElement('stereo', $val);
    }
    foreach (sort keys %h) {
	warn "unknown key in video hash: $_" unless /^_/;
    }
    $w->endTag($e);
};

=pod

=item I<previously-shown>

The 'start' and 'channel' attributes are converted to keys in a hash.

=cut
$Handlers{'previously-shown'}->[0] = sub( $ ) {
    my $node = shift;
    my %attrs = %{get_attrs($node)};
    my $r = {};
    foreach (qw(start channel)) {
	my $v = delete $attrs{$_};
	$r->{$_} = $v if defined $v;
    }
    foreach (keys %attrs) {
	warn "unknown attribute $_ in previously-shown";
    }
    return $r;
};
$Handlers{'previously-shown'}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    $w->emptyTag($e, %$v);
};

=pod

=item I<presence>

The content of the element is ignored: it signfies something by its
very presence.  So the conversion from XML to Perl is a constant true
value whenever the element is found; the conversion from Perl to XML
is to write out the element if true, donE<39>t write anything if false.

=cut
$Handlers{presence}->[0] = sub( $ ) {
    my $node = shift;
    # The 'new' element is empty, it signifies newness by its very
    # presence.
    #
    return 1;
};
$Handlers{presence}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    if (not $v) {
	# Not new, so don't create an element.
    }
    else {
	$w->emptyTag($e);
    }
};

=pod

=item I<subtitles>

The 'type' attribute and the 'language' subelement both become keys in
a hash.

=cut
$Handlers{subtitles}->[0] = sub( $ ) {
    my $node = shift;
    my %attrs = %{get_attrs($node)};
    my %r;
    $r{type} = $attrs{type} if defined $attrs{type};
    foreach (get_subelements($node)) {
	my $name = get_name($_);
	my $value = get_text($_);
	if ($name eq 'language') {
	    warn "'language' seen twice" if defined $r{language};
	    $r{language} = $value;
	}
	else {
	    warn "bad content of 'subtitles' element: $name";
	}
    }
    return \%r;
};
$Handlers{subtitles}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    t 'subtitles';
    my ($type, $language) = ($v->{type}, $v->{language});
    my %attrs; $attrs{type} = $type if defined $type;
    if (defined $language) {
	$w->startTag($e, %attrs);
	$w->dataElement('language', $language);
	$w->endTag($e);
    }
    else {
	$w->emptyTag($e, %attrs);
    }
};

=pod

=item I<rating>

The rating is represented as a tuple of [ rating, system, icons ].
The last element is itself a listref of structures returned by the
I<icon> handler.

=cut
$Handlers{rating}->[0] = sub( $ ) {
    my $node = shift;
    my %attrs = %{get_attrs($node)};
    my $system = delete $attrs{system} if exists $attrs{system};
    foreach (keys %attrs) {
	warn "unknown attribute in rating: $_";
    }
    my @children = get_subelements($node);

    # First child node is value.
    my $value_node = shift @children;
    if (not defined $value_node) {
	warn "missing 'value' element inside rating";
	return undef;
    }
    if ((my $name = get_name($value_node)) ne 'value') {
	warn "expected 'value' node inside rating, got '$name'";
	return undef;
    }

    my $rating = read_value($value_node);

    # Remaining children are icons.
    my @icons = map { read_icon($_) } @children;
	
    return [ $rating, $system, \@icons ];
};
$Handlers{rating}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    my ($rating, $system, $icons) = @$v;
    if (defined $system) {
	$w->startTag($e, system => $system);
    }
    else {
	$w->startTag($e);
    }

    write_value($w, 'value', $rating);
    write_icon($w, 'icon', $_) foreach @$icons;
    $w->endTag($e);
};

=pod

=item I<star-rating>

In XML this is a string 'X/Y' plus a list of icons.  In Perl represented
as a pair [ rating, icons ] similar to I<rating>.

=cut
$Handlers{'star-rating'}->[0] = sub( $ ) {
    my $node = shift;
    my @children = get_subelements($node);

    # First child node is value.
    my $value_node = shift @children;
    if (not defined $value_node) {
	warn "missing 'value' element inside star-rating";
	return undef;
    }
    if ((my $name = get_name($value_node)) ne 'value') {
	warn "expected 'value' node inside star-rating, got '$name'";
	return undef;
    }
    my $rating = read_value($value_node);

    # Remaining children are icons.
    my @icons = map { read_icon($_) } @children;
	
    return [ $rating, \@icons ];
};
$Handlers{'star-rating'}->[1] = sub ( $$$ ) {
    my ($w, $e, $v) = @_;
    my ($rating, $icons) = @$v;
    $w->startTag($e);
    write_value($w, 'value', $rating);
    write_icon($w, 'icon', $_) foreach @$icons;
    $w->endTag($e);
};

=pod

=item I<icon>

An icon in XMLTV files is like the <img> element in HTML.  It is
represented in Perl as a hashref with 'src' and optionally 'width'
and 'height' keys.

=cut
$Handlers{icon}->[0] = sub( $ ) {
    my $node = shift;
    my %attrs = %{get_attrs($node)};
    warn "missing 'src' attribute in icon" if not defined $attrs{src};
    return \%attrs;
};
$Handlers{icon}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    $w->emptyTag($e, %$v);
};

# To keep things tidy some elements that can have icons store their
# textual content inside a subelement called 'value'.  These two
# routines are a bit trivial but they're here for consistency.
#
sub read_value( $ ) {
    my $value_node = shift;
    my $v = get_text($value_node);
    if (not defined $v or $v eq '') {
	warn "no content of 'value' element";
	return undef;
    }
    return $v;
}
sub write_value( $$$ ) {
    my ($w, $e, $v) = @_;
    $w->dataElement($e, $v);
};


# Booleans in XMLTV files are 'yes' or 'no'.
sub decode_boolean( $ ) {
    my $value = shift;
    if ($value eq 'no') {
	return 0;
    }
    elsif ($value eq 'yes') {
	return 1;
    }
    else {
	warn "bad boolean: $value";
	return undef;
    }
}
sub encode_boolean( $ ) {
    shift() ? 'yes' : 'no';
}


=pod

=item I<with-lang>

In XML something like title can be either <title>Foo</title>
or <title lang="en">Foo</title>.  In Perl these are stored as
[ 'Foo' ] and [ 'Foo', 'en' ].  For the former [ 'Foo', undef ]
would also be okay.

=cut
$Handlers{'with-lang'}->[0] = sub( $ ) {
    my $node = shift;
    my $value = get_text($node);
    if (not length $value) {
	warn 'empty string for with-lang value';
	return undef;
    }
    my %attrs = %{get_attrs($node)};
    my $lang = $attrs{lang} if exists $attrs{lang};

    if (defined $lang) {
	return [ $value, $lang ];
    }
    else {
	return [ $value ];
    }
};
$Handlers{'with-lang'}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;
    for ($v->[0]) { s/^\s+//; s/\s+$// }
    if (not length $v->[0]) {
	warn "not writing empty content for $e";
	return;
    }
    if (@$v == 1) {
	$w->dataElement($e, $v->[0]);
    }
    elsif (@$v == 2) {
	my ($text, $lang) = @$v;
	if (defined $lang) {
	    $w->dataElement($e, $text, lang => $lang);
	}
	else {
	    $w->dataElement($e, $text);
	}
    }
    else {
	warn "bad text-with-language scalar";
    }
};

=pod

=item I<with-lang-or-empty>

Either text with language, or the empty string.  This is used for
things which can have an optional human-readable 'explanation'.  The
Perl representation is [ 'Foo', language ] for text with known
language, [ 'Foo' ] or [ 'Foo', undef if the language is unknown,
and just [] for 'present but no text'.

=cut
$Handlers{'with-lang-or-empty'}->[0] = sub( $ ) {
    my $node = shift;
    my $value = get_text($node);
    my %attrs = %{get_attrs($node)};
    my $lang = $attrs{lang} if exists $attrs{lang};
    if (not length $value) {
	warn 'empty string may not have language' if defined $lang;
	return [];
    }

    if (defined $lang) {
	return [ $value, $lang ];
    }
    else {
	return [ $value ];
    }
};
$Handlers{'with-lang-or-empty'}->[1] = sub( $$$ ) {
    my ($w, $e, $v) = @_;

    if (@$v == 0) {
	$w->emptyTag($e);
    }
    elsif (@$v == 1) {
	$w->dataElement($e, $v->[0]);
    }
    elsif (@$v == 2) {
	my ($text, $lang) = @$v;
	if (defined $lang) {
	    $w->dataElement($e, $text, lang => $lang);
	}
	else {
	    $w->dataElement($e, $text);
	}
    }
    else {
	warn "bad text-with-language scalar";
    }
};

# Sanity check.
foreach (keys %Handlers) {
    my $v = $Handlers{$_};
    if (@$v != 2
        or ref($v->[0]) ne 'CODE'
        or ref($v->[1]) ne 'CODE') {
        die "bad handler pair for $_\n";
    }
}

=pod

Now, which handlers are used for which subelements (keys) of channels
and programmes?  And what is the multiplicity (should you expect a
single value or a list of values)?

The following tables map subelements of <channel> and of <programme>
to the handlers used to read and write them.  Many elements have their
own handler with the same name, and most of the others use
I<with-lang>.  The third column specifies the multiplicity of the
element: B<*> (any number) will give a list of values in Perl, B<+>
(one or more) will give a nonempty list, B<?> (maybe one) will give a
scalar, and B<1> (exactly one) will give a scalar which is not undef.

=head2 Handlers for <channel>

@CHANNEL_HANDLERS

=head2 Handlers for <programme>

@PROGRAMME_HANDLERS

At present, no parsing or validation on dates is done because dates
may be partially specified in XMLTV.  For example '2001' means that
the year is known but not the month, day or time of day.  Maybe in the
future dates will be automatically converted to and from
B<Date::Manip> objects.  For now they just use the I<scalar> handler.
Similar remarks apply to URLs.

=cut
# Private.
sub node_to_programme( $ ) {
    my $node = shift;
    my %programme;
#    local $Log::TraceMessages::On = 1;

    # Attributes of programme element.
    %programme = %{get_attrs($node)};
    t 'attributes: ' . d \%programme;

    # Check the required attributes are there.  As with most checking,
    # this isn't an alternative to using a validator but it does save
    # some headscratching during debugging.
    #
    foreach (qw(start channel)) {
	if (not defined $programme{$_}) {
	    warn "programme missing '$_' attribute\n";
	}
    }
    my @known_attrs = qw(start stop pdc-start vps-start showview
			 videoplus channel clumpidx);
    my %ka; ++$ka{$_} foreach @known_attrs;
    foreach (keys %programme) {
	unless ($ka{$_}) {
	    warn "deleting unknown attribute '$_'";
	    delete $programme{$_};
	}
    }

    call_handlers_read($node, \@Programme_Handlers, \%programme);
    return \%programme;
}


# Private.
sub node_to_channel( $ ) {
    my $node = shift;
    my %channel;
    t 'node_to_channel() ENTRY';

    %channel = %{get_attrs($node)};
    t 'attributes: ' . d \%channel;
    if (not defined $channel{id}) {
	warn "channel missing 'id' attribute\n";
    }
    foreach (keys %channel) {
	unless (/^_/ or $_ eq 'id') {
	    warn "deleting unknown attribute '$_'";
	    delete $channel{$_};
	}
    }
		
    t '\@Channel_Handlers=' . d \@Channel_Handlers;
    call_handlers_read($node, \@Channel_Handlers, \%channel);
    return \%channel;
}



# Private.
#
# call_handlers_read()
#
# Read the subelements of a node according to a list giving a
# handler subroutine for each subelement.
#
# Parameters:
#   node
#   Reference to list of handlers: tuples of
#     [element-name, handler-name, multiplicity]
#   Reference to hash for storing results
#
# Warns if errors, but attempts to contine.
#
sub call_handlers_read( $$$ ) {
    my ($node, $handlers, $r) = @_;
    t 'call_handlers_read() using handlers: ' . d $handlers;

    die unless ref($r) eq 'HASH';
    use vars '%r'; local *r = $r;
    t 'going through each child of node';

    # Current position in handlers.  We expect to read the subelements
    # in the correct order as specified by the DTD.
    #
    my $handler_pos = 0;

    SUBELEMENT: foreach (get_subelements($node)) {
	t 'doing subelement';
	my $name = get_name($_);
	t "tag name: $name";

	# Search for a handler - from $handler_pos onwards.  But
	# first, just warn if somebody is trying to use an element in
	# the wrong place (trying to go backwards in the list).
	#
	my $found_pos;
	foreach my $i (0 .. $handler_pos - 1) {
	    if ($name eq $handlers->[$i]->[0]) {
		warn "element $name not expected here";
		next SUBELEMENT;
	    }
	}
	for (my $i = $handler_pos; $i < @$handlers; $i++) {
	    if ($handlers->[$i]->[0] eq $name) {
		t 'found handler';
		$found_pos = $i;
		last;
	    }
	    else {
		t "doesn't match name $handlers->[$i]->[0]";
		my ($handler_name, $h, $multiplicity)
		  = @{$handlers->[$i]};
		die if not defined $handler_name;
		die if $handler_name eq '';

		# Before we skip over this element, check that we got
		# the necessary values for it.
		#
		if ($multiplicity eq '?') {
		    # Don't need to check whether this set.
		}
		elsif ($multiplicity eq '1') {
		    if (not defined $r{$handler_name}) {
			warn "no element $handler_name found";
		    }
		}
		elsif ($multiplicity eq '*') {
		    # It's okay if nothing was ever set.  We don't
		    # insist on putting in an empty list.
		    #
		}
		elsif ($multiplicity eq '+') {
		    if (not defined $r{$handler_name}) {
			warn "no element $handler_name found";
		    }
		    elsif (not @{$r{$handler_name}}) {
			warn "strangely, empty list for $handler_name";
		    }
		}
		else {
		    warn "bad value of $multiplicity: $!";
		}
	    }
	}
	if (not defined $found_pos) {
	    warn "unknown element $name";
	    next;
	}
	# Next time we begin searching from this position.
	$handler_pos = $found_pos;

	# Call the handler.
	t 'calling handler';
	my ($handler_name, $h_name, $multiplicity)
	  = @{$handlers->[$found_pos]};
	die if $handler_name ne $name;
	my $h = $Handlers{$h_name}; die "no handler $h_name" if not $h;
	my $result = $h->[0]->($_); # call reader sub
	t 'result: ' . d $result;

	# Now set the value.  We can't do multiplicity checking yet
	# because there might be more elements of this type still to
	# come.
	#
	if ($multiplicity eq '?' or $multiplicity eq '1') {
	    warn "seen $name twice"
	      if defined $r{$name};
	    $r{$name} = $result;
	}
	elsif ($multiplicity eq '*' or $multiplicity eq '+') {
	    push @{$r{$name}}, $result;
	}
	else {
	    warn "bad multiplicity: $multiplicity";
	}
    }
}


package XMLTV::Writer;
use base 'XML::Writer';

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
    }
}

=pod

=back

=head1 INCREMENTAL READING AND WRITING

Because of the way parsing is currently implemented, it is not possible
to read a file lazily.  You have to wait for the whole XML document to
be loaded in and parsed, and then you are given all the programmes and
channels at once.

The C<write_data()> function provides the equivalent approach to writing:
it prints a whole XMLTV document at once.  This is often sufficient, but
sometimes you want to write out programmes gradually, as they are produced.
For this you can manually create an C<XMLTV::Writer> object and call
methods on it.  Synopsis:

  use XMLTV;
  my $w = new XMLTV::Writer();
  $w->comment("Hello from XML::Writer's comment() method");
  $w->start({ 'generator-info-name' => 'Example code in pod' });
  my %ch = (id => 'test-channel', 'display-name' => [ [ 'Test', 'en' ] ]);
  $w->write_channel(\%ch);
  my %prog = (channel => 'test-channel', start => '200203161500',
	      title => [ [ 'News', 'en' ] ]);
  $w->write_programme(\%prog);
  $w->end();

XMLTV::Writer inherits from XML::Writer, and provides the following extra
or overridden methods:

=over

=item new(), the constructor

Creates an XMLTV::Writer object and starts writing an XMLTV file, printing
the DOCTYPE line.  Arguments are passed on to XML::WriterE<39>s constructor,
except that the 'encoding' key if present gives the XML character encoding.
For example:

my $w = new XMLTV::Writer(encoding => 'ISO-8859-1');

If encoding is not specified, XML::WriterE<39>s default is used
(currently UTF-8).

=cut
sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my %args = @_;
    my $encoding = delete $args{encoding};
    my $self = $class->SUPER::new(DATA_MODE => 1, DATA_INDENT => 2, %args);
    bless($self, $class);

    if (defined $encoding) {
	$self->xmlDecl($encoding);
    }
    else {
	$self->xmlDecl();
    }

    {
	local $^W = 0; $self->doctype('tv', undef, 'xmltv.dtd');
    }
    return $self;
}

=pod

=item start()

Write the start of the <tv> element.  Parameter is a hashref which gives
the attributes of this element.

=cut
sub start {
    my $self = shift;
    die 'usage: XMLTV::Writer->start(hashref of attrs)' if @_ != 1;
    my $attrs = shift;
    $self->startTag('tv', order_attrs(%{$attrs}));
}

=pod

=item write_channels()

Write several channels at once.  Parameter is a reference to a hash
mapping channel id to channel details.  They will be written sorted
by id, which is reasonable since the order of channels in an XMLTV
file isnE<39>t significant.

=cut
sub write_channels {
    my ($w, $channels) = @_;
    t('write_channels(' . d($w) . ', ' . d($channels) . ') ENTRY');
    foreach (sort keys %$channels) {
	t "writing channel with id $_";
	my $ch = $channels->{$_};
	$w->write_channel($ch);
    }
    t('write_channels() EXIT');
}

=pod

=item write_channel()

Write a single channel.  You can call this routine if you want, but
most of the time C<write_channels()> is a better interface.

=cut
sub write_channel {
    my ($w, $ch) = @_;
    die if ref $ch ne 'HASH';
    my %ch = %$ch; # make a copy
    my $id = delete $ch{id};
    die "no 'id' attribute in channel" if not defined $id;
    $w->startTag('channel', id => $id);
    call_handlers_write($w, \@XMLTV::Channel_Handlers, \%ch);
    foreach (keys %ch) {
	warn "unknown key in channel: $_" unless /^_/;
    }
    $w->endTag('channel');
}

=pod

=item write_programme()

Write details for a single programme as XML.

=cut
sub write_programme {
#    local $Log::TraceMessages::On = 1;
    my $self = shift;
    die 'usage: XMLTV::Writer->write_programme(programme hash)' if @_ != 1;

    # We make a copy of the programme hash and delete elements from it
    # as they are dealt with; then we can easily spot any unhandled
    # elements at the end.
    #
    use vars '%p'; local *p = shift;

    t('write_programme(' . d($self) . ', ' . d(\%p) . ') ENTRY');

    # First deal with those hash keys that refer to metadata on when
    # the programme is broadcast.  After taking those out of the hash,
    # we can use the handlers to output individual details.
    #
    my $start = delete $p{start};
    if (not defined $start) {
	warn "programme missing start time, skipping";
	return;
    }
    # Just output dates as strings (see comment at read_date()).
    my %attrs = (start => $start);
    if (defined(my $val = delete $p{stop})) {
	$attrs{stop} = $val;
    }
    foreach (qw(channel clumpidx)) {
	my $val = delete $p{$_};
	$attrs{$_} = $val if defined $val;
    }
    t "beginning 'programme' element";
    $self->startTag('programme', order_attrs(%attrs));

    call_handlers_write($self, \@XMLTV::Programme_Handlers, \%p);
    foreach (keys %p) {
	if (/^_/) {
	    # Don't write.
	}
	elsif (/^debug/) {
	    my $val = delete $p{$_};
	    if (defined $val) {
		$self->comment("$_: $val");
	    }
	    else {
		$self->comment($_);
	    }
	}
	else {
	    warn "unknown key '$_' in programme hash";
	}
    }
    t "ending 'programme' element";
    $self->endTag('programme');
}

=pod

=item end()

Say youE<39>ve finished writing programmes.  This ends the <tv> element
and the file.

=cut
sub end {
    my $self = shift;
    $self->endTag('tv');
    $self->SUPER::end(@_);
}


# Private.
# order_attrs()
#
# In XML the order of attributes is not significant.  But to make
# things look nice we try to output them in the same order as given in
# the DTD.
#
# Takes a list of (key, value, key, value, ...) and returns one with
# keys in a nice-looking order.
#
sub order_attrs {
    die "expected even number of elements, from a hash"
      if @_ % 2;
    # This is copied from the ATTRLISTs for programme and tv.
    my @a = (qw(start stop pdc-start vps-start showview videoplus
		channel clumpidx),
	     qw(date source-info-url source-info-name source-data-url
		generator-info-name generator-info-url));

    my @r;
    my %in = @_;
    foreach (@a) {
	if (exists $in{$_}) {
	    my $v = delete $in{$_};
	    push @r, $_, $v;
	}
    }

    foreach (sort keys %in) {
	warn "unknown attribute $_" unless /^_/;
	push @r, $_, $in{$_};
    }

    return @r;
}


# Private.
#
# Writes the elements of a hash to an XMLTV::Writer using a list of
# handlers.  Deletes keys (modifying the hash passed in) as they are
# written.
#
sub call_handlers_write( $$$ ) {
    my ($self, $handlers, $input) = @_;
    t 'writing input hash: ' . d $input;
    die if not defined $input;
    foreach (@$handlers) {
	my ($name, $h_name, $multiplicity) = @$_;
	my $h = $XMLTV::Handlers{$h_name}; die "no handler $h_name" if not $h;
	my $writer = $h->[1]; die if not defined $writer;
	t "doing handler for $name$multiplicity";
	t "do we need to write any $name elements?";
	if (not exists $input->{$name}) {
	    t "nope, none there";
	    next;
	}

	if (not defined $input->{$name}) {
	    warn "hash has key $name with value undef\n";
	    delete $input->{$name};
	    next;
	}

	my $val = delete $input->{$name};
	t 'yes, got value(s): ' . d $val;
	if ($multiplicity eq '1') {
	    t 'exactly one element';
	    if (not defined $val) {
		warn "missing value for $name in programme hash";
		next;
	    }
	    $writer->($self, $name, $val);
	}
	elsif ($multiplicity eq '?') {
	    t 'maybe one element';
	    if (defined $val) {
		$writer->($self, $name, $val);
	    }
	}
	elsif ($multiplicity eq '*') {
	    t 'any number';
	    if (not defined $val) {
		warn "missing value for $name in programme hash (expected list)";
		next;
	    }
	    if (ref($val) ne 'ARRAY') {
		die "expected array of values for $name";
	    }
	    foreach (@{$val}) {
		t 'writing value: ' . d $_;
		$writer->($self, $name, $_);
		t 'finished writing multiple values';
	    }
	}
	elsif ($multiplicity eq '+') {
	    t 'at least one';
	    if (not defined $val) {
		warn "missing value for $name in programme hash (expected list)";
		next;
	    }
	    if (ref($val) ne 'ARRAY') {
		die "expected array of values for $name";
	    }
	    if (not @$val) {
		warn "empty list of $name properties in programme hash";
		next;
	    }
	    foreach (@{$val}) {
		t 'writing value: ' . d $_;
		$writer->($self, $name, $_);
		t 'finished writing multiple values';
	    }
	}
	else {
	    warn "bad multiplicity specifier: $multiplicity";
	}
    }
    t 'leftover keys: ' . d([ sort keys %$input ]);
}

=pod

=head1 AUTHOR

Ed Avis, ed@membled.com

=head1 SEE ALSO

The file format is defined by the DTD xmltv.dtd, which is included in
the xmltv package along with this module.  It should be installed in
your systemE<39>s standard place for SGML and XML DTDs.

The xmltv package has a web page at
<http://membled.com/work/apps/xmltv/> which carries
information about the file format and the various tools and apps which
use this module.

=cut
1;
