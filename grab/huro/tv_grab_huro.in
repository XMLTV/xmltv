#!/usr/bin/perl -w

=pod

=head1 NAME

tv_grab_huro - Grab TV listings for Hungary or Romania.

=head1 SYNOPSIS

tv_grab_huro --help

tv_grab_huro [--config-file FILE] --configure [--gui OPTION]

tv_grab_huro [--config-file FILE] [--output FILE] [--days N] [--offset N]
             [--slow] [--get-full-description] [--max-desc-length LENGTH]
             [--icons | (--local-icons DIRECTORY [--no-fetch-icons])]
             [--quiet]

tv_grab_huro --list-channels --loc [hu | ro]
             [--icons | (--local-icons DIRECTORY [--no-fetch-icons])]

tv_grab_huro --capabilities

tv_grab_huro --version

=head1 DESCRIPTION

Output TV listings for several channels available in Hungary or
Romania.  The grabber relies on parsing HTML so it might stop working
at any time.

First run B<tv_grab_huro --configure> to choose, which channels you want
to download. Then running B<tv_grab_huro> with no arguments will output
listings in XML format to standard output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_huro.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of Term::ProgressBar.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  The default is eight.

B<--offset N> start N days in the future.  The default is to start
from today.

B<--quiet> suppress the progress messages normally written to standard
error.

B<--slow> enables long strategy run: port.hu publishes only some (vital)
information on the actual listing pages, the rest is shown in a separate
popup window. If you'd like to parse the data from these popups as well,
supply this flag. But consider that the grab process takes much longer when
doing so, since many more web pages have to be retrieved.

B<--get-full-description> is quite like B<--slow> but doesn't always download
data from popup window.  Instead this is only requested if description in
overview is truncated.

B<--list-channels> write output giving <channel> elements for every
channel available (ignoring the config file), but no programmes.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://membled.com/twiki/bin/view/Main/XmltvCapabilities>

B<--version> Show the version of the grabber.

B<--icons> and B<--local-icons DIRECTORY> get the URL for
channel-logos together with the channel-list. With B<--icons>
specified the logos(images) will be not fetched just their URL (http://...)
will be written in the output XML. If called with B<--local-icons>,
the generated URL (file://...) will point to the the local directory
DIRECTORY and all channel logos will be grabbed and saved under this place.
Use B<--no-fetch-icons> option to disable the icon fetching.

B<--max-desc-length LENGTH> can be used to maximize the lenght of
the grabbed program long description. This can be usefull if you have
a viewer program (using this xmltv output), which can not be display
userfriendly the description if it is more then LENGTH character.

B<--help> print a help message and exit.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Attila Szekeres and Zsolt Varga.  Based on tv_grab_fi by Matti Airas.
Heavily patched by Stefan Siegl <stesie@brokenpipe.de> and afterwards
by Molnar Balazs <moba@t-online.hu>

Currently maintained by Stefan Siegl <stesie@brokenpipe.de>.

=head1 BUGS

The data source does not include full channels information and the
channels are identified by short names rather than the RFC2838 form
recommended by the XMLTV DTD.

=cut

######################################################################
# initializations

use strict;
use XMLTV::Version '$Id$ ';
use XMLTV::Capabilities qw/baseline manualconfig cache share/;
use XMLTV::Description 'Hungary/Romania';
use Getopt::Long;
use Date::Manip;
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;

use XMLTV;
use XMLTV::Memoize;
use XMLTV::ProgressBar;
use XMLTV::Ask;
use XMLTV::DST;
use XMLTV::Get_nice;
use XMLTV::Mode;
use XMLTV::Config_file;
use XMLTV::Date;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get Hungarian or Romanian television listings in XMLTV format
To configure: $0 --configure [--config-file FILE] [--gui OPTION]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
      [--slow] [--get-full-description] [--max-desc-length LENGTH]
      [--icons | (--local-icons DIRECTORY [--no-fetch-icons])]
      [--quiet]
To list channels: $0 --list-channels --loc [hu | ro]
      [--icons | (--local-icons DIRECTORY [--no-fetch-icons])]
To show capabilities: $0 --capabilities
To show version: $0 --version
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
  eval { require Log::TraceMessages };
  if ($@) {
    *t = sub {};
    *d = sub { '' };
  }
  else {
    *t = \&Log::TraceMessages::t;
    *d = \&Log::TraceMessages::d;
    Log::TraceMessages::check_argv();
  }
}

# switch DEBUG  in:
#${Log::TraceMessages::On} = 1;

sub grab_icon( $$ );
sub domain( $ );
sub xhead( $ );
sub xid( $$ );
sub process_table( $$$$$ );
sub make_programme_hash( $$$$$$ );
sub bump_start_day( $$ );
sub get_program_data( @ );
sub get_time( @ );
sub get_title( @ );
sub get_desc( @ );
#sub parse_desc ( $ );
sub get_channels( $ );
sub get_infourl_data( $$ );
sub nextday( $ );
sub add_person ( $$$ );

# Attributes of the root element in output.
sub domain( $ ) { "port.$_[0]" };
sub xhead( $ ) {
    my $d = &domain;
    return { 'source-info-url'     => "http://www.$d/",
	     'source-data-url'     => "http://www.$d/tv/",
	     'generator-info-name' => 'XMLTV',
	     'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
	   };
}

my %COUNTRIES = (Hungary => [ 'hu', '+0100' ],
                 Romania => [ 'ro', '+0200' ],);

# Whether zero-length programmes should be included in the output.
my $WRITE_ZERO_LENGTH = 0;

# Global channel data.
our @ch_all;

######################################################################
# get options

# Get options, including undocumented --cache option.
XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');

my ($opt_days, $opt_offset, $opt_help, $opt_output, $opt_share,
    $opt_configure, $opt_config_file, $opt_gui, $opt_quiet,
    $opt_list_channels, $opt_loc, $opt_slow, $opt_full_desc,
    $opt_local_icons, $opt_icons, $opt_no_fetch_icons,
    $opt_max_desc_length);

$opt_slow = 0;
$opt_full_desc = 0;
$opt_days = 8; # default
$opt_offset = 0; # default
$opt_quiet = 0; # default
GetOptions('days=i'        => \$opt_days,
	   'offset=i'      => \$opt_offset,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'gui:s'         => \$opt_gui,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'quiet'         => \$opt_quiet,
	   'slow'          => \$opt_slow,
	   'get-full-description' => \$opt_full_desc,
	   'list-channels' => \$opt_list_channels,
           'icons'         => \$opt_icons,
           'local-icons=s' => \$opt_local_icons,
           'no-fetch-icons'=> \$opt_no_fetch_icons,
	   'loc=s'         => \$opt_loc,
	   'share=s'       => \$opt_share,
           'max-desc-length=s' => \$opt_max_desc_length
	   )
  or usage(0);

die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);

usage(1) if $opt_help;

my $mode = XMLTV::Mode::mode('grab', # default
			     $opt_configure => 'configure',
                             $opt_list_channels => 'list-channels');

XMLTV::Ask::init($opt_gui);

# File that stores which channels to download.
my $config_file = XMLTV::Config_file::filename($opt_config_file,
                                               'tv_grab_huro',
                                               $opt_quiet,
                                               'tv_grab_hu');

my @config_lines; # used only in grab mode

if ($mode eq 'configure') {
    XMLTV::Config_file::check_no_overwrite($config_file);
}
elsif ($mode eq 'grab') {
    @config_lines = XMLTV::Config_file::read_lines($config_file);
}
elsif ($mode eq 'list-channels') {
    # Config file not used.
}
else { die }

######################################################################
# write configuration

if ($mode eq 'configure') {
    open(CONF, ">$config_file") or die "cannot write to $config_file: $!";

    my $default_cn = 'Hungary';
    my $cn = ask_choice('Grab listings for which country?',
			 $default_cn,
			 sort keys %COUNTRIES);
    my $c = $COUNTRIES{$cn}[0];
    print CONF "country $c\t# $cn\n";

    # Ask about each channel.
    my %channels = get_channels($c);
    my @chs = sort keys %channels;
    my @names = map { $channels{$_} } @chs;
    my @qs = map { "add channel $_?" } @names;
    my @want = ask_many_boolean(1, @qs);
    foreach (@chs) {
	my $w = shift @want;
	warn("cannot read input, stopping channel questions"), last
	  if not defined $w;
	# No need to print to user - XMLTV::Ask is verbose enough.

	# Print a config line, but comment it out if channel not wanted.
	print CONF '#' if not $w;
	my $name = shift @names;
	print CONF "channel $_ $name\n";
	# TODO don't store display-name in config file.
    }

    close CONF or warn "cannot close $config_file: $!";
    say("Finished configuration.");

    exit();
}

# Not configuration, we must be writing something, either full
# listings or just channels.
#
die if $mode ne 'grab' and $mode ne 'list-channels';

# Options to be used for XMLTV::Writer.
my %w_args;
if (defined $opt_output) {
    my $fh = new IO::File(">$opt_output");
    die "cannot write to $opt_output: $!" if not defined $fh;
    $w_args{OUTPUT} = $fh;
}
$w_args{encoding} = 'ISO-8859-2';

######################################################################
# write only channel list

if ($mode eq 'list-channels') {
    # Write channels mode.
    if (not defined $opt_loc) {
	my $msg = "--loc option required with --list-channels:\n";
	foreach (sort keys %COUNTRIES) {
	    $msg .= "    --loc $COUNTRIES{$_}[0] for $_\n";
	}
	die $msg;
    }
    my $writer = new XMLTV::Writer(%w_args);
    $writer->start(xhead($opt_loc));
    get_channels($opt_loc); # sets @ch_all
    $writer->write_channel($_) foreach @ch_all;
    $writer->end();
    exit();
}

######################################################################
# We are producing full listings.
die if $mode ne 'grab';

# Read configuration
my $line_num = 0;
my ($country, $tz);
my @channels;
foreach (@config_lines) {
    ++ $line_num;
    next if not defined;
    my $where = "$config_file:$line_num";
    if (/^country:?\s+(\w\w)$/) {
	warn "$where: already seen country\n"
	  if defined $country;
	$country = $1;

	# Lame reverse lookup on %COUNTRIES.
	foreach (values %COUNTRIES) {
	    if ($_->[0] eq $country) {
		$tz = $_->[1];
		last;
	    }
	}
	die "$where: unknown country $country\n" if not defined $tz;
    }
    elsif (/^channel:?\s+(\S+)\s+([^\#]+)/) {
	my $ch_did = $1;
	my $ch_name = $2;
	$ch_name =~ s/\s*$//;
	push @channels, $ch_did;
	# FIXME do not store display-name in the config file - it is
	# ignored here.
	#
    }
    else {
	warn "$config_file:$.: bad line\n";
    }
}

for ($country) {
    if (not defined) {
	$_ = 'hu';
	warn "country not seen in $config_file, assuming '$_'\n";
    }
}

######################################################################
# read jobmap file
# (this is a file, where we store translations of job names from 
#  Hungarian or Romanian language to English.  However we leave some
#  translations blank, namely these that have no field in the credits
#  structure)

# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_huro.PL.  But we can
# use the current directory instead of share/tv_grab_huro for
# development.
#
# The 'source' file tv_grab_huro.in has $SHARE_DIR undef, which
# means use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_huro" : '.';

# Read the file with channel mappings.
(my $JOBMAP_FILE = "$OUR_SHARE_DIR/jobmap") =~ tr#/#/#s;
my %jobmap;
$line_num = 0;
foreach (XMLTV::Config_file::read_lines($JOBMAP_FILE, 1)) {
    ++ $line_num;
    next unless defined;
    my $where = "$JOBMAP_FILE:$line_num";
    my @fields = split m/:/;
    die "$where: wrong number of fields"
      if @fields > 2;

    my ($huro_job, $credits_id) = @fields;
    $jobmap{$huro_job} = defined($credits_id) ? $credits_id : "";
}

# Read the file with channel mappings.
# cat_en:cat_hu:regexp
(my $CATMAP_FILE = "$OUR_SHARE_DIR/catmap.$country") =~ tr#/#/#s;
my %catmap;
$line_num = 0;
foreach (XMLTV::Config_file::read_lines($CATMAP_FILE, 1)) {
    ++ $line_num;
    next unless defined;
    my $where = "$CATMAP_FILE:$line_num";
    my @fields = split m/:/;
    die "$where: wrong number of fields"
      if @fields > 3;

    my ($cat_en, $cat_hu, $cat_reg) = @fields;
    $catmap{$cat_en} = defined($cat_reg) ? [$cat_reg, $cat_hu]
	: [$cat_hu, $cat_hu];
}



######################################################################
# begin main program

my $now = DateCalc(parse_date('now'), "$opt_offset days");
my %channels = get_channels($country); # sets @ch_all
my @to_get;
my $writer = new XMLTV::Writer(%w_args);
$writer->start(xhead($country));

# Turn a site channel id into an XMLTV id.
# Parameters: country, site id
sub xid( $$ ) {
    my ($country, $id) = @_;
    return "$id." . domain($country);
}

# Write channel elements
foreach my $ch_did (@channels) {
    my %channel = ( 'display-name' => [ [ $channels{$ch_did}, $country ] ],
		    'id'           => xid($country, $ch_did) ) ;
    # fetch and get icon url
    if (my $iconurl = grab_icon( domain($country), $ch_did )) {
	$channel{'icon'} = [ { src => $iconurl } ];
    }

    $writer->write_channel(\%channel);
}

# The grabber's source allows requests of more than one day per page. This can
# be done by specifying the i_xday argument with the GET request.
#
# To not load their server too much (requesting e.g. 14 channels in one shot
# should 'cause quite some traffic to the SQL server) I think we shouldn't 
# query for more then 5 channels per page. With the default of requesting data
# for 8 days this leads to 2 requests per channel and grab ...

my $daysperpage = int($opt_days / 5) + (($opt_days % 5) ? 1 : 0);
$daysperpage = int($opt_days / $daysperpage);

t "requesting $daysperpage days per scraped webpage ..."; 

# Make list of pages to fetch for each day.
my @days;
my $day=UnixDate($now,'%Q');
for (my $i=1+$opt_offset;$i<$opt_days+$opt_offset+1;$i+=$daysperpage) {
    push @days, [ $day, $i ];
    $day=nextday($day); die if not defined $day;
}

# This progress bar is for both downloading and parsing.  Maybe
# they could be separate stages.

my $bar = new XMLTV::ProgressBar('getting listings', @days * @channels)
  if not $opt_quiet;

foreach my $date_n_day (@days) {
    my ($aday, $iday) = @$date_n_day;
    my $some_success = 0;
    foreach my $ch_did (@channels) {
        my @ps = process_table($country, $aday, xid($country, $ch_did),
                               $ch_did, $iday);
	$some_success = 1 if @ps;
	$writer->write_programme($_) foreach @ps;
	update $bar if not $opt_quiet;
    }
    if (@channels and not $some_success) {
        warn "failed to get any listings for day $iday, stopping\n";
	last;
    }
}
$bar->finish() if not $opt_quiet;
$writer->end();

######################################################################
# subroutine definitions

####
# process_table: fetch a URL and process it
#
# arguments:
#    country id (hu, ro)
#    Date::Manip object giving the day to grab
#    xmltv id of channel
#    site id of channel
#
# returns: list of the programme hashes to write
#
sub process_table( $$$$$ ) {
    my ($country, $date, $ch_xmltv_id, $ch_port_id, $interval) = @_;

    my $d = domain($country);
    my $url = "http://www.$d/pls/tv/tv.channel?i_ch=$ch_port_id" .
    	      "&i_days=$interval&i_xday=$daysperpage&i_where=1";
    local $SIG{__WARN__} = sub {
	warn "$url: $_[0]";
    };

    # parse the page to a document object
    my $tree = get_nice_tree $url;

    # the page consists of two major tables, where one holds the data 
    # until 'bout 20 o'clock, the other, i.e. lower, one the evening program
    my $body = $tree->look_down("_tag"=>"body");

    # first scan for all tables in $body->content_list()
    my %tables;
    my $region;
    foreach($body->content_list()) {
	next unless(ref eq "HTML::Element");

        # don't consider anything before the closing </blockquote>
	# parsable information ...
	unless(defined $region) {
	    if($_->tag eq "blockquote"

	       # port.hu unfortunately doesn't show <blockquote> below <body>
	       # but embedded in <font>    :-(
	       || $_->look_down("_tag"=>"blockquote")) {
		$region = "upper";
	    }

	    next;
	}

	# we care for tables only ...
	next unless($_->tag eq "table");

	# filter out tables without strong tags, as those don't hold data.
	next unless($_->look_down("_tag"=>"strong"));

	# input fields are bad, these aren't worth anything for grabbing ...
	next if($_->look_down("_tag"=>"input"));

	# check whether it's one of the lower tables ...
	$region = "lower"
	  if($_->look_down("_tag"=>"img", "src"=>"/tv/kep/vonal.gif"));

	push @{$tables{$region}}, $_;
    }

    # indexes, pointing into table-lists, to continue parsing after break.
    my %indexes = ("upper" => 0, "lower" => 0);

    # we have the followign structure here:
    # @tables{ upper => [upper-table], lower => [lower-table] }

    my @program_data; # the array, we push our programmes into ..
    while(1) {
	my $lasttime = 0;

	foreach my $region ("upper", "lower") {
	    while(1) {
		my $tab = ($tables{$region})->[$indexes{$region}];
		last unless(defined($tab)); # get outta here ...

		# extract the first time specified in this table-piece ...
		$tab->as_text() =~ m/([012][0-9]):([0-5][0-9])/
		    or die "unable to parse returned html page";
		my $time = $1 * 60 + $2;
		$time += 24 * 60
		    if($time < 6 * 60 && ($lasttime >= 24 * 60
					  || $region eq 'lower'));

		last if($time < $lasttime); # must be the next column ...

		# parse this page's data ...
		push @program_data, get_program_data($tab);

		# lookup last time in this minor table ... (as base for comp.)
		$tab->as_text() =~ m/.*([012][0-9]):([0-5][0-9])/
		    or die "unable to parse returned html page";
		$lasttime = $1 * 60 + $2;
		if($lasttime < $time) { $lasttime += 24 * 60; } # bump one day.

		# continue with next table ...
		$indexes{$region} ++;
	    } 
	}

	last unless($lasttime); # we found at least some data => continue.
    }

    $tree->delete; # get rid of HTML::TreeBuilder's in memory representation

    if (not @program_data) {
	warn "no programs found, skipping\n";
	return ();
    }

    my @r;
    my $prev;
    while (@program_data) {
	my $cur = shift @program_data;

	if (defined $prev and bump_start_day($prev, $cur)) {
	    # bump start time, if necessary
	    $date = UnixDate(DateCalc($date, '+ 1 day'), '%Q');
	}

	# Assume country and lang. code the same.
	push @r, make_programme_hash($country, $tz, $date,
				     $ch_xmltv_id, $ch_port_id, $cur);

	if (defined($prev) && $prev->{q(time)} eq $cur->{q(time)}) {
	    # starttime of previous and current programme is equal,
	    # therefore use clumpidx to express relation
	    my $clumps_num;

	    if(defined($r[-2]->{q(clumpidx)})) {
		# previous programme already has a clumpidx arg assigned.
		($clumps_num) = $r[-2]->{q(clumpidx)} =~ m;^\d+/(\d+)$;;
	    } else { $clumps_num = 2; }

	    # okay, assign new clumpidx values ...
	    for(0..($clumps_num-1)) {
		$r[-$clumps_num+$_]->{q(clumpidx)} = "$_/$clumps_num";
	    }
	}

	$prev = $cur;
    }
    return @r;
}

sub make_programme_hash( $$$$$$ ) {
    my ($lang, $tz, $date, $ch_xmltv_id, $ch_port_id, $cur) = @_;

    my %prog;

    $prog{channel}=$ch_xmltv_id;
    $prog{title}=[ [ $cur->{title}, $lang ] ];

    my $start=parse_local_date("$date $cur->{time}", $tz);
    my ($start_base, $start_tz) = @{date_to_local($start, $tz)};
    $prog{start}=UnixDate($start_base, '%q') . " $start_tz";

    # FIXME: parse description field further
    $prog{desc}=[ [ $cur->{desc}{desc}, $lang ] ]
      if defined $cur->{desc}{desc};
    $prog{category} = $cur->{category} if (defined $cur->{category});
    $prog{date}    = $cur->{date} if defined $cur->{date};

    foreach my $infourl (@{$cur->{desc}{infourl}}) {
	# always read data from linked page (in --slow mode)
	if($opt_slow) {
            get_infourl_data(\%prog, $infourl);
	}
	
	# in --get-full-description mode read if description ends in '...'
	elsif($opt_full_desc && ($prog{desc})->[0]->[0] =~ m/\.\.\.$/) {
            get_infourl_data(\%prog, $infourl);
	}
    }

    return \%prog;
}

sub bump_start_day( $$ ) {
    my ($cur,$next) = @_;
    if (!defined($next)) {
	return undef;
    }
    my $start = UnixDate($cur->{time},'%H:%M');
    my $stop = UnixDate($next->{time},'%H:%M');
    if (Date_Cmp($start,$stop)>0) {
	return 1;
    } else {
	return 0;
    }
}


#
# program data is split as follows:
# - data is contained within many tag nodes, in a complicated hierarchy that
#   includes several tables...,
#   however each tv program listing has also a fixed head (HORA, TIPO,
#   CANAL...) and the data follows this header in a fixed order, so...
sub get_program_data( @ ) {
    my ($tree) = @_;
    my @data;

    my @html_time = get_time($tree);
    my @html_title = get_title($tree);
    my @html_desc = get_desc($tree);

    t "DESCs:" . d \@html_desc; 

    my $index = 0;
    while (defined $html_time[$index]) {
	my %h = (time =>$html_time[$index],
		 title=>$html_title[$index],
		 );

	if (defined($html_desc[$index])) {

	    $h{desc} = $html_desc[$index];   # this holds desc and categories

	    if (defined($html_desc[$index]{desc}) && 
		length($html_desc[$index]{desc})) {
		my %cy = parse_desc($html_desc[$index]{desc});

		$h{category} = $cy{category}
		  if defined($cy{category});
		$h{date}     = $cy{date} 
		  if (defined($cy{date}) && length($cy{date}));
	    }
	}
	push @data, \%h;
	$index++;
    }
    return @data;
}

sub get_time( @ ) {

    my ($tree) = @_;

    my @txt_elem; my $i = 0;
    my @txt_cont = $tree->look_down("_tag"=>"td", "align"=>"right",
				    "valign"=>"top");
    foreach my $txt (@txt_cont) {
	$_ = $txt->as_text;
	s/^\s+//;s/\s+$//;
	s/^Kb[.]//; # means 'approx' in Magyar

	# enforce <td> to contain timestr, port.hu tends to write out
	# an empty <td> now right before each column.
	m/.*([012][0-9]):([0-5][0-9])/ or next;

	# port.hu tends to write out 24:00 o'clock, replace by 00:00
	# which is expected to mean :)
	s/^24:/00:/;

	t "found " . $i++ . " time in program table: '$_'";
	push @txt_elem, $_;
    }
    
    return @txt_elem;
}

sub get_title( @ ) {
    my ($tree) = @_;

    my @txt_elem; my $i = 0;
    my @txt_cont = $tree->look_down("_tag"=>"td", "align"=>"left",
				    "valign"=>"top");
    foreach my $txt (@txt_cont) {
	my @fonts = $txt->find_by_tag_name("_tag"=>"font", "size"=>"2");
	my $text = $fonts[0]->as_text;
	for ($text) { s/^\s+//; s/\s+$// }
	t "found " . $i++ . " title in program table: '$text'"
	  unless $text eq '';
	push @txt_elem, $text unless $text eq '';
    }
	
    return @txt_elem;
}

sub get_desc( @ ) {
    my ($tree) = @_;
    
    my @txt_elem; my $i = 0;
    my @txt_cont = $tree->look_down("_tag"=>"td", "align"=>"left",
				    "valign"=>"top");
    foreach my $txt (@txt_cont) {
	my @urls;
	my @alltext;
	my @fonts = $txt->content_list();

	foreach (grep { ref } @fonts) {
	    for ($_->as_text) {
		s/^\s+//;s/\s+$//;
		push @alltext, $_ if length;
	    }
	}
	
	next unless (@alltext);

	my $joined;
	$joined = join(".  ", @alltext);
	t "found " . $i++ . " desc in program table: '$joined'";

	# add all found URL-s
	my @a_cont = $txt->look_down("_tag"=>"a");
	foreach my $a (@a_cont) {
	    push @urls,  $a->attr(q(href));
	}

	push @txt_elem, { "desc" => $joined, "infourl" => \@urls };
    }
    
    return @txt_elem;
}

# returns: ( category => [ [Animals, en], [Természet, hu], [..], ... ]
#            date     =>  2001 )
sub parse_desc {
    my $desc = $_[0];
    my %result;
    my ($cont, $contph, $conthead, $date, @categories);

    # 1: if there is () in the desc grab from there
    # 2: if no (), or
    # 3: no match found, try in the first 120 character
    #
    # examples:
    # Hegylako - A hollo  (amerikai-francia-kanadai kalandfilmsorozat, 1998)
    # Lisa.  Animációs sorozat.
    # Slayers - A kis boszorkány.  (12).  Japan animacios sorozat.

    $contph = "" unless (($contph) = $desc =~ m/[^\(]*(\([^\)]+\))/);
    $conthead = substr($desc, 0, (length($desc) < 120 ? length($desc) : 120));

    t "parse_desc: desc: '$desc'";

    foreach $cont ($contph, $conthead) {
	next unless length($cont);
	($date) = $cont =~ m/([12][0-9]{3})/ if !defined($date);
    }

    t "parse_desc: date: '$date'" if (defined($date) && length($date));

    # sometimes only the proposed minimal age of watching person is
    # presented in parentheses eg: (12), so parse this only if it is 
    # longer as for example 8
    $cont = ( length($contph) > 8 ? $contph : $conthead );

    t "parse_desc: text where looking for category: '$cont'";

    foreach (keys %catmap) {
	if ($cont =~ /$catmap{$_}[0]/i) {
	    push @categories, [$_, "en"];
	    push @categories, [$catmap{$_}[1], $country];
	    t "parse_desc: category: '$_'";
	}
    }

    $result{category} = \@categories;
    $result{date} = $date if (defined($date) && length($date));
    
    return %result;
}



# get channel listing for a country
sub get_channels( $ ) {
    my $country = shift;
    my $d = domain($country);
    my $bar = new XMLTV::ProgressBar('getting list of channels', 1)
	if not $opt_quiet;
    my %channels;
    my $url="http://www.$d/pls/tv/tv.prog";

    my $tree = get_nice_tree $url;
    my @menus = $tree->find_by_tag_name("_tag"=>"select");

    foreach my $elem (@menus) {
	my $cname = $elem->attr('name');
	if ($cname eq "i_ch") {
	    my @ocanals = $elem->find_by_tag_name("_tag"=>"option");
	    @ocanals = sort @ocanals;
	    foreach my $opt (@ocanals) {
		my %channel;
		if (not $opt->attr('value') eq "") {
		    my $channel_id = $opt->attr('value');
		    my $channel_name = $opt->as_text;
		    if (length $channel_id eq 1) {
			$channel_id = "00" . $channel_id;
		    }
		    if (length $channel_id eq 2) {
			$channel_id = "0" . $channel_id;
		    }
		    $channels{$channel_id}=$channel_name;
		    # Assume country code and lang. code the same.
		    %channel = ( 'display-name' => [[$channel_name, $country]],
				 'id'           => "$channel_id.$d" ) ;
		    # fetch and get icon url
		    if (my $iconurl = grab_icon( $d, $channel_id )) {
			$channel{'icon'} = [ { src => $iconurl } ];
		    }
		    $channel{'url'} = [ "http://www." . domain($country) . 
					"/pls/tv/tv.channel?i_ch=$channel_id&".
					"i_days=1&i_xday=3&i_where=1" ]; 
		    push @ch_all, \%channel;
		}
	    }
	}
    }
    die "no channels could be found" if not keys %channels;
    update $bar if not $opt_quiet;
    $bar->finish() if not $opt_quiet;
    return %channels;
}


# add_person (job, person, credits)
sub add_person ( $$$ ) {
    my ($job, $person, $rcredits) = @_;
    $person =~ s/\s+/ /g;

    return unless length($person);

    if (defined($jobmap{$job})) {
	push @{$$rcredits{$jobmap{$job}}}, $person;
    }
    else {
	push @{$$rcredits{'actor'}}, $person;
    }
    t "credits: added: '$job -> $person'";
}


# merge data from linked info page into programme hash
sub get_infourl_data( $$ ) {
    my $prog = shift;
    my $d = domain($country);
    my $url = "http://www.$d" . shift;

    # function to parse all of text data of a HTML element and his childrens :
    sub getalltext ( $ );
    sub getalltext ( $ ) {
	my @tmplines;
	my $e = $_[0];
	foreach my $c ($e->content_list) {
	    if (ref $c) { 
		push @tmplines, getalltext($c);
	    }
	    else {
		push @tmplines, $c;
	    }
	}
	return @tmplines;
    }

    # do not grab:
    # -> pictures: ... pls/me/picture.popup?i_area_id
    # -> dvd rent links page: ... pls/w/logging.page_log?i_page_id=20...
    # -> sample movie ... video.link_popup?i_object_id=18822

    if ($url =~ "(picture.popup|logging.page_log|video.link_popup)") {
	# add this url to the program
	push @{$prog->{q(url)}}, $url;
	t "SKIP fetching of slow url: $url";
	return;
    }

    t "fetching slow url" . d $url;
    # this url is the most important, url add this as the first
    if (defined $prog->{q(url)}) {
	@{$prog->{q(url)}} = ( $url, @{$prog->{q(url)}} );
    }
    else {
	push @{$prog->{q(url)}}, $url;
    }

    my $tree = HTML::TreeBuilder->new();
    my $data = get_nice($url);
    warn "could not fetch $url (infopage), trying to continue.\n"
      unless(defined $data);
    $tree->parse($data) or warn "cannot parse content of $url\n";
    $tree->eof;

    my (@lines, $anchor, $left, $right, $parent, $elem);

    ##################################################
    # SUBTITLE
    # anchor point: 
    # the title will be tagged aw follows:
    #              <span class="blackbigtitle"> title </span>
    # these siblings buld the subtitle, until a table follows... e.g.:
    #  <br><span class="txt"> ... subtitle line 1 ...<br>
    #  <span class="bsubtitle"> ...subtitle line 2 ... </span></center><p>
    #  <table ....
    #  we have to search the title tag and collect the text until table found

    t "suptitle parsing ...";
    ($anchor, undef) = $tree->look_down(_tag=>"span", class=>"blackbigtitle");
    if ($anchor) {
	$elem = $anchor; 
	my ($line, $engtitle, @tmp);
	while (($elem = $elem->right()) &&
	       ((ref $elem) && ($elem->tag() ne "table"))) {
	    # if a whole line is sorrounded with parentheses, on port.hu this
	    # is the program' english title
	    # add this as title and subtitle (because some viewer shows only
	    # infos of selected language (so the english title will be visible)
	    @tmp = getalltext($elem);
	    push @lines, @tmp;
	    $line = join(' ', @tmp);
	    if (($engtitle) = $line =~ m/^\s*\(([^\)]+)\)\s*$/) {
		push @{$prog->{q(title)}}, [$engtitle, 'en'];
		t "engtitle added: $engtitle";
	    }
	}
	my $joined = join(", ", @lines);
	t "anchor and right sibling found, lines parsed and joined:'$joined'";
	$prog->{q(sub-title)} = [[$joined, $country]] if length($joined);
    }

    ##################################################
    # LONG DESCRIPTION:
    # long description is preceded with the following HTML block, called "dots"
    # <table border="0" cellpadding="0" cellspacing="0" width="100%">
    # ...
    # <td background="/cc/hdots.gif"><img src="/cc/t.gif"
    # ...
    # </table>
    # anchor point: 
    # long desc is in the 3. block; blocks are delimited with dots (images),
    # to get the information:
    # after the 2. founded dots find the containing table element: this is the
    # nearest parent table
    # collect all text until the next table element.

    t "long desc parsing ...";
    my @dots = $tree->look_down(_tag=>"td", background => qr/hdots.gif/);
    return if ($#dots < 1);
    @lines = ();
    ($anchor, undef) = $dots[1]->look_up(_tag=>"table", width=>"100%");
    if ($anchor) {
	$elem = $anchor; 
	while (($elem = $elem->right()) &&
	       ((ref $elem) && ($elem->tag() ne "table"))) {
	    push @lines, getalltext($elem);
	}
	my $joined = join(" ", @lines);
	$joined =~ s/\xA0//;      # remove the to_text()'s results of &npsp
	t "long desc: anchor and right siblings found: joined:'$joined'";
	if (length($joined)) {
	    #$text =~ s/^\s+//; # remove blanks
	    #$text =~ s/\s+$//; # remove blanks
	    delete($prog->{q(desc)});
	    
	    # strip the desc at the specified command line
	    # option (if specified)
	    if (defined ($opt_max_desc_length) && 
		($opt_max_desc_length < length($joined))) {
		t "long desc was stripped, at: $opt_max_desc_length.";
		$joined = substr($joined, 0, $opt_max_desc_length - 3) . "...";
	    }
	    
	    $prog->{q(desc)} = [[ $joined, $country ]];
	}
    }

    ##################################################
    # SERIES NUMBER, CATEGORY, YEAR
    # anchor point: 
    # this is in the block, before the 1.st dots, we should find this
    # and collect all text data, and parse it from known datas.
    # the dots table is the child of a td element, which holds the usable data

    return if ($#dots < 0);

    if(!(($anchor, undef) = $dots[0]->look_up(_tag=>"table", width=>"100%"))) {
	return;
    }

    # collect all text lines
    if ($parent = $anchor->parent()) {
	push @lines, getalltext($parent);
    }

    # 0:{we are in credits secton}, 1:{duration,year section}
    my $section = 0;
    my $job = "foobar";
    my $part = "";
    my (%credits, $episode, $minutes, $year, $line);
    my $person = "";

    foreach $line (@lines) {
	$line =~ s/\xA0//; # remove to_text()'s results of &npsp
	t  "processing line: '" . d $line . "'";

	foreach $part (split /, */, $line) {
	    $part =~ s/^\s+//; # remove heading blanks
	    $part =~ s/\s+$//; # remove ending blanks
	    $part =~ s/^,*$//;
	    
	    next unless length $part;
	    t "processing part: '$part'";
	    
	    # we are in credits block if a known hungarian "job:" found
	    $section = 1 if (($section == 0) && 
			     (($_) = $part =~ m/\b(.+):/) && 
			     (defined($jobmap{$_})));
	  
	    if ($section == 0) {
		# duration, year, category
		# possibilitys
		# 1: amerikai filmdráma sorozat, 90 perc, 2000, 2. rész
		# 12 éven aluliak számára ....
		
		$_ = $part;
	      SWITCH: {
		  if ((m/\s*([0-9\/]+)\. rész/) && (! defined $episode))
		  { $episode = $1; last SWITCH;}
		  if ((m/\s*(\d+) perc/)        && (! defined $minutes))
		  { $minutes = $1; last SWITCH;}
		  if ((m/\s*([12][0-9]{3})/)    && (! defined $year))
		  { $year = $1; last SWITCH;}
		  { ; } # default -> category, was processed over 
	      }

		t "found episode: '$episode'" if defined $episode;
		t "found minutes: '$minutes'" if defined $minutes;
		t "found year: '$year'"       if defined $year;
	    } # section 0
	    if ($section == 1) {
		# 
		# is there a "hu-job:" string in the part? if yes, we should
		# push the last readed person, and clear the person string.
		# if a job is defined (hu-job) but not supported in the DTD we
		# will add # the person(s) as:
		#  <actor> some_not_defined_job: Foo Bar, Dummy Name ...<actor>
		# note: \b(.+): do not match to " író: ",
		# because í is not part of \b

		if (($_) = $part =~ /^\s*(\S+):/) {
		    $part =~ s/^\s*(\S+):\s*//;      # remove the "jobname:"
		    t "is this a known job?: '$_'";  # string e.g.: hu-job
		      
		    if (defined($jobmap{$_})) {
			t "yes, this string is a jobname";
			# this means, we should add our until
			# now collected person to the credits,
			# and begin to collect new actors...

			add_person($job, $person, \%credits);
			
			if (length($jobmap{$_})) {
			    # newly readed part has a en-job (this
			    # is defined in DTD, so this will be the next
			    # used job for XML generation
			    
			    t "job known in DTD as: $jobmap{$_}";
			    $job = $_;
			    $person = $part;
			} #en-job
			else {
			    # this job is not known in DTD, so only en-job,
			    # no hu-job; add as descriped above, set job to
			    # foobar to add as actor
			    $job = "foobar";
			    $person = "$_: $part ";
			} #hu-job
			next;
		    } #hu-job
		} #: in the part
		
		# we are here, if:
		# -> $part holds ':' but it is no hu-job (no en-job)
		# -> it have no :

		if ($part =~ /^\(.*\)$/) {
		    t "found () expression, addint it to person string";
		    # if it has the from '(...)' the found HTML was:
		    # actor: Arnold Schweizenegger (as the Terminator)
		    # add this to persons and do not push, it. 
		    $person .= " $part";
		}
		else {
		    # this is a new name, check how looks person, if it ends
		    # with ":" do not add this to credits, only append, because
		    # in the previuos iteration only hu-job was found.
		    if ($person =~ /:\s*$/) {
			$person .= " $part";
		    }
		    else {
			add_person($job, $person, \%credits);
			$person = $part;
		    }
		}
	    } #section 1
	} #loop over parts
    } #loop over $lines
    
    # add the last processed data to credits...
    add_person($job, $person, \%credits) if length($person);
    
    t "CREDITS: " . d \%credits;

    #$prog->{q(category)} = [[ $category, $country ]]
    #if defined $category and length $category;

    $prog->{q(length)} = $minutes * 60
      if defined $minutes;

    $prog->{q(date)} = $year
      if defined $year ;

    if(defined($episode)) {
	if($episode =~ m!(\d+)/(\d+)!) {
	    # episode-num spec with the total number specified.
	    # however XMLTV counts from 0 on ...
	    $prog->{q(episode-num)} = [[ sprintf("%d/%d", $1 - 1, $2),
					 "xmltv-ns" ]];
	}
	else {
	    $prog->{q(episode-num)} = [[ $episode, "onscreen" ]];
	}
    }

    $prog->{q(credits)} = \%credits;
    $tree->delete;
}

# Bump a YYYYMMDD date by one.
sub nextday( $ ) {
    my $d = shift;
    my $p = parse_date($d);
    my $n = DateCalc($p, "+ $daysperpage day");
    return UnixDate($n, '%Q');
}

# icons:        returns channel-logo url (http://...)
# local-icons:  returns channel-logo url (file:///...) and
#               if --no-fetch-icons was not specified: 
#               download the image into the spec. direcotry
#
# parameter:    $1: channel id
sub grab_icon( $$ ) {
    # if icon not requested
    return unless ($opt_icons || $opt_local_icons);

    my $country = shift;
    my $channelid = shift;
    my $fetchurl  = "http://www.${country}/tv/kep_ado/al_${channelid}.gif";
    my ($file, $iconurl);

    return $fetchurl if ($opt_icons && ! $opt_local_icons);

    # remove multiple /;  make absoluth path 
    $_ = "${opt_local_icons}/${channelid}.gif";
    s!//!/!g;
    $file = Cwd::abs_path( $_ );
    
    $iconurl   = "file://${file}";

    return $iconurl  if ($opt_local_icons && $opt_no_fetch_icons);

    # create directory
    mkdir $opt_local_icons unless (-d $opt_local_icons);
    if (! -d $opt_local_icons) {
	warn "directory not exists, and cannot create: $opt_local_icons; " .
	    "icon will be not grabbed";
	return $fetchurl;
    }

    if (open(FILE,">$file")) {
	if (my $image = get_nice($fetchurl)) {
	    t "icon grabbed successfully";
	    print FILE $image;
	    close FILE;
	    # success
	    return $iconurl;
	}
	else {
	    warn "cannot create icon file ($file), using remote URL instead";
	    close FILE;
	    unlink $file;
	    return $fetchurl;
	}
    }
    return;
}
