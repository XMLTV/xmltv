#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_grab_uk - Grab TV listings for the United Kingdom.

=head1 SYNOPSIS

tv_grab_uk --help

tv_grab_uk [--config-file FILE] --configure

tv_grab_uk [--config-file FILE] [--output FILE] [--days N]
           [--offset N] [--quiet]

=head1 DESCRIPTION

Output TV and radio listings in XMLTV format for many stations
available in Britain.  The data comes from the Ananova website (and is
subject to their terms and conditions).

First you must run B<tv_grab_uk --configure> to choose which stations
you want to receive.  Choose a terrestrial analogue TV region, and
optionally some digital or satellite channels plus radio.  To help you
choose digital channels some 'packages' of channels are defined.

Then running B<tv_grab_uk> with no arguments will get a weekE<39>s
listings for the stations you chose.

B<--configure> Prompt for which stations to download and write the
configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_uk>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> When grabbing, write output to FILE rather than
standard output.

B<--days N> When grabbing, grab N days rather than as many as
possible.

B<--offset N> Start grabbing at today + N days.  N may be negative.

B<--quiet> suppress the progress messages normally written to standard
error.

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.ananova.com/tv/>,
L<http://www.ananova.com/about/terms.html>

=head1 AUTHOR

Ed Avis, ed@membled.com

=head1 BUGS

Currently there is no means to edit a previous configuration, you have
to reconfigure from scratch.  There is also no system to prompt the
user about new channels that have appeared on the Ananova site.

=cut

use strict;
use LWP::Simple;
use Getopt::Long;
use Date::Manip;
use IO::File;
use Tie::RefHash;
use Data::Dumper;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

# Use Term::ProgressBar if installed.
my $have_bar;
BEGIN {
    eval { require Term::ProgressBar };
    $have_bar = not $@;
}

use XMLTV;
# We modify the XMLTV module's tables to add a <distribution> element
# to <channel>s.  We assume each channel has exactly one distribution
# method.  This list is to replace @XMLTV::Channel_Handlers where
# support for the extra element is needed.
#
my @new_channel_handlers
  = (@XMLTV::Channel_Handlers,
     [ 'distribution', 'scalar', '1' ],
    );

use XMLTV::TZ qw(gettz);
use XMLTV::UK_TZ;
use XMLTV::Ananova_Channel;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Usage <<END
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N] [--offset N]
END
  ;

# Prototype declarations
sub get_copyright( $$ );
sub get_regions( $$ );
sub read_channels_page( $$ );
sub fix_times( $ );
#sub fix_dates( $ );
sub fix_zero_length( $ );
sub extract_variant( $$ );
sub get_channel_pkgs();
sub init_channels();
sub get_pages( $$ );
sub configure();
sub grab( @ );
sub fix_ananova_xml( $ );

# Check options.  First do the undocumented --cache option (to cache
# get(), which retrieves web pages), then the normal ones.
#
my $using_cache = XMLTV::Memoize::check_argv('get');
my ($opt_days,
    $opt_help,
    $opt_output,
    $opt_share,
    $opt_configure,
    $opt_config_file,
    $opt_offset,
    $opt_quiet,
   );
$opt_days   = 7; # default
$opt_quiet  = 0; # default
$opt_offset = 0; # default today
GetOptions('days=i'        => \$opt_days,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'share=s'       => \$opt_share, # also undocumented
           'offset=i'      => \$opt_offset,
	   'quiet'         => \$opt_quiet,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
if ($opt_help) {
    usage(1);
}
if ($opt_configure) {
    print STDERR "Going to configure channels to download, please wait\n";
}
$have_bar = 0 if $opt_quiet;

# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_uk.PL.  But we can use the
# current directory instead of share/tv_grab_uk for development.
#
# The 'source' file tv_grab_uk.in has $SHARE_DIR undef, which means
# use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_uk" : '.';
(my $CHANNEL_NAMES_FILE = "$OUR_SHARE_DIR/channel_ids") =~ tr!/!/!s;

# PHP page provided by Ananova to access their internal listings data.
# This is used as an inital substring of all the URLs gotten by this
# program.
#
my $BASE_URL = 'http://www.ananova.com/tv_listings/_xmltv.php';

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/tv_grab_uk";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = 'tv_grab_uk';
    }
}

if ($opt_configure) {
    if (-e $CONFIG_FILE) {
	print <<END
The configuration file $CONFIG_FILE already exists.  There is
currently no support for altering an existing configuration, you have
to reconfigure from scratch.

END
  ;
	if (not askBooleanQuestion
	    ('Do you wish to overwrite the old configuration?', 0)) {
	    print "Exiting.\n";
	    exit 0;
	}
    }
}
else {
    if (-e $CONFIG_FILE) {
	print STDERR "using config file $CONFIG_FILE\n"
	  unless $opt_quiet;
    }
    else {
	die "config file $CONFIG_FILE does not exist, run me with --configure\n";
    }
}

# On Windows Date::Manip can have trouble finding the local timezone.
# Since the output listings shouldn't depend on the local timezone
# anyway, we just set it here.
#
Date_Init('TZ=UTC');

# Things will go horribly wrong if Ananova change pages from one day
# to the next while the script is running.  Assume they do it at
# midnight.
#
use vars '$today';
BEGIN { $today = ParseDate('today'); die if not defined $today; }
END {
    if (UnixDate(ParseDate('today'), '%Q') ne UnixDate($today, '%Q')) {
	warn "current day has changed, results may be messed up\n";
    }
}

# Convert an internal (Date::Manip) date to output format.
sub ud {
    my ($internal, $tz) = @{date_to_uk($_[0])};
    return UnixDate($internal, '%q') . ' ' . $tz;
}

# Memoize some date parsing routines, if possible.  FIXME move to
# XMLTV::Memoize.
#
eval { require Memoize };
unless ($@) {
    foreach (qw(parse_uk_date ParseDate UnixDate DateCalc Date_Cmp
		ParseDateDelta ud)) {
	Memoize::memoize($_) or warn "cannot memoize $_";
    }
}

# Download the two index pages now.
my $index_pages = get_pages('getting list of channels', [ qw(regions allchannels) ]);

# Set up the global channels and regions data.  This is needed for
# both configuration and grabbing.
#
init_channels();
read_channels_page($index_pages->{allchannels}->{content},
		   $index_pages->{allchannels}->{url});

# Then regions uses information already gathered about channels.
my $regions = get_regions($index_pages->{regions}->{content},
			  $index_pages->{regions}->{url});
my %region_display = reverse %$regions;
#$Log::TraceMessages::On = 1;
t 'regions: ' . d $regions;
foreach my $r (keys %$regions) {
    t "region $r:";
    foreach (grep { $_->is_region($r) } XMLTV::Ananova_Channel->all()) {
	t "...contains channel " . $_->stringify();
    }
}

# Predefined channel packages for ease of configuration.
my %channel_pkgs = get_channel_pkgs();

if ($opt_configure) {
    configure();
}
else {
    my %g_args = ();
    if (defined $opt_output) {
	my $fh = new IO::File ">$opt_output";
	die "cannot write to $opt_output\n" if not $fh;
	%g_args = (OUTPUT => $fh);
    }
    grab(%g_args);
}


# Ask the user which channels to download, and write $CONFIG_FILE.
sub configure() {
#    local $Log::TraceMessages::On = 1;
    # FIXME need to make directory
    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    my %chose_ch;

    # Need to ask:
    #
    # - Do you get terrestrial TV and if so what region?
    # - Do you have satellite?
    # - Do you have radio?  (incl. with Sky Digital)
    # - If satellite, prompt for channel packages.
    #
    my $terr = askBooleanQuestion
      ('Do you get terrestrial analogue television?', 1);
    if ($terr) {
	my @region_dns = sort keys %region_display;
	die if not @region_dns;
	t '\%region_display: ' . d \%region_display;
	t 'region display names: ' . d \@region_dns;
	my $default_region = 'Carlton';
	if (not defined $region_display{$default_region}) {
	    warn "default region '$default_region' seems to have disappeared\n";
	    $default_region = $region_dns[0];
	}

	# FIXME commonize showing one name to the user and another
	# internally.
	#
	my $region_dn = askQuestion
	  ('Which terrestrial region?', $default_region, @region_dns);
	my $aid;
	foreach (@region_dns) {
	    if ($_ eq $region_dn) {
		$aid = $region_display{$_};
		last;
	    }
	}
	die if not defined $aid;
	print CONF "region $aid\t# $region_dn\n";
    }

    my $dig = askBooleanQuestion
      ('Do you get digital or satellite television?', 0);
    if ($dig) {
	print <<END
You now need to select which digital channels to download.
First choose some predefined packages of channels.
END
  ;
	my $finished_option = 'Finished choosing packages';
	die "can't have package named '$finished_option'!"
	  if defined $channel_pkgs{$finished_option};
	my %to_choose = %channel_pkgs;
	while (%to_choose) {
	    my @k = sort keys %to_choose;
	    my $default = $k[0];
	    my $chosen = askQuestion('Package to add: ',
				     $default, @k, $finished_option);
	    last if $chosen eq $finished_option;

	    # Now prompt about individual channels in this package.
 	    use vars '@ch_in_pkg';
	    local *ch_in_pkg = delete $to_choose{$chosen};
	    my @r = askManyBooleanQuestions
	      (1, map { "Add channel $_?" } @ch_in_pkg);
	    die if @r != @ch_in_pkg;
	    foreach (@ch_in_pkg) {
		if (shift @r) {
		    unless ($chose_ch{$_}++) {
			print CONF "channel $_\t# from package $chosen\n";
		    }
		}
	    }
	}
    }

    my @radio_chs = grep { my $t = $_->get_type(); defined $t and $t eq 'radio' }
      XMLTV::Ananova_Channel->all();

    if (@radio_chs == 0) {
	print "Hmm, there don't seem to be any radio channels available.\n";
    }
    elsif (@radio_chs < 10) {
	if (askBooleanQuestion('Download radio listings?', 1)) {
	    print CONF "type radio\n";
	}
    }
    else {
	print 'There are ', (scalar @radio_chs),
	  " radio channels, please select those you want individually\n";
    }

    print "Any other channels?\n";
    for (;;) {
	print "Enter the name of a channel, or '.' to finish: ";
	my $in = <STDIN>;
	if (not defined $in) {
	    die "strange, failed to read stdin but not EOF"
	      if not eof STDIN;

	    warn "got EOF, stoppping configuration\n";
	    last;
	}
	$in =~ s/^\s+//; $in =~ s/\s+$//;
	last if $in eq '.';
	my @poss;
	foreach (XMLTV::Ananova_Channel->all()) {
	    push @poss, $_ if $_->get_a_display_name() =~ /\Q$in\E/i;
	}
	if (@poss == 0) {
	    print "No channel matching that.\n";
	}
	elsif (@poss == 1) {
	    my $ch = $poss[0];
	    if (askBooleanQuestion('Add channel ' .
				   $ch->get_a_display_name() . '?', 1)) {
		my $xmltv_id = $ch->get_xmltv_id();
		unless ($chose_ch{$xmltv_id}++) {
		    print CONF "channel $xmltv_id\n";
		}
	    }
	}
	elsif (1 <= @poss and @poss < 25) {
	    my %dn_to_ch;
	    foreach (@poss) {
		my $dn = $_->get_a_display_name();
		warn "more than one channel called $dn"
		  if exists $dn_to_ch{$dn};
		$dn_to_ch{$dn} = $_;
	    }
	    my $none_option = 'None of the above are what I wanted';
	    die 'silly channel name' if exists $dn_to_ch{$none_option};
	    my $r = askQuestion('Which channel to add?',
				$poss[0]->get_a_display_name(),
				(sort keys %dn_to_ch), $none_option);
	    next if $r eq $none_option;
	    my $ch = $dn_to_ch{$r}; die if not defined $ch;
	    my $xmltv_id = $ch->get_xmltv_id();
	    unless ($chose_ch{$xmltv_id}++) {
		print CONF "channel $xmltv_id\n";
	    }
	}
	elsif (25 <= @poss) {
	    print "'$in' matches lots of channels, be more specific.\n";
	}
	else { die }
    }

    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab a week's listings.\n";
    exit();
}

# Grab listings and write them in XML.  Arguments are to be passed to
# XMLTV::Writer.
#
sub grab( @ ) {
    my $copyright = get_copyright($index_pages->{regions}->{content},
				  $index_pages->{regions}->{url});

    # The copyright message is in whatever encoding the XML web pages
    # use.  Assume that this is a superset of ASCII, and that our
    # output encoding is too; then we just strip non-ASCII characters.
    #
    for ($copyright) {
	# Try to preserve at least the magic word or magic symbol.
	s/©/copyright/g if not /copyright/i;
	s/©/(C)/g;
	tr/\200-\377//d;
    }

    # Hopefully nobody will confuse this copyright message for the
    # listings with the copyright in this program.
    #
    print STDERR "\n$copyright\n" unless $opt_quiet;

    # Now read the config file to find which files to download.  The
    # user can choose channels by type (radio or satellite), region,
    # XMLTV id, or 'ALL'.  But only some of these can be chosen with
    # --configure.  The choices 'satellite' and 'ALL' are not normally
    # user-visible, they'd be a huge set of channels.
    #
    my %wanted; tie %wanted, 'Tie::RefHash';
    open(CONF, $CONFIG_FILE)
      or die "cannot read $CONFIG_FILE: $!\n";
    my @all_chs = XMLTV::Ananova_Channel->all();
    while (<CONF>) {
	s/\#.*//; s/^\s+//; s/\s+$//;
	next if not length;
	t "got line from config file: $_";
	if ($_ eq 'ALL') {
	    foreach (@all_chs) {
		$wanted{$_} = 1;
	    }
	}
	elsif (/^type\s+(radio|satellite)$/) {
	    my $type = $1;
	    foreach (@all_chs) {
		my $got_type = $_->get_type();
		if (not defined $got_type) {
#		    warn 'channel with no type, not getting: ' . $_->stringify();
		    next;
		}
		$wanted{$_} = 1 if $got_type eq $type;
	    }
	}
	elsif (/^region\s+(.+)/) {
	    my $region = $1;

	    # For backward compatibility turn old-style Ananova
	    # regions like 'ne_11' into just numbers like '11'.
	    #
	    if ($region =~ /^[a-z]+_(\d+)$/) {
		$region = $1;
	    }
	    die "$CONFIG_FILE:$.:bad region specification $region"
	      if $region =~ tr/0-9//c;

	    t "want region $region, marking channels";
	    foreach (@all_chs) {
		if ($_->is_region($region)) {
		    t 'marking channel ' . $_->stringify();
		    $wanted{$_} = 1;
		}
	    }
	}
	# No way to ask for channel packages directly, they are used
	# only by --configure.  So far.
	elsif (/^channel\s+(.+)/) {
	    my $xmltv_id = $1;
	    my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($xmltv_id);
	    if (not defined $ch) {
		warn "$CONFIG_FILE:$.: no channel with XMLTV id $xmltv_id, skipping\n";
		next;
	    }
	    $wanted{$ch} = 1;
	}
	else { die "$CONFIG_FILE:$.: bad line\n" }
    }

    # Check that every channel is associated with some package (so it
    # could be chosen) or has actually been chosen.
    #
#    local $Log::TraceMessages::On = 1;
    my %in_some_pkg;
    foreach my $pkg (keys %channel_pkgs) {
	t 'setting %in_some_pkg entries for package: ' . d $pkg;
	$in_some_pkg{$_} = 1 foreach @{$channel_pkgs{$pkg}};
    }
    t '\%in_some_pkg=' . d \%in_some_pkg;
    CH: foreach (@all_chs) {
	my $xid = $_->get_xmltv_id();
	next if $in_some_pkg{$xid};

	# It's not in any channel package, but is it in a region?
	foreach my $rid (keys %$regions) {
	    next CH if $_->is_region($rid);
	}

	# For now, we won't warn about radio channels.  FIXME we
	# should eventually handle these like TV ones, but maybe
	# shoving localradio off into their own bit.
	#
	my $type = $_->get_type();
	next if defined $type and $type eq 'radio';

	my $aid = $_->get_first_ananova_id();
	my $dn = $_->get_a_display_name();
	warn "no channel package or region includes $dn ($xid, $aid)\n";
    }

    # We want to get them in day order, so that we can get the first day's
    # listings first.  This is becuase we need to get a complete day to
    # get the complete channel information, which must be written out
    # before any programmes.
    #
    # We download all the files at once, then process them one by one.
    #
    my @to_get;
    if (keys %wanted) {
	my @chs = sort { $a <=> $b }
	  map { $_->get_first_ananova_id() }
	    keys %wanted;
	die if not @chs;
	unless ($opt_quiet) {
	    print STDERR 'grabbing ' . (scalar @chs) . ' channels from '
	      . (scalar @all_chs) . " available\n";
	}
	foreach my $day (($opt_offset + 1) .. ($opt_offset + $opt_days)) {
	    my $CHS_PER_REQ = 10;
	    for (my $i = 0; $i < @chs; $i += $CHS_PER_REQ) {
		my $end = $i + $CHS_PER_REQ;
		$end = @chs if $end > @chs;
		push @to_get, "$BASE_URL?day=day$day&c="
		  . join('.', @chs[$i .. $end-1]);
	    }
	}
    }
    else {
	warn "apparently nothing to download\n";
    }

    my $bar = new Term::ProgressBar('downloading listings', scalar @to_get)
      if $have_bar;
    my @to_parse;
    foreach (@to_get) {
	t "downloading page: $_";
	my $got = get($_);
	if (not defined $got) {
	    warn "failed to get $_, skipping page\n";
	}
	elsif (not fix_ananova_xml(\$got)) {
	    warn "$_: bad content, skipping page\n";
	}
	else {
	    push @to_parse, [ $got, $_ ];
	}
	update $bar if $have_bar;
    }

    $bar = new Term::ProgressBar('parsing', scalar @to_parse)
      if $have_bar;

    my @listingses;
    foreach (@to_parse) {
	my ($xml, $url) = @$_;
	t "parsing content of $url";
	my $r;
	{
	    local $Log::TraceMessages::On = 0;
	    local $SIG{__WARN__} = sub {
		my $msg = shift;
 		$msg = "warning: something's wrong" if not defined $msg;
		print STDERR "$url: $msg\n";
	    };
	    eval {
		local @XMLTV::Channel_Handlers = @new_channel_handlers;
		$r = XMLTV::parse($xml);
	    };
	    die "$url: $@" if $@;
	}
	push @listingses, $r;
	update $bar if $have_bar;
    }

    # Join together all the listings files: but for scalability we
    # don't join the programmes.  (Putting them all into a big list in
    # channel order gave very poor locality of memory use, so
    # thrashing.)
    #
    my $catted = XMLTV::cat_noprogrammes(@listingses);
    my $w = new XMLTV::Writer(@_, encoding => $catted->[0]);
    $w->start($catted->[1]);
    $w->comment($copyright);
    use vars '%ch'; local *ch = $catted->[2];

    # Convert Ananova channel ids to XMLTV ids.  Ananova serves the pages
    # with its own internal numeric ids.
    #
    foreach (keys %ch) {
	die if not defined;
	my $xid = XMLTV::Ananova_Channel->ananova_id_to_xmltv_id($_);
	if (not defined $xid) {
	    # Shouldn't happen as we read the allchannels page before.
 	    warn "in channels, cannot convert Ananova id $_->{channel} to XMLTV id";
	}
	else {
	    warn "channel with XMLTV id $xid seen twice"
	      if defined $ch{$xid};
	    ($ch{$xid} = delete $ch{$_})->{id} = $xid;
	}
    }
    add_display_names(\%ch);
    $w->write_channels(\%ch);

    foreach (@listingses) {
	foreach (@{$_->[3]}) {
	    my $xid = XMLTV::Ananova_Channel->ananova_id_to_xmltv_id($_->{channel});
	    if (not defined $xid) {
		warn "in programme, cannot convert Ananova id $_->{channel} to XMLTV id";
	    }
	    else {
		$_->{channel} = $xid;
	    }
	}
    }

    my %by_ch;
    foreach (@listingses) {
	foreach (@{$_->[3]}) {
	    push @{$by_ch{$_->{channel}}}, $_;
	}
    }
    t '\%by_ch: ' . d \%by_ch;
    $bar = new Term::ProgressBar('miscellaneous fixes', scalar keys %by_ch)
      if $have_bar;
    foreach (keys %by_ch) {
	t "doing channel $_";
	my $progs = $by_ch{$_};
	t 'progs are: ' . d $progs;
	foreach (@$progs) { die if not defined }

	# Get rid of Ananova's bizarre system for follow-on
	# programmes.  The XMLTV way of dealing with them is not ideal
	# either, but it's the standard right now.
	#
	fix_times($progs);
	foreach (@$progs) { die if not defined }

	# Remove the occasional zero-length programmes which pop up.  NB
	# we rely here on the ordering which Ananova generates within each
	# channel.
	#
	fix_zero_length($progs);

	update $bar if $have_bar;
    }

    foreach (@listingses) {
	foreach (@{$_->[3]}) {
	    $w->write_programme($_);
	}
    }
    $w->end();
}


# Add extra display names to channels, based on the display names
# stored in Ananova_Channel objects.
#
# Parameter: reference to list of channels, with proper XMLTV ids.
#
# Modifies the data passed in.
#
sub add_display_names( $ ) {
    my $ch = shift;
  CH: foreach (keys %$ch) {
	my $ch_obj = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	if (not defined $ch_obj) {
	    # Shouldn't happen.
	    warn "no object for XMLTV id $_";
	}
	else {
	    # Discard the existing display name data and replace it
	    # with the list from the object.  Urgh, this is horrible.
	    #
	    my @new = ();
	    foreach ($ch_obj->get_display_names()) {
		if (not defined) {
		    warn "got undef display name from get_display_names()";
		    next CH; # leave this one alone
		}
		if (not tr/0-9//c) {
		    # Only numbers, this name is language independent.
		    push @new, [ $_ ];
		}
		else {
		    # Assume the channel_ids file is in English.
		    push @new, [ $_, 'en' ];
		}
	    }
	    $ch->{$_}->{'display-name'} = \@new;
	}
    }
}


# Extract the copyright message from the comment at the start of every
# page served.  Takes page content, returns the copyright message.
#
# Parameters:
#   content
#   URL (for error messages)
#
sub get_copyright( $$ ) {
    my ($content, $url) = @_;
    my $r;
    my @lines = split /\n/, $content;
    my $msg;
    while (@lines) {
	local $_ = shift @lines;
	if (s/^(\W*)Copyright\b/Copyright/) {
	    my $prefix = $1;
	    $msg .= "$_\n";
	    # Find following lines with the same prefix.
	    while (@lines) {
		local $_ = shift @lines;
		s/^\Q$prefix\E// or last;
		$msg .= "$_\n";
	    }
	    return $msg;
	}
    }
    warn "no copyright message found in $url\n";
}


# Reads the Ananova 'regions' page and sets up channel objects.  Also
# returns a hashref mapping region ids to region names.
#
# Parameters:
#   contents of Ananova 'regions' page
#   URL of that page (for error reporting)
#
sub get_regions( $$ ) {
    my ($xml, $url) = @_;
    my %r;

    # Call some internal routines of the XMLTV module to parse this
    # XML, which is similar to XMLTV's channel listings but not quite
    # the same.
    #
    # (Ignore attributes of the <tv> element.)
    #
    local @XMLTV::Channel_Handlers = @new_channel_handlers;
    t 'set \@XMLTV::Channel_Handlers to' . d \@XMLTV::Channel_Handlers;
    my $t = new XML::Twig
      (TwigHandlers =>
       { '/tv/region' => sub { do_region($url, \%r, @_) } });
    $t->parse($xml);

    # We just told some existing channel objects about their
    # terrestrial regions.  That is the main purpose of this
    # subroutine.  But we also return a hash mapping region ids to
    # region names.
    #
    return \%r;
}
# Helper for get_regions().  First two args are URL and hash to modify,
# next two are those passed by XML::Twig.
#
sub do_region( $$$$ ) {
    my ($url, $r, $t, $node) = @_;
    # Get the Ananova region id.
    use vars '%reg_attrs'; local *reg_attrs = XMLTV::get_attrs($node);
    delete $reg_attrs{tag};	# old-style id, not used.
    my $reg_id = delete $reg_attrs{id};
    if (not defined $reg_id) {
	warn "$url: region with no id, skipping";
	next;
    }
    foreach (keys %reg_attrs) {
	warn "$url: unknown attribute $_ in region";
    }

    # Store the region id and name.
    my $fc = $node->first_child();
    my $reg_name = $fc->pcdata();
    if (not defined $reg_name) {
	warn 'first child of region should be region name';
	next;
    }
    $fc->delete();
    for ($reg_name) { s/^\s+//; s/\s+$// }
    $r->{$reg_id} = $reg_name;

    # Inside a <region> element are some <channel> elements.
    t 'parsing <channel>s inside <region>';
    foreach (XMLTV::get_subelements($node)) {
	if (XMLTV::get_name($_) ne 'channel') {
	    warn "$url: something other than channel inside region";
	    next;
	}
	t 'calling XMLTV::node_to_channel()';
	my $ch_data = XMLTV::node_to_channel($_);
	my @chs = XMLTV::Ananova_Channel->find_by_ananova_id($ch_data->{id});
	if (not @chs) {
	    warn "$url: channel $ch_data->{id} mentioned in regions but not channels";
	    next;
	}
		
	# Tell each channel with this Ananova id that it belongs to
	# this region.
	#
	$_->add_region($reg_id) foreach @chs;
    }
}


# Read Ananova's 'allchannels' page.  This tells us about radio and
# satellite channels.
#
# Parameters:
#   contents of allchannels page
#   URL (for error reporting)
#
sub read_channels_page( $$ ) {
    my ($xml, $url) = @_;
#    local $Log::TraceMessages::On = 1;
    my $data;

    if (not defined $xml) {
	die "failed to get channels page $url\n";
    }
    fix_ananova_xml(\$xml) or die "$url: bad channels page content";

    t 'parsing XML for channels page: ' . d $xml;
    {
	eval {
	    local @XMLTV::Channel_Handlers = @new_channel_handlers;
	    t 'set \@XMLTV::Channel_Handlers to: ' . d \@XMLTV::Channel_Handlers;
	    $data = XMLTV::parse($xml);
	};
	die "$url: $@" if $@;
    }
    my ($encoding, $credits, $channels, $progs) = @$data;
    t '$encoding=' . d $encoding;
    t '$credits=' . d $credits;
    t '$channels=' . d $channels;
    t '$progs=' . d $progs;
    # Assume that the encoding is a superset of ASCII (we know that
    # only ASCII characters are interesting to us for parsing).
    #

    # FIXME ignoring the credits
    die if @$progs;

    # FIXME perhaps a cleaner way of doing this than parsing then
    # writing out again?
    #
    my (%type, %display);
    foreach my $id (keys %$channels) {
	my $c = $channels->{$id};
	die "undef \$channels->{$id}" if not defined $c;
	die "\$channels->{$id} not hash: $c" if ref $c ne 'HASH';
	die "\$channels->{$id} has no 'id' key" if not defined $c->{id};

	# FIXME handle multiple display names; keep lang attribute
	for ($c->{'display-name'}) {
	    if (not defined or @$_ == 0) {
		warn "no display names for channel $c->{id}, skipping";
		next;
	    }
	    elsif (@$_ == 1) {
		# Okay.
	    }
	    elsif (@$_ >= 2) {
		warn "skipping additional display names for $_->[0]->[0]";
	    }
	    else {
		die;
	    }
	}
	
	my ($type, $aid, $display) = ($c->{distribution}, $c->{id}, $c->{'display-name'}->[0]->[0]);
	die if ref $type;
	die if $id ne $aid;
	t "got line with type $type, aid $aid, dn $display";
	my @chs = XMLTV::Ananova_Channel->find_by_ananova_id($aid);
	t 'maybe looked up by aid: ' . d \@chs;
	if (not @chs) {
	    t 'not found, create new channel object';
	    my $ch = new XMLTV::Ananova_Channel();
	    $ch->add_ananova_id($aid);
	    @chs = ($ch);
	}
	
	foreach my $ch (@chs) {
	    # Only set the display name based on the first (ie,
	    # best) Ananova id for this channel.  Otherwise we'd
	    # have a conflict between say 'Border' and 'Border
	    # (Scottish viewers)'.  Only the first of the two should
	    # have a chance to set the display name.
	    #
	    my $first_aid = $ch->get_first_ananova_id();
	    t "first Ananova id: $first_aid";
	    if ($first_aid eq $aid) {
		t 'this Ananova channel is the first for this channel';
		$ch->set_main_display_name($display);
		t "set display name to $display";
	    }
	    # Additional display names are added from the channel_ids file
	    # but *not* from Ananova's extra names.
	    #
	    # No warning for duplicate display names, that often happens.
	    #

	    # Guess an XMLTV id if it wasn't set before.  This would go
	    # wrong if two channels had the same Ananova id, but that can
	    # only happen if it's specified in the channel_ids file -
	    # which also defines the XMLTV ids.
	    #
	    if (not defined $ch->get_xmltv_id()) {
#		warn "no XMLTV id in channel_ids file for Ananova id $aid\n";
		$ch->set_xmltv_id("$aid.tv-listings.ananova.com");
	    }

	    if ($type eq 'terrestrial') {
		$ch->set_type('terrestrial');
	    }
	    elsif ($type eq 'digital') {
		# FIXME losing distinction between ITV Digital and Sky
		$ch->set_type('satellite');
	    }
	    elsif ($type eq 'satellite') {
		$ch->set_type('satellite');
	    }
	    elsif ($type eq 'localradio') {
		# FIXME losing distinction between local and national radio
		$ch->set_type('radio');
	    }
	    elsif ($type eq 'radio') {
		$ch->set_type('radio');
	    }
	    elsif ($type eq 'unknown') {
		$ch->set_type('duff');
	    }
	    else {
		warn "$url: unknown <distribution>: $type";
		$ch->set_type('duff');
	    }
	}
    }
}


# extract_variant()
#
# Some channels are really two channels in one, for example Radio 4 FM
# and Radio 4 LW.  Programmes on the channel have titles prefixed with
# '(FM)', etc.  This routine filters out all programmes for a
# particular 'variant'.
#
# Parameters:
#   Reference to list of programmes (all on same channel)
#   Transmission method (variant) to look for, eg 'FM'.
#
# Side effects: programmes in the list which are not from this variant
# will be deleted.
#
# BTW: this supersedes the old special_radio4() handler in
# tv_extractinfo_en.  It seems more appropriate to handle it here
# since it is a pecularity of British listings and not English
# TV/radio listings in general.
#
sub extract_variant( $$ ) {
    use vars '@progs'; local *progs = shift;
    my $tr = shift;

    my @progs_new;
    foreach (@progs) {
	my $titles = $_->{title}; die if not defined $titles;

	# Find whether one (and only one) transmission method is mentioned.
	my $tr_this;

	foreach (@$titles) {
	    for my $text ($_->[0]) {
		t "trying to match text $text for (Something) at start...";
		if ($text =~ s/^\s*\(([A-Z]+)\)\s*//) {
		    t 'matches';
		    if (not defined $tr_this) {
			$tr_this = $1;
			t '$tr_this set to: ' . d $tr_this;
		    }
		    elsif (defined $tr_this and $tr_this eq $1) {
			# Okay, agrees with other titles.
		    }
		    elsif (defined $tr_this and $tr_this ne $1) {
			warn "titles disagree, giving both ($tr_this) and ($1)";
			# Just discard this value.
		    }
		    else { die }
		}
	    }
	}

	if (defined $tr_this) {
	    t "found a transmission method: $tr_this";
	    if ($tr_this eq $tr) {
		t 'matches, keep';
		push @progs_new, $_;
	    }
	    else {
		t "does not match $tr, discard this programme";
	    }
	}
	else {
	    t 'no transmission method given, assume programme on all variants';
	    push @progs_new, $_;
	}
    }

    @progs = @progs_new;
}
	

####
# Channels stuff
#

# In principle it should be possible to find all channel data by
# looking at the Ananova site.  However they don't use the RFC2838
# style names, and I also want to add some extra display names for
# channel numbers.  So there's a hardcoded table listing XMLTV channel
# ids, their equivalent on the Ananova site, and optionally an extra
# (short) display name for that channel.
#
# It can be hard to decide whether two related channels should map to
# the same internal name - eg digital and analogue versions of the
# same channel.  I have made different internal names if I know that
# the content will be different (eg BBC1 digital is different to any
# of the analogue region versions), but otherwise mapped both channels
# to the same internal name.  Sometimes there are annoying small
# differences which require differing internal names, else
# tv_sort complains.  The same applies to regional variants for
# channels which don't differ between regions (eg Channel 5).
#
# Piping the output through tv_sort will check that the two
# versions of a channel are indeed identical.
#
sub init_channels() {
#    local $Log::TraceMessages::On = 1;
    # See the distributed version of this file for info about the
    # format.
    #
    local *FH;
    open (FH, "<$CHANNEL_NAMES_FILE")
      or die "cannot open $CHANNEL_NAMES_FILE: $!";
    while (<FH>) {
	s/^\s+//; s/\s+$//; s/\#.*//;
	next unless length;
	my @fields = split /:/;
	die "$CHANNEL_NAMES_FILE:$.: wrong number of fields"
	  if @fields < 2 or @fields > 3;

	my ($xmltv_id, $ananova_ids, $extra_dn) = @fields;
	my @aids = split /,/, $ananova_ids;
	die "$CHANNEL_NAMES_FILE:$.: no Ananova ids"
	  if not @aids;

	# Look for the notation X/V for a 'transmission variant' of an
	# Ananova channel, for example radio4/FM is Ananova channel
	# radio4, programmes listed as '(FM)' or without transmission
	# details.
	#
	# We do not support multiple Ananova channels here: just one
	# 'variant' per channel object.  It ought to be done properly,
	# with each variant associated with an Ananova id, but it
	# isn't.
	#
	my $variant;
	foreach (@aids) {
	    if (s!/(.+)$!!) {
		$variant = $1;
		warn "multiple Ananova ids not supported when one has variant"
		  if @aids > 1;
	    }
	}

	t "initializing channel with id $xmltv_id";
	my $ch = new XMLTV::Ananova_Channel();
	$ch->set_xmltv_id($xmltv_id);
	foreach (@aids) {
	    t "adding Ananova id $_";
	    $ch->add_ananova_id($_);
	}
	if (defined $variant) {
	    t "setting variant $variant";
	    $ch->set_variant($variant);
	}
	t 'maybe adding extra display name: ' . d $extra_dn;
	$ch->add_extra_display_names($extra_dn)
	  if defined $extra_dn;
    }
    close FH or warn "cannot close $CHANNEL_NAMES_FILE: $!";
}

# Return a hash mapping package names to lists of XMLTV channel ids.
sub get_channel_pkgs() {
    # Each package is a file under channel_pkgs/ somewhere in share/.
    # The filename is the package name, and then channel ids are
    # listed one per line.
    #
    my $channel_pkgs_dir = "$OUR_SHARE_DIR/channel_pkgs";
    die "no directory $channel_pkgs_dir" if not -d $channel_pkgs_dir;
    my %pkgs;
    foreach (<$channel_pkgs_dir/*>) {
	m!^\Q$channel_pkgs_dir\E/(.+)$! or die;
	my $pkg_name = $1;
	die "package $pkg_name seen twice" if defined $pkgs{$pkg_name};
	open(PKG, "$_") or die "cannot read channel package file $_: $!";
	while (<PKG>) {
	    s/^\s+//; s/\s+$//; s/\#.*//;
	    next unless length;
	    push @{$pkgs{$pkg_name}}, $_;

	    # Check the XMLTV id is actually known.
	    my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	    if (not defined $ch) {
		warn "channel id $_ mentioned in package $pkg_name, but not known";
	    }
	}
	close PKG or die "cannot close $_: $!";
    }
    return %pkgs;
}


# get_pages()
#
# Fetch the given 'pages' from Ananova.  Attempt to combine multiple
# page fetches.
#
# Parameters:
#   text to use for progress bar
#   listref of page names to download, eg for show=regions name is 'regions'
#
# Returns: reference to hash mapping page name to a hash with 'url'
# and 'content'.  Although 'url' may be shared with other pages.
#
# Dies if a page cannot be downloaded.
#
sub get_pages( $$ ) {
#    local $Log::TraceMessages::On = 1;
    my ($text, $pages) = @_;
    my @pages = @$pages;
    foreach (@pages) { die if not defined }
    my %r;
    my $num_pages = scalar @pages;
    t "initializing progress bar with $num_pages items";
    my $bar = new Term::ProgressBar($text, $num_pages) if $have_bar;

    # FIXME currently multiple pages are not supported.
    my $max_at_once = 1;

    my @got;
    while (@pages) {
	my @this_fetch = ();
	die if $max_at_once != 1;
	while (@pages and (@this_fetch < $max_at_once)) {
	    push @this_fetch, shift @pages;
	}
	t 'this fetch: ' . d \@this_fetch;
	t 'remaining to fetch: ' . d \@pages;
	my $url = "$BASE_URL?" . join('&', map { "show[]=$_" } @this_fetch);
	t "fetching url: $url";
	foreach (@this_fetch) { $r{$_}->{url} = $url }

	my $retries = 3;
      GET:
	my $got = get $url;
	die "cannot fetch $url" if not defined $got;

	# FIXME need to split up pages, when multiple ones are
	# returned.
	#
	push @got, $got;

	if (@got != @this_fetch) {
	    warn 'expected ' . (scalar @this_fetch) .
	      " pages from URL $url, got " . (scalar @got);
	    if ($retries--) {
		warn "retrying $url\n";
		goto GET;
	    }
	    else {
		die "really cannot fetch $url, giving up\n";
	    }
	}
	update $bar if $have_bar;
	foreach (@this_fetch) {
	    die "page $_ requested twice" if defined $r{$_}->{content};
	    $r{$_}->{content} = shift @got;
	}
    }
    die if (keys %r) != $num_pages;
    return \%r;
}


# fix_times()
#
# Often there are follow-on programmes like Weather in 'News;
# Weather'.  Ananova represents these by having the followon overlap
# the last 15 seconds of the main programme.  This isn't the XMLTV
# way, which is to use clumpidx.  Neither answer is ideal but we want
# to follow the existing standard.
#
# Parameters: a reference to a list of programmes for one channel.
#   The programmes will be modified, but not the list itself.
#
sub fix_times($) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: fix_times(ref to list of programmes)' if @_ != 1;
    t('fix_times() ENTRY');
    my @progs = @{shift()}; # take a copy

    for (my $prev = shift @progs; my $p = $progs[0]; $prev = shift @progs) {
	my $start = $p->{start};
	my $stop = $p->{stop};
	my $prev_stop = $prev->{stop};
	if (defined $stop and defined $prev_stop) {
	    my $start_p = ParseDate($start); die if not defined $start_p;
	    my $stop_p = ParseDate($stop); die if not defined $stop_p;
	    my $prev_stop_p = ParseDate($prev_stop); die if not defined $prev_stop_p;
	    my $start_plus_15 = DateCalc($start_p, '+ 15 seconds');
	    die if not defined $start_plus_15;
	    if (not Date_Cmp($start_plus_15, $prev_stop_p)
		and not Date_Cmp($stop_p, $prev_stop_p)) {
		# Found the magic 15 second difference.  Fix it.
		if (defined $prev->{clumpidx} or defined $p->{clumpidx}) {
		    # I really don't expect this to happen.
		    warn 'cannot add clumpidx to programmes, already there';
		    next;
		}
		$prev->{clumpidx} = '0/2';
		$p->{clumpidx} = '1/2';
		$p->{start} = $prev->{start};
	    }
	}
    }
    t 'fix_times() EXIT';
}


# # fix_dates()
# #
# # Turn dates like 'TVM 1996' into date and category.  Takes a
# # reference to a list of programmes and modifies them.
# #
# sub fix_dates( $ ) {
#     die 'usage: fix_dates(ref to list of programmes)' if @_ != 1;
#     use vars '@progs'; local *progs = shift;
#
#     # This code is similar to special_tv_movie() in tv_extractinfo_en,
#     # but acts on the <date> field and not the programme description.
#     #
#     PROG: foreach (@progs) {
# 	if (defined $_->{date} and $_->{date} =~ s/^TVM\s*//) {
# 	    # Add the category (unless it's already there).
# 	    my $cat = 'TV movie';
# 	    if (defined $_->{category}) {
# 		foreach (@{$_->{category}}) {
# 		    next PROG if $_->[0] eq $cat;
# 		}
# 	    }
# 	    push @{$_->{category}}, [ $cat, 'en' ];
# 	}
#     }
# }


# fix_zero_length()
#
# I once saw 'News' with start time 0700 and stop time 0700, and then
# on the same channel immediately afterwards, 'News' from 0700 to
# 0705.  This subroutine looks for similar glitches and removes the
# zero-length programme.
#
# Parameter: ref to list of programmes: the programmes will not be
# modified, but the list may be.
#
sub fix_zero_length( $ ) {
#    local $Log::TraceMessages::On = 1;
    t 'fix_zero_length() ENTRY';
#    t 'progs: ' . d $_[0];
    use vars '@progs'; local *progs = shift;
    foreach (@progs) { die if not defined }

    # Consider all consecutive pairs of programmes.
    my $last = $#progs - 1;
    for (my $i = 0; $i <= $last; $i++) {
	my $first = $progs[$i];
	if (not defined $first) {
	    # But we already checked that each elem of @progs was
	    # defined!
	    #
	    warn "strange, found undef element \$progs[$i], skipping\n";
	    next;
	}

#	t 'first: ' . d $first;
	die if not defined $first->{start};
	die if not defined $first->{channel};
	die if not defined $progs[$i+1];
	die if not defined $progs[$i+1]->{start};
	die if not defined $progs[$i+1]->{channel};

	my $first_stop = $first->{stop};
	next if not defined $first_stop;
	my $first_start = $first->{start};
	next if $first_stop ne $first_start;

	# OK, the first programme is zero length.
	my $second = $progs[$i+1];
	my $second_start = $second->{start};
	next if $first_start ne $second_start;

	# A likely candidate.  Check the non-time details are identical.
	t 'suspect: ' . d $first;
	t '...and: ' . d $second;
	my $first_notimes = { %$first };
	my $second_notimes = { %$second };
	foreach ($first_notimes, $second_notimes) {
	    delete $_->{start};
	    delete $_->{stop};
	}
	t 'without times: ' . d $first_notimes;
	t '...and: ' . d $second_notimes;

	# FIXME Data::Dumper doesn't always work, as shown by tv_sort.
	if (Dumper($first_notimes) eq Dumper($second_notimes)) {
	    # The first programme is a duplicate of the second,
	    # except that it has zero length.  Remove it.
	    #
	    t 'identical, removing the first';
	    splice(@progs, $i, 1);
#	    t 'progs now: ' . d \@progs;
	    -- $i;
	    -- $last;
	}
    }
    t 'fix_zero_length() EXIT';
}


# fix_ananova_xml()
#
# The XML returned by _xmltv.php is not quite well-formed or valid or
# semantically sensible; fix what we can and check for some common errors.
# Modifies the string passed in and returns true iff it should now be
# a parsable XMLTV document.
#
sub fix_ananova_xml( $ ) {
    for (${ $_[0] }) {
	# Work around bad characters.
	s/\s&\s/ &amp; /g;

	# Empty <category> (and possibly other) elements.
	# (Spurious backslash in regexp to keep Emacs happy.)
	if (s!<(\w+) lang="\w+"(?:\s+x-\w+="[^\"]*")*></\1>!!) {
#           warn "got page $_ containing empty $1\n";
	}
	
	if (/^\s*Can\'t connect to db$/) {
	    # This is so serious we abort the whole program.
	    die "\nWeb site giving 'Can't connect to db' error.  Please try again later.\n";
	}
	
	if (not /<tv/) {
	    warn "no <tv> element found in XML: $_\n";
	    return 0;
	}

	# Seems okay...
	return 1;
    }
}
