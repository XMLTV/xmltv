#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_grab_uk - Grab TV listings for the United Kingdom.

=head1 SYNOPSIS

tv_grab_uk --help

tv_grab_uk [--config-file FILE] --configure

tv_grab_uk [--config-file FILE] [--output FILE] [--days N]

=head1 DESCRIPTION

Output TV and radio listings in XMLTV format for many stations
available in Britain.  The data comes from the Ananova website (and is
subject to their terms and conditions).

First you must run B<tv_grab_uk --configure> to choose which stations
you want to receive.  Choose a terrestrial analogue TV region, and
optionally some digital or satellite channels plus radio.  To help you
choose digital channels some 'packages' of channels are defined.

Then running B<tv_grab_uk> with no arguments will get a weekE<39>s
listings for the stations you chose.

B<--configure> Prompt for which stations to download and write the
configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_uk>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> When grabbing, write output to FILE rather than
standard output.

B<--days N> When grabbing, grab N days starting from today, rather
than as many as possible.

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.ananova.com/tv/>,
L<http://www.ananova.com/about/terms.html>

=head1 AUTHOR

Ed Avis, epa98@doc.ic.ac.uk

=head1 BUGS

Currently there is no means to edit a previous configuration, you have
to reconfigure from scratch.  There is also no system to prompt the
user about new channels that have appeared on the Ananova site.

=cut

use strict;
use LWP::Simple;
use Getopt::Long;
use Tie::IxHash;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Date::Manip;
use Tie::RefHash;
use Term::ProgressBar;
use IO::File;
use Tie::RefHash;

use XMLTV;
use XMLTV::TZ qw(gettz);
use XMLTV::UK_TZ;
use XMLTV::Ananova_Channel;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Usage <<END
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
END
  ;

# Prototype declarations
sub get_copyright( $ );
sub get_regions( $$ );
sub get_dir( $$ );
sub read_channels_page( $ );
sub read_file( $$$$$ );
sub date_programmes( $$ );
sub add_clumpidx( $ );
sub get_channel_pkgs();
sub init_channels();
sub write_channels( $$ );
sub get_pages( $$ );
sub configure();
sub grab( @ );

# Check options.  First do the undocumented --cache option (to cache
# get(), which retrieves web pages), then the normal ones.
#
my $using_cache = XMLTV::Memoize::check_argv('get');
my ($opt_days, $opt_help, $opt_output, $opt_share,
    $opt_configure, $opt_config_file);
GetOptions('days=i'        => \$opt_days,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'share=s'       => \$opt_share, # also undocumented
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
if ($opt_help) {
    usage(1);
}
if ($opt_configure) {
    print STDERR "Going to configure channels to download, please wait\n";
}

# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_uk.PL.  But we can use the
# current directory instead of share/tv_grab_uk for development.
#
# The 'source' file tv_grab_uk.in has $SHARE_DIR undef, which means
# use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_uk" : '.';

# PHP page provided by Ananova to access their internal listings data.
# This is used as an inital substring of all the URLs gotten by this
# program.
#
my $A = 'http://www.ananova.com/tv_listings/_tv_raw.php';

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/tv_grab_uk";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = 'tv_grab_uk';
    }
}
print STDERR "using config file $CONFIG_FILE\n";

# On Windows Date::Manip can have trouble finding the local timezone.
# Since the output listings shouldn't depend on the local timezone
# anyway, we just set it here.
#
Date_Init('TZ=UT');

# Things will go horribly wrong if Ananova change pages from one day
# to the next while the script is running.  Assume they do it at
# midnight.
#
use vars '$today';
BEGIN { $today = ParseDate('today'); die if not defined $today; }
END {
    if (UnixDate(ParseDate('today'), '%Q') ne UnixDate($today, '%Q')) {
	warn "current day has changed, results may be messed up\n";
    }
}

# And Ananova may be one day behind.  If this happens warn about it
# once and then continue.
#
my $fudge_day; # true, false, or undef

# Convert an internal (Date::Manip) date to output format.
sub ud {
    my ($internal, $tz) = @{date_to_uk($_[0])};
    return UnixDate($internal, '%q') . ' ' . $tz;
}

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

# The date libraries, however, do benefit from memoization.  It's only
# about an 8% speed increase for the program as a whole, but worth it.
#
use Memoize;
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly\n";
}
else {
     foreach (qw(parse_uk_date ParseDate UnixDate DateCalc Date_Cmp
		 ParseDateDelta ud)) {
	 Memoize::memoize($_) or warn "cannot memoize $_";
     }
}

# Download the three index pages now.
my $index_pages = get_pages('getting list of channels', [ qw(regions allchannels dir) ]);

# Set up the global channels and regions data.  This is needed for
# both configuration and grabbing.
#
my $regions = get_regions($index_pages->{regions}->{content},
			  $index_pages->{regions}->{url});
XMLTV::Ananova_Channel->know_regions(values %$regions);
my %region_display = reverse %$regions;
init_channels();
read_channels_page($index_pages->{allchannels}->{content});

# Predefined channel packages for ease of configuration.
my %channel_pkgs = get_channel_pkgs();

if ($opt_configure) {
    configure();
} else {
    my %g_args = ();
    if (defined $opt_output) {
	my $fh = new IO::File ">$opt_output";
	die "cannot write to $opt_output\n" if not $fh;
	%g_args = (OUTPUT => $fh);
    }
    grab(%g_args);
}


# Ask the user which channels to download, and write $CONFIG_FILE.
sub configure() {
    warn "FIXME overwriting existing $CONFIG_FILE\n";
    # FIXME need to make directory
    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    my %chose_ch;

    # Need to ask:
    #
    # - Do you get terrestrial TV and if so what region?
    # - Do you have satellite?
    # - Do you have radio?  (incl. with Sky Digital)
    # - If satellite, prompt for channel packages.
    #
    my $terr = askBooleanQuestion
      ('Do you get terrestrial analogue television?', 1);
    if ($terr) {
	my @region_dns = sort keys %$regions;
	die if not @region_dns;
	my $default_region = 'Carlton';
	if (not defined $regions->{$default_region}) {
	    warn "default region '$default_region' seems to have disappeared\n";
	    $default_region = $region_dns[0];
	}
	my $region_dn = askQuestion
	  ('Which terrestrial region?', $default_region, @region_dns);
	my $aid;
	foreach (@region_dns) {
	    if ($_ eq $region_dn) {
		$aid = $regions->{$_};
		last;
	    }
	}
	die if not defined $aid;
	print CONF "region $aid\t# $region_dn\n";
    }

    my $dig = askBooleanQuestion
      ('Do you get digital or satellite television?', 0);
    if ($dig) {
	print <<END
You now need to select which digital channels to download.
First choose some predefined packages of channels.
END
  ;
	my $finished_option = 'Finished choosing packages';
	die "can't have package named '$finished_option'!"
	  if defined $channel_pkgs{$finished_option};
	my %to_choose = %channel_pkgs;
	while (%to_choose) {
	    my @k = sort keys %to_choose;
	    my $default = $k[0];
	    my $chosen = askQuestion('Package to add: ',
				     $default, @k, $finished_option);
	    last if $chosen eq $finished_option;

	    # Now prompt about individual channels in this package.
 	    use vars '@ch_in_pkg';
	    local *ch_in_pkg = delete $to_choose{$chosen};
	    my @r = askManyBooleanQuestions
	      (1, map { "Add channel $_?" } @ch_in_pkg);
	    die if @r != @ch_in_pkg;
	    foreach (@ch_in_pkg) {
		if (shift @r) {
		    unless ($chose_ch{$_}++) {
			print CONF "channel $_\t# from package $chosen\n";
		    }
		}
	    }
	}
    }

    if (askBooleanQuestion('Download radio listings?', 1)) {
	print CONF "type radio\n";
    }

    print "Any other channels which may have been missed?\n";
    for (;;) {
	print "Enter the name of a channel, or '.' to finish: ";
	my $in = <STDIN>;
	$in =~ s/^\s+//; $in =~ s/\s+$//;
	last if $in eq '.';
	my @poss;
	foreach (XMLTV::Ananova_Channel->all()) {
	    push @poss, $_ if $_->get_a_display_name() =~ /$in/i;
	}
	if (@poss == 0) {
	    print "No channel matching that.\n";
	}
	elsif (@poss == 1) {
	    my $ch = $poss[0];
	    if (askBooleanQuestion('Add channel ' .
				   $ch->get_a_display_name() . '?', 1)) {
		my $xmltv_id = $ch->get_xmltv_id();
		unless ($chose_ch{$xmltv_id}++) {
		    print CONF "channel $xmltv_id\n";
		}
	    }
	}
	elsif (1 <= @poss and @poss < 25) {
	    my %dn_to_ch;
	    foreach (@poss) {
		my $dn = $_->get_a_display_name();
		warn "more than one channel called $dn"
		  if exists $dn_to_ch{$dn};
		$dn_to_ch{$dn} = $_;
	    }
	    my $none_option = 'None of the above are what I wanted';
	    die 'silly channel name' if exists $dn_to_ch{$none_option};
	    my $r = askQuestion('Which channel to add?',
				$poss[0]->get_a_display_name(),
				(sort keys %dn_to_ch), $none_option);
	    next if $r eq $none_option;
	    my $ch = $dn_to_ch{$r}; die if not defined $ch;
	    my $xmltv_id = $ch->get_xmltv_id();
	    unless ($chose_ch{$xmltv_id}++) {
		print CONF "channel $xmltv_id\n";
	    }
	}
	elsif (25 <= @poss) {
	    print "'$in' matches lots of channels, be more specific.\n";
	}
	else { die }
    }

    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab a week's listings.\n";
    exit();
}

# Grab listings and write them in XML.  Arguments are to be passed to
# XMLTV::Writer.
#
sub grab( @ ) {
    my %args = @_;
    my $copyright = get_copyright($index_pages->{regions}->{content});

    # Hopefully nobody will confuse this copyright message for the
    # listings with the copyright in this program.
    #
    print STDERR "\n$copyright\n";

    # Set up an XMLTV::Writer; print copyright and start of
    # document.  Ananova's data is in Latin-1.
    #
    my $writer = new XMLTV::Writer(encoding => 'ISO-8859-1', %args);
    $writer->comment($copyright);
    $writer->start({ 'source-info-url'     =>
		     'http://www.ananova.com/tv_listings/_tv_full_listings.html',
		     'source-info-name'    => 'Ananova',
		     'source-data-url'     => $A,
		     'generator-info-name' => 'XMLTV/0.5pre2', # FIXME
		     'generator-info-url'  =>
		     'http://www.doc.ic.ac.uk/~epa98/work/apps/xmltv/',
	       });

    # Find which listing files are available.
    my @files = get_dir($index_pages->{dir}->{content},
			$index_pages->{dir}->{url});

    # Now read the config file to find which files to download.  The
    # user can choose channels by type (radio or satellite), region,
    # XMLTV id, or 'ALL'.  But only some of these can be chosen with
    # --configure.  The choices 'satellite' and 'ALL' are not normally
    # user-visible, they'd be a huge set of channels.
    #
    my (%wanted_type, %wanted_region, %wanted_xmltv_id);
    my $want_all;
    open(CONF, $CONFIG_FILE)
      or die "cannot read $CONFIG_FILE, run $0 --configure\n";
    while (<CONF>) {
	s/\#.*//; s/^\s+//; s/\s+$//;
	next if not length;
	if ($_ eq 'ALL') {
	    $want_all = 1;
	}
	elsif (/^type\s+(radio|satellite)$/) {
	    $wanted_type{$1} = 1;
	}
	elsif (/^region\s+(.+)/) {
	    my $region = $1;

	    # For backward compatibility turn old-style Ananova
	    # regions like 'ne_11' into just numbers like '11'.
	    #
	    if ($region =~ /^[a-z]+_(\d+)$/) {
		$region = $1;
	    }
	    die "$CONFIG_FILE:$.:bad region specification $region"
	      if $region =~ tr/0-9//c;
	    $wanted_region{$region} = 1;
	}
	# No way to ask for channel packages directly, they are used
	# only by --configure.  So far.
	elsif (/^channel\s+(.+)/) {
	    $wanted_xmltv_id{$1} = 1;
	}
	else { die "$CONFIG_FILE:$.: bad line\n" }
    }

    # Filter out the files we want to download - those with the correct
    # channel type, region or channel id.
    #
    t 'deciding which files to download';
    my %used_xmltv_id;
    my $wanted_file = sub( $ ) {
#	local $Log::TraceMessages::On = 1;
	t 'looking at file: ' . d $_[0];
	my ($filename, $day, $aid) = @{$_[0]};
	if (defined $opt_days and $opt_days < $day) {
	    t 'outside the --days range';
	    return 0;
	}

	if ($want_all) {
	    t 'want all files, so want this one';
	    return 1;
	}

	my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($aid);
	t 'looked up by Ananova id: ' . d $ch;
	if (not defined $ch) {
	    warn "cannot lookup $aid";
	    return 0;
	}

	# The same channels may be available as two different
	# files.  We want only the first Ananova set of pages
	# for this channel.
	#
	if ($ch->get_first_ananova_id() eq $aid) {
	    t 'is first Ananova id, continuing';
	} else {
	    t 'a secondary Ananova page for this channel, skipping';
	    return 0;
	}

	my $type = $ch->get_type();
	if (defined $type) {
	    if ($wanted_type{$type}) {
		t "wanted by type $type";
		return 1;
	    }
	}
	else {
	    warn 'channel ' . $ch->stringify() . ' has no type';
	    return 0;
	}

	foreach my $wr (keys %wanted_region) {
	    if ($ch->is_region($wr)) {
		t "belongs to wanted region $wr";
		return 1;
	    }
	}

	my $xmltv_id = $ch->get_xmltv_id();
	t 'channel has XMLTV id: ' . d $xmltv_id;
	if (defined $xmltv_id) {
	    if ($wanted_xmltv_id{$xmltv_id}) {
		t 'this id is wanted';
		$used_xmltv_id{$xmltv_id}++;
		return 1;
	    }
	}
	else {
	    warn 'channel has no XMLTV id: ' . $ch->stringify();
	    return 0;
	}

	t 'nothing matched';
	return 0;
    };

    @files = grep { $wanted_file->($_) } @files;
    foreach (@files) { die if not ref }
#    local $Log::TraceMessages::On = 1;
    t 'files to download: ' . d \@files;
    t 'checking that every wanted XMLTV id was found';
    foreach (sort keys %wanted_xmltv_id) {
	next if $used_xmltv_id{$_};
	my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	die if not defined $ch;
	warn 'channel ' . $ch->stringify() . ' not found on site';
    }

    # We want to get them in day order, so that we can get the first day's
    # listings first.  This is becuase we need to get a complete day to
    # get the complete channel information, which must be written out
    # before any programmes.
    #
    # We download all the files at once, then process them one by one.
    #
    my $got = get_pages('downloading listings', [ map { $_->[0] } @files ]);
    my $bar = new Term::ProgressBar('parsing', scalar @files);
    my $first_day;
    my %chans_todo; tie %chans_todo, 'Tie::RefHash';
    my $wrote_channels = 0;
    my @progs_todo;
    foreach (sort { $a->[1] <=> $b->[1] } @files) { # FIXME use
                                                    # hashrefs not lists
	my ($filename, $day, $ananova_id) = @$_;
	t "getting file for day $day, Ananova id $ananova_id, filename $filename";
	die if defined $opt_days and $day > $opt_days;
	$first_day = $day if not defined $first_day;

	# Work out the actual day this number corresponds to: 1 is
	# today.
	#
	my $day_offset = $day-1;
	t 'day offset: ' . d $day_offset;

	my $day_date = DateCalc($today, "+ $day_offset days");
	die if not defined $day_date;

	# I noticed that at 00:49 the pages had not changed over. This
	# is a horrible kludge, but these listings will soon be taken
	# out of service so who cares.
	#
	$day_date = DateCalc($day_date, '- 1 day') if $fudge_day;
	die if not defined $day_date;

	# Get a list of programmes from this filename, fix the dates and
	# add clumpidxes.
	#
	my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($ananova_id);
	die if not defined $ch;
	my $g = $got->{$filename};
	my $progs = read_file(\$day_date, $ch, $g->{content}, $filename, $g->{url});
	if (defined $progs) {
	    date_programmes($progs, $day_date);
	    add_clumpidx($progs);
	    push @progs_todo, @$progs;

	    # Add the channel to the list of channels to output.  Well
	    # actually it's a hash because in the case of grabbing ALL
	    # files on Ananova we may grab the same channel twice (but
	    # it should be written as a <channel> element only once).
	    #
	    ++$chans_todo{$ch};
	}
	else {
	    my $chd = $ch->get_a_display_name();
	    warn "not writing any programmes for channel $chd, day $day_date\n";
	}

	# Check to see if we have to write channels data first.
	if (not $wrote_channels) {
	    if ($day != $first_day) {
		# Must have done a whole day's listings, channels are
		# ready to write.  We write only those channels for
		# which there were programmes during the first day -
		# this is good enough and avoids writing out channels
		# which were listed in dir but didn't really have any
		# programmes.
		#
		write_channels($writer, [ keys %chans_todo ]);
		$wrote_channels = 1;
	    }
	}

	if ($wrote_channels) {
	    t 'channels have been written before, write programmes';
	    $writer->write_programme($_) foreach @progs_todo;
	    @progs_todo = ();
	}

	update $bar;
    }

    # In case we never got to the second day, make sure the pending stuff
    # is written.
    #
    if (not $wrote_channels) {
	write_channels($writer, [ keys %chans_todo ]);
	$writer->write_programme($_) foreach @progs_todo;
	$wrote_channels = 1; @progs_todo = ();
    }

    # Finish.
    $writer->end();
}


# Extract the copyright message from the comment at the start of every
# page served.  Takes page content, returns the copyright message.
#
sub get_copyright( $ ) {
    my $r;
    foreach (split /\n/, $_[0]) {
	s/^\s*\#// or die "unexpected non-comment line in page";
	s/^\s+//;
	last if not length;
	$r .= "$_\n";
    }
    return $r;
}


# Return a reference to an ordered hash mapping region display name to
# Ananova internal region number.  The old Ananova region names like
# 'ea_0' are ignored, now we just look at the number 0.
#
# Parameters:
#   contents of Ananova 'regions' page
#   URL of that page (for error reporting)
#
sub get_regions( $$ ) {
    my ($data, $url) = @_;
    my %r; tie %r, 'Tie::IxHash';
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	if (/^region\.(?:[a-z]+_)?(\d+)=(.+)$/) {
	    $r{$2} = $1;
	}
	else {
	    warn "bad line from $url: $_";
	}
    }
    if (not keys %r) {
	warn "couldn't get any region data from $url";
    }
    return \%r;
}


# Get the list of Ananova 'filenames' and parse each filename into a
# tuple of:
#
# [ original filename, day number, Ananova channel id ]
#
# Returns a list of these tuples (er, listrefs).
#
# Parameters:
#   contents of Ananova 'dir' page
#   URL of 'dir' page
#
sub get_dir( $$ ) {
    my ($data, $url) = @_;
    local $Log::TraceMessages::On = 0;

    my @r;
    my %warned_unknown_region;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	my $orig = $_;

	s/^day(\d+)_// or die "bad Ananova filename $_ (no 'dayX_')";
	my $day = $1;
	my $channel = $_;

	push @r, [ $orig, $day, $channel ];
    }
    return @r;
}


# Read Ananova's Channels page.  This tells us about radio and
# satellite channels.
#
# Parameter: content of channels page
#
sub read_channels_page( $ ) {
    my $data = shift; die if not defined $data;
    local $Log::TraceMessages::On = 0;

    my (%type, %display);
    my %seen_display;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	if (not /^([^=]+)=(.+)/) {
	    warn "bad line in channels listing: $_\n";
	    next;
	}
	my ($ananova_id, $display) = ($1, $2);
	t "ch=$ananova_id, display=$display";
	my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($ananova_id);
	$ch = new XMLTV::Ananova_Channel() if not defined $ch;
	$ch->add_ananova_id($ananova_id);

	# Only set the display name based on the first (ie,
	# best) Ananova id for this channel.  Otherwise we'd
	# have a conflict between say 'Border' and 'Border
	# (Scottish viewers)'.  Only the first of the two should
	# have a chance to set the display name.
	#
	if ($ch->get_first_ananova_id() eq $ananova_id) {
	    $ch->set_main_display_name($display);
	}
	# Additional display names are added from the channel_ids file
	# but *not* from Ananova's extra names.
	#
	# No warning for duplicate display names, that often happens.
	#

	$ch->guess_type() if not defined $ch->get_type();
    }
}


# Read data for a particular day.
#
# Parameters:
#   reference to date expected in file (in Date::Manip format)
#   XMLTV::Ananova_Channel object, used to check and set display name
#   content of page from Ananova
# Plus two used for error reporting and checking:
#   Ananova 'filename'
#   Ananova URL
#
# Returns: reference to list of programme details, or undef if error.
# These won't have proper start and stop times; instead they have a
# 'time' key and you should use date_programmes() or similar to fix up
# the list of programmes afterwards.  Also the channel is not
# included, you should add that to each programme (probably in RFC2838
# style) afterwards.
#
# The expected date is used for two things.  For error checking, and
# if read_file() gets a different date to the one expected but decides
# it is worth working around, then the scalar pointed to will be
# changed to the new date.  See also the global $fudge_day.
#
my (%warned_shorter, $warned_wrong_date); # cut down on duplicate warnings
sub read_file( $$$$$ ) {
    use vars '$date_expected'; local *date_expected = shift;
    my ($ch, $data, $file, $url) = @_;
    my @lines = split /\n/, $data;
    foreach (@lines) { s/^\s+//; s/\s+$//; s/\#.*// }
    @lines = grep { length } @lines;

    if (not @lines) {
	# No non-comment lines.  This could be because the PHP script
	# is returning 'file not found'.  That happens if you request
	# the directory listing, it contains obsolete files which
	# (wrongly) are still around, and then your request for the
	# file itself is handled by a different box where the file is
	# in fact deleted.
	#
	if ($data =~ /\n\# \Q$file\E does not exist$/) {
	    warn "file $file does not exist on server, probably should be removed from dir\n";
	    return undef;
	}
	else {
	    warn "cannot get data from $url, returns:\n$data";
	    return undef;
	}
    }

    # Check the date.
    if (not check_page_date(\$date_expected, shift @lines)) {
	warn "bad date in $file (expected $date_expected), skipping";
	return undef;
    }

    # No need to check the display name, we assume it will be the same
    # as in the show=allchannels list.  Ah, bliss.
    #
    shift @lines;

    my $copyright = pop @lines;
    if ($copyright !~ /^\(c\) Copyright/) {
	warn "strange copyright message: $copyright\n";
    }

    if (@lines and $lines[0] =~
	/^There are no listings available for this channel today\|\|/) {
	return [];
    }

    # Right, got that cruft out of the way, each remaining line is a
    # |-separated list of programme details.
    #
    my @r;
    my $prev_time;
    foreach (@lines) {
	my @fields = split /\|/, $_, -1; # toothpicks ahoy!
	my $num_fields = scalar @fields;
	if ($num_fields == 1 and $fields[0] =~ /copyright/i) {
	    next;
	}
	if ($num_fields < 17 or $num_fields >= 22) {
	    warn "wrong number of fields ($num_fields, need 17..21) "
	      . "in line from $url: $_\n";
	    warn "fields are: " . join("\n", @fields) . "\n";
	    warn "skipping line\n";
	    next;
	}
	my ($title, $time, $when, $episode_num, $episode_name, $cast,
	    $director, $duration, $main_desc, $type, $subtitled, $bw,
	    $stereo, $mono, $new, $repeat, $digital)
	  = @fields;
	my %p;

	# In the XMLTV format, title is multivalued, so it needs to be
	# a list.  Furthermore each element is itself a list of
	# [ string, language ].  Many other elements are like this.
	#
	$p{title} = [ [ $title, $LANG ] ];
	
	# The comment from Ananova says that the time is 'probably in
	# time zone existing at 5:00am of the correct file date'.  I
	# assume that means that it might not be, and it might instead
	# have an explicit timezone.  We'll just use the old
	# date-parsing routines to figure out the timezone.
	#
	# That means that for now, we add an element 'time' to the
	# programme details, and later on, date_programmes() turns
	# this into a proper start and stop time.
	#
	if (length $time) {
	    if (not $time =~ /^\d\d?:\d\d$/) {
		warn "bad time '$time' in line from page $url: $_";
		warn "skipping line";
		next;
	    }
	}
	else {
	    # No time was given for this programme.  This is probably
	    # because it's contained in the same 'clump' as the
	    # previous one, for example 'CBBC' at 6:45 is followed in
	    # the listings by 'Teletubbies' without a time.
	    #
	    # For this case, we give the programme the same time as
	    # the previous one.  That's the way it appears in the
	    # Ananova user-visible pages and it's what add_clumpidx()
	    # expects.
	    #
	    if (not defined $prev_time) {
		warn "no time for first line from page $url: $_";
		warn "skipping line";
		next;
	    }
	    $time = $prev_time;
	}

	# For sanity-checking the time against 'when',
	# comparing raw hours and minutes will probably be faster
	# than using Date::Manip.
	#
	$time =~ /^(\d\d?):(\d\d)$/ or die;
	my ($hours, $minutes) = ($1, $2);
	if (length($hours) == 1) {
	    $hours = "0$hours";
	    $time = "$hours:$minutes";
	}
	$p{time} = $time;
	$prev_time = $time;
	
	# The 'when' attribute can be DAYTIME, EVENING or LATENIGHT.
	# It seems a bit redundant to me.  But on the principle that
	# no scrap of information should be thrown away, we check that
	# it's sensible.
	#
	if ($when eq 'DAYTIME') {
	    if (5 <= $hours and $hours < 18) {
		# Daytime is between 05:00 and 18:00.  It overlaps
		# slightly with LATENIGHT.
		#
	    }
	    else {
		warn "time $time is wrongly considered 'DAYTIME' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'EVENING') {
	    if (18 <= $hours) {
		# Evening is from 18:00 until midnight.
	    }
	    else {
		warn "time $time is wrongly considered 'EVENING' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'LATENIGHT') {
	    # Latenight is until 07:00 (or sometimes a programme just
	    # beginning at that time is still latenight).  Annoyingly,
	    # 23:59 is also counted as latenight, so we'll say it runs
	    # from 23:00 to 07:00.
	    #
	    if (23 <= $hours
		or $hours < 7
		or ($hours == 7 and $minutes == 0)) {
		# Okay.
	    }
	    else {
		warn "time $time is wrongly considered 'LATENIGHT' "
		  . "in line from url $url: $_\n";
	    }
	}
	else {
	    warn "unknown 'when' specifier $when "
	      . "in line from url $url: $_";
	}

	# Episode number.
	if (length $episode_num) {
	    if ($episode_num =~ m!^[0-9/]+$!) {
		# Assume that Ananova numbers episodes from 1; but
		# XMLTV - like all good languages - counts from 0.
		#
		$episode_num =~ s/^(\d+)/$1 - 1/e;

		# We don't know the series or season.
		$p{'episode-num'} = [ ". . $episode_num", 'xmltv_ns' ];
	    }
	    else {
		warn "bad episode number '$episode_num' "
		  . "in line from url $url: $_";
	    }
	}

	# Epsiode name.  This corresponds to the badly named
	# 'sub-title' in XMLTV.
	#
	if (length $episode_name) {
	    $p{'sub-title'} = [ [ $episode_name, $LANG ] ];
	}

	# Cast.
	if (length $cast) {
	    foreach (split /\s*,\s*/, $cast) {
		push @{$p{credits}{actor}}, $_;
	    }
	}

	# Director.
	if (length $director) {
	    foreach (split /\s*,\s*/, $director) {
		push @{$p{credits}{director}}, $_;
	    }
	}
	
	# Ananova's idea of 'duration' is usually the original length
	# of a film - not the length it is shown at on TV.  Now we do
	# have a 'length' element in the XMLTV format, but that's
	# meant for the length _as shown_, just not including adverts
	# or other junk.  So we just discard duration.
	#
	# There is an occasional bug in the site where the duration has
	# what looks like a year stuck three times onto the end.  As
	# in '85 mins1997 1997 1997'.
	#
	$duration =~ s/(\d{4}) \1 \1$//;
	if ($duration ne '' and $duration !~ /^(\d+)\s+(?:mins|minutes)$/) {
	    warn "bad duration $duration "
	      . "in line from url $url: $_";
	}

	# Programme type.
	if (length $type) {
	    foreach (split /\s*,\s*/, $type) {
		# Convert Ananova's categories into English.
		my %lookup = (chldren => 'children',
			      diy => 'DIY');
		$_ = lc;
		$_ = $lookup{$_} if defined $lookup{$_};
		push @{$p{category}}, [ $_, $LANG ];
	    }
	}

	# Subtitles.  Assume that when Ananova say this, they mean
	# teletext (I don't know what happens for foreign films with
	# on-screen subtitles).
	#
	if ($subtitled) {
	    # We don't know what language the subtitles are in.  $LANG
	    # sets the language for the descriptions, not the
	    # programmes themselves.
	    #
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	
	# Check 'type' of channel to decide whether video and audio
	# elements need be present.  If $p{video}{present} is false,
	# that means there's definitely no picture; if it's undefined
	# then we don't know yet.
	#
	my $ch_type = $ch->get_type();
	if ($ch_type eq 'terrestrial') {
	    # Terrestrial television.  We can't infer anything from
	    # that, because occasionally programmes are broadcast with
	    # no picture or no sound.
	    #
	}
	elsif ($ch_type eq 'satellite') {
	    # Similar.
	}
	elsif ($ch_type eq 'radio') {
	    $p{video}{present} = 0;
	    $p{audio}{present} = 1;
	}
	elsif ($ch_type eq 'duff') {
	    die "trying to download listings for duff channel";
	}
	else { die "bad type $ch_type for channel $ch" }

	# Black and white - in other words, not colour.
	if ($bw) {
	    if (defined $p{video}{present} and not $p{video}{present}) {
		warn "black-and-white flag set for a programme with no picture";
	    }
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}
	
	# Stereo or mono.
	if (not $stereo and not $mono) {
	    # Just don't set any of the flags.
	}
	else {
	    if (defined $p{audio}{present} and not $p{audio}{present}) {
		warn "stereo information set for a programme with no sound";
	    }
	    $p{audio}{present} = 1;

	    if (not $stereo and $mono) {
		$p{audio}{stereo} = 'mono';
	    }
	    elsif ($stereo and not $mono) {
		$p{audio}{stereo} = 'stereo';
	    }
	    elsif ($stereo and $mono) {
		warn "line in page $url has both stereo and mono: $_";
	    }
	    else { die }
	}

	# Repeat or new.  I don't know whether these are necessarily
	# mutually exclusive - you might have an instant repeat of the
	# first episode of a new series have both.  So I won't bother
	# checking that both are not set.
	#
	if ($repeat) {
	    # 'Repeat' in British TV usually means 'previously shown
	    # on the same channel'.  It has happened that series
	    # transferred from one channel to another got repeated on
	    # the new channel as 'new'.
	    #
	    # However, we can't say this for sure.  Things can be
	    # shown on BBC1 and then 'repeated' on BBC2, for example.
	    # Short of some really ornate system to describe all
	    # different nuances of previously-shown in the file
	    # format, we just have to leave the element empty.
	    #
	    $p{'previously-shown'} = {};
	}
	if ($new) {
	    $p{new} = 1;
	}

	# I don't know what the 'digital' flag is for: Ananova says
	# 'if known to be available on as digital transmission'.  Just
	# ignore it.
	#

	# There is one main description and up to four additional
	# descriptions with increasing levels of detail.  We
	# sanity-check that they have more or less increasing length.
	#
	my @descs = @fields[17..$#fields];
	foreach my $i (0 .. $#descs) {
	    next if not defined $descs[$i] or not length $descs[$i];
	    foreach my $j ($i+1 .. $#descs) {
		next if not defined $descs[$j] or not length $descs[$j];
		# Sometimes the data really does have shorter text for
		# the supposedly more detailed description.  So we
		# can't check it pedantically.  OTOH this has caught
		# some errors in data input.  So we use a heuristic:
		# the more detailed description should be at least
		# half as long as a less detailed one.
		#
		if (2 * length $descs[$j] < length $descs[$i]) {
		    unless ($warned_shorter{$descs[$j]}{$descs[$i]}++) {
			warn
			  "description $j ($descs[$j]) is much shorter than description $i ($descs[$i]) "
			    . "in line from url $url: $_";
		    }
		}
	    }
	}
	# The most detailed description should be the same as the main
	# description.  Er, except when it is not present at all.
	#
	if (defined $descs[3] and $descs[3] ne '' and $descs[3] ne $main_desc) {
	    warn "description 3 ($descs[3]) isn't the same as main desc ($main_desc) "
	      . "in line from url $url: $_";
	    # Add on the main description so we don't lose it.
	    push @descs, $main_desc;
	}
	my %seen;
	foreach (reverse @descs) {
	    next if $_ eq '';
	    next if $seen{$_}++;
	    push @{$p{desc}}, [ $_, $LANG ];
	}

	# Channel.  By now we know the display name of the
	# channel, so we can call get_xmltv_id().
	#
	$p{channel} = $ch->get_xmltv_id();

	# Source - used for debugging and written out only as a
	# comment in the output.
	#
	$p{debug_source} = $file;

	push @r, \%p;
    }
    return \@r;
}


# check_page_date()
#
# Check the date in a day's listings matches what we expect.
# According to Ananova's comment there's some odd procedure you have
# to follow to make sure it is correct.
#
# Parameters:
#   reference to expected date
#   date string from page
#
# As with read_file(), the expected date is passed by reference and
# modified sometimes.
#
sub check_page_date($$) {
    use vars '$expected'; local *expected = shift;
    my $got = shift;

    if (not $got =~
/^((?:Sun|Mon|Tues|Wednes|Thurs|Fri|Satur)day)\|(\d\d)\|(\d\d)\|(\d\d\d\d)$/)
    {
	warn "bad date '$got'";
	return 0;
    }
    my ($weekday, $dd, $mm, $yyyy) = ($1, $2, $3, $4);
    t "got date: $weekday $yyyy-$mm-$dd";
    my $dp = ParseDate("$yyyy-$mm-$dd");
    if (not defined $dp) {
	warn "bad date '$got'";
	return 0;
    }
    t "parsed out date $dp, check it matches $weekday";
    if (UnixDate($dp, '%A') ne $weekday) {
	# Apparently you have to step backwards by one or two days
	# until the date matches the weekday given.
	#
	my $found = 0;
	foreach (0, 1) {
	    $dp = DateCalc($dp, '- 1 day'); die if not defined $dp;
	    if (UnixDate($dp, '%A') eq $weekday) {
		$found = 1;
		last;
	    }
	}
	if (not $found) {
	    warn "weekday of $got is wrong (even tried going back a couple of days)";
	    return undef;
        }
    }

    # But does it match what we expect?
    my $day_got = UnixDate($dp, '%Q');
    my $day_expected = UnixDate($expected, '%Q');
    if ($day_got ne $day_expected) {
	if ($using_cache) {
	    unless ($warned_wrong_date++) {
		warn "since cache is in use, ignoring wrong date in pages\n";
	    }
	}
	elsif (not defined $fudge_day) {
	    # There's still a chance to set the fudge-flag for
	    # days and work around Ananova being one day out.
	    #
	    my $yesterday = DateCalc($expected, '- 1 day');
	    die if not defined $yesterday;
	    if ($day_got eq UnixDate($yesterday, '%Q')) {
		warn "Ananova is one day behind, so day 1 is yesterday\n";
		$fudge_day = 1;
		$expected = $yesterday; # passed by ref, remember
	    } else {
		warn "wrong date in page: expected $day_expected, got $day_got\n";
		$fudge_day = 0; # don't try this trick again
		return 0;
	    }
	} else {
	    warn "wrong date in page: expected $day_expected, got $day_got\n";
	    return 0;
	}
    }
    
    return 1;
}


# date_programmes()
#
# Given a list of programme details (from extract_progs()) and the date
# of this listing, add proper time and date for each programme.  In UT.
#
# Parameters:
#   reference to list of programme details
#   date in Date::Manip format
#
# Modifies the list passed in, so that each programme no longer has
# {time} but has {start} instead.  If the programme has
# {length}, gets rid of that too and puts in {stop}.
#
sub date_programmes($$) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_date) = @_;
    t 'adding date to programmes: ' . d $progs;
    t 'base date: ' . d $base_date;
    my $base_day = UnixDate($base_date, '%Q');
    die if not defined $base_day;
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;

    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my $current_tz = 0; # not undef, because of Memoize complaining

    foreach (@$progs) {
	t('adding date to programme ' . d($_));
	my $t = $_->{'time'};
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	if (defined gettz($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t "found explicit timezone $t, using for future progs";
	    $current_tz = gettz($t);
	}

	t "doing 24h UK time $t with base day $base_day";
	my $prog_date = parse_uk_date("$base_day $t", $current_tz);
	if (not defined $prog_date) {
	    # It's not a valid UK time.  Two reasons for this: it
	    # really isn't, or we're just confused about what day it
	    # is and need to 'jump' forward a day.
	    #
	    t 'that date is bad, maybe need to jump a day?';
	    my $err;
	    my $new_base_day = UnixDate
	      DateCalc($base_day, $day_later, \$err),
	      '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    my $new_prog_date = parse_uk_date("$new_base_day $t", $current_tz);
	    die "bad base day + time '$t' (even tried next day)"
	      if (not defined $new_prog_date) or ($new_prog_date !~ /\S/);
	    t 'okay... assume we will jump a day (do it later)';
	}

	if ((not defined $prog_date)
	    or (defined $prev_date
		and (Date_Cmp($prev_date, $prog_date) > 0) ) )
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day - but see below.
	    #
	    t 'time is lower than before';
	    my $prev_day = UnixDate $prev_date, '%Q';
	    t 'previous programme was at ' . d($prev_date);
	    my $threshold = ParseDate("$prev_day 12:00:00");
	    t 'threshold is ' . d($threshold);
	    if (Date_Cmp($prev_date, $threshold) < 0) {
		# I can't believe that one programme would last from
		# before 12:00 until after midnight on any day.  So
		# this seeming jump to the next day is bogus - it's
		# the same day but the time is a little bit earlier
		# for some reason.  (Probably UT/BST switching)
		#
		t 'previous programme started before threshold, ' .
		  'cannot be next day';
	    }
	    else {
		t 'must be next day';
		my $err;
		$base_day = UnixDate
		  DateCalc($base_day, $day_later, \$err),
		  '%Q';
		die "error from DateCalc(): $err" if defined $err;
		$prog_date = parse_uk_date("$base_day $t", $current_tz);
		die "bad base day + time '$t'"
		  if (not defined $prog_date) or ($prog_date !~ /\S/);
		t 'new base day: ' . d($base_day);
	    }
	}

	delete $_->{'time'};
	$_->{start} = ud($prog_date);
	t 'new start time: ' . d($_->{start});
	$prev_date = $prog_date;

	if (defined(my $length = delete $_->{length})) {
	    # Try to calculate the stop time based on start time and length.
	    if (not defined $_->{stop}) {
		my $stop = DateCalc(ParseDate($_->{start}), "+ $length");
		if (defined $stop) {
		    $_->{stop} = ud($stop);
		}
		else {
		    warn "could not calculate stop time from $_->{start} + $length";
		}
	    }
	    else {
		warn 'programme has both length and stop';
	    }
	}
    }
}


# add_clumpidx()
#
# Sometimes two programmes on a channel are given the same
# start time in the listings.  This seems to happen when the
# first is a 'mothership' containing several smaller things,
# for example '11:00 The Core, 11:00 Core News'.
#
# We add a 'clumpidx' attribute to distinguish these
# programmes.  Eg 'The Core' has clumpidx '0/2' and 'Core
# News' has '1/2'.
#
# Parameters:
#   a reference to a list of programmes for one channel, which will
#   be modified
#
sub add_clumpidx($) {
    die "usage: add_clumpidx(ref to list of programmes)"
      if @_ != 1;
    my $progs = shift;
    t('add_clumpidx() ENTRY');

    my $last_start;
    my %num_in_clump; # Maps start time to num. progs at that time
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = ParseDate($_->{start});
	t '$start=' . d($start);
	$_->{clumpidx} = $num_in_clump{$start}++;
	t 'clumpidx now ' . d($_->{clumpidx});

	if ($num_in_clump{$start} > 1) {
	    if (not defined $last_start or $last_start ne $start) {
		warn <<END
more than one programme at $start on same channel, \
but not consecutive in listings (this is $_->{title})
END
				 ;
	    }
	}
	$last_start = $start;
    }

    # Okay, we've got clumpidx of '0', '1' where needed, but even
    # better would be '0/2', '1/2'.  We look at how many programmes
    # are in each clump: if only one, remove the clumpidx entirely.
    # If more than one, put the full 'x/y' clumpidx.
    #
    t "refine clumpidx's and build todo list";
    my %todo;
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = ParseDate($_->{start});
	my $num = $num_in_clump{$start};
	die if not defined $_->{clumpidx};
	if ($num == 1) {
	    # Ordinary, sane programme not sharing its slot.  This
	    # would have a clumpidx of '0/1', which isn't worth
	    # putting in the output.
	    #
	    t 'only programme in slot';
	    die if $_->{clumpidx} ne '0';
	    delete $_->{clumpidx};
	}
	elsif ($num > 1) {
	    t 'shares a slot';
	    $_->{clumpidx} .= "/$num";
	    t 'new clumpidx: ' . d($_->{clumpidx});
	    push @{$todo{$start}}, $_;
	    t "\$todo{$start} now " . d($todo{$start});
	}
	else { die }
    }
    t 'add_clumpidx() EXIT';
}

# Write channels as XMLTV.
#
# Parameters:
#     XMLTV::Writer to use
#     ref to list of Ananova_Channel objects.
#
sub write_channels( $$ ) {
#    local $Log::TraceMessages::On = 1;
    my $writer = shift;
    foreach (sort { $a->get_xmltv_id() cmp $b->get_xmltv_id() } @{shift()}) {
	$_->write($writer, $LANG);
    }
}


####
# Channels stuff
#

# In principle it should be possible to find all channel data by
# looking at the Ananova site.  However they don't use the RFC2838
# style names, and I also want to add some extra display names for
# channel numbers.  So there's a hardcoded table listing XMLTV channel
# ids, their equivalent on the Ananova site, and optionally an extra
# (short) display name for that channel.
#
# It can be hard to decide whether two related channels should map to
# the same internal name - eg digital and analogue versions of the
# same channel.  I have made different internal names if I know that
# the content will be different (eg BBC1 digital is different to any
# of the analogue region versions), but otherwise mapped both channels
# to the same internal name.  Sometimes there are annoying small
# differences which require differing internal names, else
# tv_sort complains.  The same applies to regional variants for
# channels which don't differ between regions (eg Channel 5).
#
# Piping the output through tv_sort will check that the two
# versions of a channel are indeed identical.
#
sub init_channels() {
#    local $Log::TraceMessages::On = 1;
    # See the distributed version of this file for info about the
    # format.
    #
    my $channel_names_file = "$OUR_SHARE_DIR/channel_ids";
    local *FH;
    open (FH, "<$channel_names_file")
      or die "cannot open $channel_names_file: $!";
    while (<FH>) {
	s/^\s+//; s/\s+$//; s/\#.*//;
	next unless length;
	my @fields = split /:/;
	die "$channel_names_file:$.: wrong number of fields"
	  if @fields < 3 or @fields > 4;

	my ($xmltv_id, $ananova_ids, $type, $extra_dn) = @fields;
	my @aids = split /,/, $ananova_ids;
	die "$channel_names_file:$.: no Ananova ids"
	  if not @aids;

	t "initializing channel with id $xmltv_id";
	my $ch = new XMLTV::Ananova_Channel();
	$ch->set_xmltv_id($xmltv_id);
	foreach (@aids) {
	    t "adding Ananova id $_";
	    $ch->add_ananova_id($_);
	}
	t 'setting type: ' . d $type;
	$ch->set_type($type);
	t 'maybe adding extra display name: ' . d $extra_dn;
	$ch->add_extra_display_names($extra_dn)
	  if defined $extra_dn;
    }
    close FH or warn "cannot close $channel_names_file: $!";
}

# Return a hash mapping package names to lists of XMLTV channel ids.
sub get_channel_pkgs() {
    # Each package is a file under channel_pkgs/ somewhere in share/.
    # The filename is the package name, and then channel ids are
    # listed one per line.
    #
    my $channel_pkgs_dir = "$OUR_SHARE_DIR/channel_pkgs";
    die "no directory $channel_pkgs_dir" if not -d $channel_pkgs_dir;
    my %pkgs;
    foreach (<$channel_pkgs_dir/*>) {
	m!^\Q$channel_pkgs_dir\E/(.+)$! or die;
	my $pkg_name = $1;
	die "package $pkg_name seen twice" if defined $pkgs{$pkg_name};
	open(PKG, "$_") or die "cannot read channel package file $_: $!";
	while (<PKG>) {
	    s/^\s+//; s/\s+$//; s/\#.*//;
	    next unless length;
	    push @{$pkgs{$pkg_name}}, $_;

	    # Check the XMLTV id is actually known.
	    my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	    if (not defined $ch) {
		warn "channel id $_ mentioned in package $pkg_name, but not known";
	    }
	}
	close PKG or die "cannot close $_: $!";
    }
    return %pkgs;
}


# get_pages()
#
# Fetch the given 'pages' from Ananova.  Attempt to combine multiple
# page fetches.
#
# Parameters:
#   text to use for progress bar
#   listref of page names to download, eg for show=dir name is 'dir'
#
# Returns: reference to hash mapping page name to a hash with 'url'
# and 'content'.  Although 'url' may be shared with other pages.
#
# Dies if a page cannot be downloaded.
#
sub get_pages( $$ ) {
#    local $Log::TraceMessages::On = 1;
    my ($text, $pages) = @_;
    my @pages = @$pages;
    foreach (@pages) { die if not defined }
    my %r;
    my $num_pages = scalar @pages;
    t "initializing progress bar with $num_pages items";
    my $bar = new Term::ProgressBar($text, $num_pages);

    # Arbitrary limit on number of pages fetched at once, requested by
    # Ananova to keep down memory usage on the server.
    #
    my $max_at_once = 10;
    while (@pages) {
	my @this_fetch = ();
	while (@pages and (@this_fetch < $max_at_once)) {
	    push @this_fetch, shift @pages;
	}
	t 'this fetch: ' . d \@this_fetch;
	t 'remaining to fetch: ' . d \@pages;
	my $url = "$A?" . join('&', map { "show[]=$_" } @this_fetch);
	t "fetching url: $url";
	foreach (@this_fetch) { $r{$_}->{url} = $url }
	my $got = get $url;
	die "cannot fetch $url" if not defined $got;
	
	# Each new page begins with some comment (#) lines.
	my @lines = split /\n/, $got;
	my @got;
	my $curr = '';
	my $in_comment = 1;
	foreach (@lines) {
	    my $is_comment = /^\#/;

	    # Horrible kludge: there is one page which does have a
	    # comment in the middle of it, ignore that line.
	    #
	    $is_comment = 0 if /^\#\s+OK,/;

	    # Another: if a file doesn't exist this is given in a
	    # comment!
	    #
	    if ($is_comment and /^\#\s+\S+ does not exist/) {
		$is_comment = 0;
	    }

	    if (not $is_comment and not $in_comment) {
		# Another ordinary line on the current page.
		$curr .= "$_\n";
	    }
	    elsif (not $is_comment and $in_comment) {
		# Reached the end of the comments on the current page.
		$curr .= "$_\n";
		$in_comment = 0;
	    }
	    elsif ($is_comment and not $in_comment) {
		# Reached some comments, must be start of next page.
		t 'reached end of page: ' . d $curr;
		push @got, $curr; update $bar;
		$curr = "$_\n";
		$in_comment = 1;
	    }
	    elsif ($is_comment and $in_comment) {
		# Another comment at the top of the current page.
		$curr .= "$_\n";
	    }
	    else { die }
	}
	t 'last page: ' . d $curr;
	push @got, $curr; update $bar;
	if (@got != @this_fetch) {
	    die 'expected ' . (scalar @this_fetch) .
	      " pages from URL $url, got " . (scalar @got);
	}
	foreach (@this_fetch) {
	    die "page $_ requested twice" if defined $r{$_}->{content};
	    $r{$_}->{content} = shift @got;
	}
    }
    die if (keys %r) != $num_pages;
    return \%r;
}
