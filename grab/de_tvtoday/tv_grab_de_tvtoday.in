#!/usr/bin/perl

=pod

=head1 NAME

tv_grab_de_tvtoday - Grab TV listings for Germany (from www.tvtoday.de webpage).

=head1 SYNOPSIS

tv_grab_de_tvtoday --help

tv_grab_de_tvtoday [--config-file FILE] --configure [--gui OPTION]

tv_grab_de_tvtoday [--config-file FILE] [--output FILE]
                   [--days N] [--offset N]
                   [--quiet] [--slow] [--nosqueezeout]

tv_grab_de_tvtoday --list-channels [--icons]

tv_grab_de_tvtoday --capabilities

tv_grab_de_tvtoday --version

=head1 DESCRIPTION

Output TV listings for several channels available in Germany.
The data comes from www.tvtoday.de which is the webpage of one of
the most popular TV magazines in Germany. The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_de_tvtoday --configure> to choose, which channels
you want to download. Then running B<tv_grab_de_tvtoday> with no
arguments will output listings in XML format to standard output.

B<--configure> Ask for each available channel whether to download
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_de_tvtoday.conf>.  This is the file
written by B<--configure> and read when grabbing.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of Term::ProgressBar.

B<--output FILE> Write to FILE rather than standard output.

B<--days N> Grab N days.  The default is seven.

B<--offset N> Start N days in the future.  The default is to start
from today (= zero). Set to -1 to grab data beginning yesterday.

B<--quiet> Suppress the progress messages normally written to standard
error.

B<--slow> enables long strategy run: tvtoday.de publishes only some (vital)
information on the actual listing pages, the rest is shown in a separate
popup window. If you'd like to parse the data from these popups as well,
supply this flag. But consider that the grab process takes much longer when
doing so, since many more web pages have to be retrieved.

B<--list-channels> Write output giving <channel> elements for every
channel available (ignoring the config file), but no programmes.

B<--icons> Get the URL for channel-logos together with the channel-list.
Mind that this takes a long time, since a webpage has to be requested for
every channel.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://membled.com/twiki/bin/view/Main/XmltvCapabilities>

B<--version> Show the version of the grabber.

B<--help> Print a help message and exit.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Stefan Siegl, stesie@brokenpipe.de. Inspired by tv_grab_fi by Matti Airas.
Modified for new tv_today design by Mirza Muharemagic <derliebegott@gmail.com>

=head1 BUGS

If you happen to find a bug, you're requested to send a mail to me
at B<stesie@brokenpipe.de> or to one of the XMLTV mailing lists, see webpages
at http://sourceforge.net/projects/xmltv/.

=cut

use warnings;
use strict;
use XMLTV::Version '$Id$ ';
use XMLTV::Capabilities qw/baseline manualconfig cache share/;
use XMLTV::Description 'Germany (www.tvtoday.de)';
use Date::Manip;
use Getopt::Long;
use HTML::TreeBuilder;
use HTML::Entities;
use URI::Escape;
use XMLTV;
use XMLTV::Ask;
use XMLTV::ProgressBar;
use XMLTV::DST;
use XMLTV::Config_file;
use XMLTV::Mode;
use XMLTV::Get_nice;
use XMLTV::Memoize;
use XMLTV::Usage <<END
$0: get German television listings from www.tvtoday.de in XMLTV format
To configure: $0 --configure [--config-file FILE] [--gui OPTION]
To grab data: $0 [--config-file FILE] [--output FILE]
                 [--days N] [--offset N]
                 [--quiet] [--slow]
Channel List: $0 --list-channels [--icons]
To show capabilities: $0 --capabilities
To show version: $0 --version

END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
        *t = sub {};
        *d = sub { '' };
    }
    else {
        *t = \&Log::TraceMessages::t;
        *d = \&Log::TraceMessages::d;
    #$Log::TraceMessages::On = 1;
    }
}

#-- our own prototypes first ...
sub grab_data($$$);
sub squeeze_out_desc($$);
sub refine_category_attr($$);
sub get_channels();
sub get_icons();
sub channel_id($);
sub split_up_names($$);
sub parse_date_data($);
sub get_page($);
sub add_credits($$@);
sub parse_page($$);
sub read_popup($$$);
sub refine_credits($);

#-- Category-Matching RegExp
our constant $category_regexp = '^(.*?\s+)?((?:[\wäöüßÄÖÜ-]+-?)?(?:[Aa]genten|[Aa]benteuer|[Aa]ction|[Aa]usland(s-?)?|[Bb]oulevard|[Cc]all-[Ii]n|[Cc]harts|[Cc]omedy|[Dd]etektiv|[Dd]oku(?:mentar|mentation)?|Daily[\s+\-][Ss]oap|[Dd]rama|[Ee]rotik|Episoden?|[Dd]rama|[Ee]rmittler|[Ff]amilien|[Gg]erichts|[Gg]esundheits?|[Jj]ournal|[Kk]rimi|[Kk]omödie|[Kk]ultur|[Ll]iteratur|[Ll]ifestyle|[Mm]agazin|[Mm]elodram|[Mm]istery|[Mm]usik|[Nn]achrichten|[Pp]olit(ik)?|[Pp]orträt|[Qq]uiz|[Rr]e(gion(al)|ligions?)|[Rr]eportage|[Rr]eihe|[Ss]oap|[Ss]atire|[Ss]erie|[Ss]piel|[Ss]tudie|[Tt]alk|[Tt]ier|[Tt]hriller|[Ww]erbsendung|[Ww]unschclip|[Gg]espräch|[Tt]elenovela|[Tt]eleshopping|[Ww]isssens?(schafts?)?|[Zz]eichentrick|[Aa]nimation|[Kk]ultur|[Bb]ericht|[Ww]etter|[Ww]estern)?\-?(?:[Ff]ilm|[Mm]ovie|[Dd]oku(mentation)?|[Bb]ericht|[Ii]nfos|[Jj]ournal|[Ss]how|[Ss]endung|[Ss]erie|[Ss]oap|[Mm]agazin|[Tt]alk|[Rr]eport(age)?|[Re]eihe|[Ee]pos)?s?)([\s;,]+.*)?$';

#-- DEBUG FLUFF ...
my $debug = 0;
$XMLTV::Get_nice::Delay = 0 if($debug);

#-- attributes of xmltv root element
my $head = {
    'source-data-url'      => 'http://www.tvtoday.de/program2007',
    'source-info-url'      => 'http://www.tvtoday.de/',
    'generator-info-name'  => 'XMLTV',
    'generator-info-url'   => 'http://membled.com/work/apps/xmltv/',
};

#-- the timezone tvtoday.de lives in is, CET/CEST
my constant $TZ = "+0100";
my constant $lang = "de";

#-- Parse argv now.  First do undocumented --cache option.
XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');

my $opt_configure;
my $opt_config_file;
my $opt_gui;
my $opt_output;
my $opt_days;
my $opt_offset = 0;
my $opt_quiet = 0;
my $opt_slow = 0;
my $opt_nosqueeze = 0;
my $opt_list_channels;
my $opt_icons = 0;
my $opt_help;
my $opt_share;
my $opt_testing;

GetOptions(
    'configure'      => \$opt_configure,
    'config-file=s'  => \$opt_config_file,
    'gui:s'          => \$opt_gui,
    'output=s'       => \$opt_output,
    'days=i'         => \$opt_days,
    'offset=i'       => \$opt_offset,
    'quiet'          => \$opt_quiet,
    'slow'           => \$opt_slow,
    'nosqueezeout'   => \$opt_nosqueeze,
    'list-channels'  => \$opt_list_channels,
    'icons'          => \$opt_icons,
    'help'           => \$opt_help,
    'share=s'        => \$opt_share,
    'testing'        => \$opt_testing,
) or usage(0);

usage(1) if $opt_help;

## Disabled at the moment, because not usable at the moment in this test version
die "Option '--nosqueezeout'  is disabled in this version. Use '--slow' if you want detailed program"
  if $opt_nosqueeze;

XMLTV::Ask::init($opt_gui);

#-- make sure offset+days arguments are within range
die "offset mustn't be larger than seven"
  if($opt_offset > 7);

warn "cannot fetch data before yesterday, starting yesterday", $opt_offset = -1
  if($opt_offset < -1);
$opt_days = 8 - $opt_offset unless (defined($opt_days));

die "fetching more than 8 days isn't possible, check offset+days arguments"
  if($opt_days + $opt_offset > 8);

#-- offset and days should be valid now, let's go on ...

my $mode = XMLTV::Mode::mode('grab', # default value
    $opt_configure     => 'configure',
    $opt_list_channels => 'list-channels',
);

#-- initialize config file support
my $config_file = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_de_tvtoday', $opt_quiet);
my @config_lines;

if($mode eq 'configure') {
    XMLTV::Config_file::check_no_overwrite($config_file);
}
elsif($mode eq 'grab' || $mode eq 'list-channels') {
    @config_lines = XMLTV::Config_file::read_lines($config_file);
}
else { die("never heard of XMLTV mode $mode, sorry :-(") }

my $bar = new XMLTV::ProgressBar( 'getting list of channels', 1 )
    if not $opt_quiet;

#-- hey, we can't live without channel data, so let's get that now!
my %channels = get_channels();
$bar->update() if not $opt_quiet;
$bar->finish() if not $opt_quiet;

#-- if wanted, get the channel logos (only in list-channels-mode done here!)
my %icons;
%icons = get_icons() if $opt_icons && $opt_list_channels;

# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_de_tvtoday.PL.  But we can
# use the current directory instead of share/tv_grab_de_tvtoday for
# development.
#
# The 'source' file tv_grab_de_tvtoday.in has $SHARE_DIR undef, which
# means use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_de_tvtoday" : '.';

# Read the file with channel mappings.
(my $CHANNEL_NAMES_FILE = "$OUR_SHARE_DIR/channel_ids") =~ tr!/!/!s;
my (%chid_mapping, %seen);
my $line_num = 0;
foreach (XMLTV::Config_file::read_lines($CHANNEL_NAMES_FILE, 1)) {
    ++ $line_num;

    next unless defined;
    my $where = "$CHANNEL_NAMES_FILE:$line_num";
    my @fields = split m/:/;
    die "$where: wrong number of fields"
      if @fields != 2;

    my ($xmltv_id, $tvtoday_id) = @fields;
    warn "$where: tvtoday id $tvtoday_id seen already\n"
      if defined $chid_mapping{$tvtoday_id};
    $chid_mapping{$tvtoday_id} = $xmltv_id;
    warn "$where: XMLTV id $xmltv_id seen already\n"
      if $seen{$xmltv_id}++;
}

my @requests;

#-- read our configuration file now
my $line = 1;
foreach(@config_lines) {
    $line ++;
    next unless defined;

    if (/^channel:?\s+(\S+)/) {
        warn("\nConfigured channel $1 not available anymore. \nPlease reconfigure tv_grab_de_tvtoday.\n"),
        next unless(defined($channels{$1}));
        push @requests, $1;
    }
    elsif (/^map:?\s+(\S+)\s+(\S+)/) {
        # Override anything set in the channel_ids file.
        $chid_mapping{$1} = $2;
    }
    else {
        warn "$config_file:$line: bad line\n";
    }
}



#-- if we're requested to do so, write out a new config file ...
if ($mode eq 'configure') {
    open(CONFIG, ">$config_file") or die("cannot write to $config_file, due to: $!");

    #-- now let's annoy the user, sorry, I meant ask ..
    my @chs = sort keys %channels;
    my @names = map { $channels{$_} } @chs;
    my @qs = map { "add channel $_?" } @names;
    my @want = ask_many_boolean(1, @qs);

    foreach (@chs) {
        my $w = shift @want;
        my $chname = shift @names;

        warn("cannot read input, stopping to ask questions ..."), last if not defined $w;

        print CONFIG '#' if not $w; #- comment line out if user answer 'no'

        # shall we store the display name in the config file?
        # leave it in, since it probably makes it a lot easier for the
        # user to choose which channel to comment/uncommet - when manually
        # viing the config file -- are there people who do that?
        print CONFIG "channel $_ #$chname\n";
    }

    close CONFIG or warn "unable to nicely close the config file: $!";
    say("Finished configuration.");

    exit();
}



#-- well, we don't have to write a config file, so, probably it's some xml stuff :)
#-- if not, let's go dying ...
die unless($mode eq 'grab' or $mode eq 'list-channels');

my %writer_args;
if (defined $opt_output) {
    my $handle = new IO::File(">$opt_output");
    die "cannot write to output file, $opt_output: $!" unless (defined $handle);
    $writer_args{'OUTPUT'} = $handle;
}

$writer_args{'encoding'} = 'ISO-8859-1';

if( defined( $opt_days ) ) {
  $writer_args{offset} = $opt_offset;
  $writer_args{days} = $opt_days+1;   ## add +1, because tvtoday contains program: 06h(1st day)-05h(2nd day)
  $writer_args{cutoff} = "000000";
}

#-- create our writer object
my $writer = new XMLTV::Writer(%writer_args);
$writer->start($head);

if ($mode eq 'list-channels') {
    foreach (keys %channels) {
        my %channel = ('id'           => channel_id($_),
                       'display-name' => [[$channels{$_}, $lang]]);
        $channel{'icon'} = [{'src' => "http://www.tvtoday.de" . $icons{$_}}]
          if(defined($icons{$_}));
        $writer->write_channel(\%channel);
    }

    $writer->end();
    exit();
}



#-- there's only one thing, why we might exist: write out tvdata!
die unless ($mode eq 'grab');
die "No channels specified, run me with --configure flag\n" unless(scalar(@requests));

#--  We need to wait with writing the channels, therefore buffer the program-infos
my @writebuffer;

#-- get <programme> tags
my $numdays = $opt_days + $opt_offset - 1;

$bar = new XMLTV::ProgressBar('grabbing', scalar(@requests) * $opt_days)
  if not $opt_quiet;

foreach my $channel (@requests) {
    for (my $day = $opt_offset; $day <= $numdays; $day ++) {
       grab_data($channel, $day, $day == $numdays);
       update $bar if not $opt_quiet;
       last if $opt_testing;
    }
    last if $opt_testing;
}
$bar->finish() if not $opt_quiet;

#-- write out <channel> tags
foreach(@requests) {
    my $id = channel_id($_);
    my %channel = ('id'           => $id,
                   'display-name' => [[$channels{$_}, $lang]]);
    $channel{'icon'} = [{'src' => "http://www.tvtoday.de" . $icons{$id}}]
      if(defined($icons{$id}));
    $writer->write_channel(\%channel);
}

#-- write out <program> tags
$writer->write_programme($_) foreach(@writebuffer);

#-- hey, looks like we've finished ...
$writer->end();



#-- channel_id($s) :: turn site channel id into an xmltv id
sub channel_id($) {
    for (my $s = shift) {
        $_ = lc(defined($chid_mapping{$_}) ? $chid_mapping{$_} : "$_.tvtoday.de");
        $_ = "C$_" if /^\d/;
        return $_;
    }
}

#-- grab_data($ch, $offset, $lday) :: grab the tvdata of one channel for one specific day
sub grab_data($$$) {
    my $ch = shift @_;      #- station id of the channel to grab (without the .tvtoday.de suffix)
    my $offset = shift @_;  #- offset we should use
    my $lday = shift @_;    #- true: last day to grab in row

    ## set date
    my ($sec,$min,$hour,$day,$month,$year) = localtime(time);  ## today
    ($sec,$min,$hour,$day,$month,$year) = localtime(Date_SecsSince1970($month+1,$day,$year+1900,0,0,0)+($offset*86400));
    my $myday =  $day.'.'.($month+1).'.'.($year+1900);
    #my $myday =  '3.4.'.($year+1900);

    my $grab = {
        'channel'      => channel_id($ch),
        'channel_id'   => $ch,
        'channel_name' => $channels{$ch},
        'url'          => "http://www.tvtoday.de/program2007?channelId=$ch&slotIndex=all&format=standard&date=$myday",
        'lasttime'     => 0,
        'lastday'      => $lday,
        'myday'        => $myday
    };

    while (defined($grab->{url})) {
        my $tb = HTML::TreeBuilder->new();
        my $htmldata = get_page($grab->{url});

        die "successful grab of $grab->{url} required, stopping here."
            unless(defined($htmldata));

        $tb->parse($htmldata) or die "cannot parse content of $grab->{url}\n";
        $tb->eof;
        parse_page($tb, $grab);
        $tb->delete();
    }
}

sub convert_cp1252_chars {
    $_ = shift;

    s/\204/"/g;         # Double Low-9 Quotation Mark
    s/\205/.../g;       # Horizontal Ellipsis
    s/\221/`/g;         # Left Single Quotation Mark
    s/\222/'/g;         # Right Single Quotation Mark
    s/\223/"/g;         # Left Double Quotation Mark
    s/\224/"/g;         # Right Double Quotation Mark
    s/\225/*/g;         # Bullet
    s/\226/-/g;         # En Dash
    s/\227/-/g;         # Em Dash
    return $_;
}

sub strip_tags {
    $_ = shift;

    s/-\s*<wbr\s*\/?>([a-z])/$1/gs;                    ## Auslands-<wbr/>magazin => Auslandsmagazin
    s/<.*?>//g;                                        ## remove other tags
    return $_;
}

sub trim {
    $_ = shift;

    return $_ if !$_;
    s/^\s+//gs;         ## whitespaces from begin of the string
    s/\s+$//gs;         ## whitespaces from end of the string
    return $_;
}

sub clean_up_str {
    $_ = strip_tags(convert_cp1252_chars(shift));
    s/&shy;//g;
    $_ = trim(decode_entities($_));
    s/[,;]+$//g;
    return $_;
}

sub get_unix_time {
    my ($time,$myday) = @_;
    my $day;
    if ($myday =~ /([1-3]?[0-9])\.(1?[0-9])\.(20[0-9]{2})/) {
        $day = ParseDate("$3-$2-$1 00:00:00");
    } else {
        return 0;
    }
    $time = parse_local_date(DateCalc($day, "+ $time seconds"), $TZ);
    my ($time_base, $time_tz) = @{date_to_local($time, $TZ)};
    return UnixDate($time_base, '%q') . " $time_tz"
}

# example: Silvester Stalone (Rocky) => Silvester Stalone
sub remove_role {
    $_ = shift;
    s/\(.*\)//is;
    return $_;
}

sub parse_page($$) {
    my $page = shift(@_);
    my $grab = shift @_;
    my $over_headline_table = 0;
    my $pos;
    my $day;

    #-- well, now let's scan the table for programme data
    ##
    foreach ($page->look_down('_tag' => 'tr')) {

        # get only rows with relevant content
        next if !defined($_->attr('class'));
        next if $_->attr('class') !~/^slot_([012345])$/;

        my @el = $_->content_list();
        die('no tr') unless(ref($el[0]) eq "HTML::Element" and $el[0]->tag eq "td");

        ## first td (el[0]) is our channel
        foreach my $show ($el[0]->look_down('_tag' => 'div')) {
            next if (!defined($show->attr('class')) || $show->attr('class') ne 'broadcast');

            my %show = ();
            foreach my $time_tmp ($show->look_down('_tag' => 'span')) {
                next if !defined($time_tmp->attr('class')) || $time_tmp->attr('class') ne 'tv-sendung-uhrzeit';
                if ($time_tmp->as_text() =~/([0-2][0-9])\.([0-5][0-9])/) {
                    my $begintime = $1 * 3600 + $2 * 60;
                    $begintime += 86400 if($begintime < $grab->{'lasttime'});
                    $grab->{'lasttime'} = $begintime;
                    $show{"start"} = get_unix_time($begintime,$grab->{myday});
                    last;
                }
            }

            ## "premiere" only for movies
            ## tv_today uses the same img for news because new are always "premiere" :-)
            my $movie = $show->look_down('_tag' => 'img', 'alt' => 'FILM');
            if ($movie && $show->look_down('_tag' => 'img', 'alt' => 'NEU')) {
                $show{'premiere'} = [];
            }

            ## LIVE (not used at the moment), I put in in sub-title
            my $live = '';
            if ($show->look_down('_tag' => 'img', 'alt' => 'LIVE')) {
                #$show{'live'} = 1;
                $live = 'LIVE: ';
            }

            ## star-ratings
            foreach my $stars ($show->look_down('_tag' => 'img')) {
                next if !defined($stars->attr('alt'));
                if ($stars->attr('alt') =~/^([0123])\s+Boller$/) {
                    $show{'star-rating'} = [ $1.'/3' ];
                }
            }

            foreach my $show_tmp ($show->look_down('_tag' => 'td')) {
                next if (!defined($show_tmp->attr('class')) || $show_tmp->attr('class') ne 'tv-sendung-info');
                my $sub_title; ## not subtitle but name of the episode

                my @show_details = $show_tmp->content_list();
                die("no a") unless ($show_details[0]->tag eq 'a');

                ## title
                my $title = clean_up_str($show_details[0]->as_HTML());
                $show{'title'} = [[ $title , $lang ]];

                ## sub-title, country, year
                if ($show_tmp->as_HTML() =~/<a.*?\/a>(.*?)<\/td>/gis) {
                    my @info = ();
                    my @orig_info = map { trim(clean_up_str($_)); push @info, $_ if length($_)>0 && $_ !~/^\s+$/ } (split /<br\s*\/>/, $1);

                    ## if info contains 3 lines after title:
                    #-- 1st line: subtitle (episode name)
                    #-- 2nd line: category
                    #-- 3rd line: country + year
                    if ($#{info} == 2
                        ## if 2nd line is matching country and/or year
                        && (
                          ## country + year, i.e.: USA 1999 or USA/GB 1999/2000
                          (my @country_year = ($info[2] =~ /^([A-Z]{1,5}(\/[A-Z]{1,5})*)\s*((19|20)[0-9]{2})([-\/](19|20)?[0-9]{2})?$/s)) ||
                          ## just year, i.e.: 1999 or 1999/2000
                          (my @year = ($info[2] =~ /^((19|20)[0-9]{2})([-\/](19|20)?[0-9]{2})?$/s))
                        )
                        ## and category is matching and contains no whitespaces
                        && ($info[1] =~ m/$category_regexp/o && $info[1] !~/\s+/)
                    ) {
                        ## set country, year
                        if (@country_year) {
                            $show{"country"} = [[ trim($country_year[0]), $lang ]] if $country_year[0];
                            $show{"date"}    = parse_date_data($country_year[2]) if $country_year[2];
                        } else {
                            $show{"date"}    = parse_date_data($year[0]) if $year[0];
                        }
                        $show{"category"} = [[ $info[1], $lang ]] if length($info[1]) > 0;
                        $sub_title = $info[0];

                    } else {
                        foreach my $str (@info) {
                            if ($str =~ m/$category_regexp/o && $str !~/\s+/) {
                                $show{"category"} = [[ $str, $lang ]] if $str;
                            } elsif ($str =~ /^([A-Z]{1,5}(\/[A-Z]{1,5})*)\s*((19|20)[0-9]{2})([-\/](19|20)?[0-9]{2})?$/s) {
                                $show{"country"} = [[ $1, $lang ]] if $1;
                                $show{"date"}    = parse_date_data($3) if $3;
                            } elsif ($str =~ /^((19|20)[0-9]{2})([-\/](19|20)?[0-9]{2})?$/s) {
                                $show{"date"}    = parse_date_data($1) if $1;
                            } elsif ($str =~ /^([A-Z]{1,5}(\/[A-Z]{1,5})*)$/s) {
                                $show{"country"} = [[ $1, $lang ]] if $1;
                            } else {
                                ## put in sub-title everything what is not in category and country/year
                                $sub_title .= $str.', ';
                            }
                        }
                    }
                    if ($live) {
                        $sub_title = $sub_title ? $live.$sub_title : $live;
                    }
                    $show{"sub-title"} = [[ clean_up_str($sub_title), $lang ]] if $sub_title && length($sub_title) > 0;
                }

                ## more details from popup
                if ($opt_slow && $show_details[0]->attr('href') &&
                    $show_details[0]->attr('href') =~/detailPopup\(\'(\d+)\'\)/) {

                    my $popup = "http://www.tvtoday.de/program2007?format=detail&sid=$1";
                    read_popup($popup, \%show, $grab->{channel_name});
                    refine_credits(\%show);

                    if ($show{"stop"} && $show{stop} =~/^([0-9]{2})\.([0-9]{2})$/) {
                        my $endtime = $1 * 3600 + $2 * 60;
                        $endtime += 86400 if($endtime < $grab->{'lasttime'});
                        $show{"stop"} = get_unix_time($endtime,$grab->{myday});
                    }
                }

                ## try to set an alternative category
                if (!$show{"category"}) {
                    ## eurosport: sport
                    ## premiere sport: sport
                    if ($grab->{channel_id} =~ /^(EURO|PSPO1)$/i) {
                        $show{"category"} = [[ 'Sport', $lang ]];

                    } elsif ($grab->{channel_id} =~ /^(DSF)$/i) {

                        ## erotic clips on DSF
                        if ($title =~ /erotik/ || $sub_title =~ /erotik/i) {
                            $show{"category"} = [[ 'Erotik', $lang ]];
                        } elsif ($title =~ /(dauer)?werbe-?sendung/ || $sub_title =~ /(dauer)?werbe-?sendung/i) {
                            $show{"category"} = [[ 'Werbung', $lang ]];
                        } else {
                            $show{"category"} = [[ 'Sport', $lang ]];
                        }
                    }
                }

                ## add other alternative categories
                my @new_categories = ();
                my ($serie, $magazin,$dokumentation,$reportage);

                if (defined($show{"category"})) {
                    ## check existance to avoid doubling
                    for (my $i=0; $i<=$#{$show{"category"}}; $i++) {
                        $serie         = 1 if $show{"category"}[$i][0] =~/^Serie$/i;
                        $magazin       = 1 if $show{"category"}[$i][0] =~/^Magazin$/i;
                        $dokumentation = 1 if $show{"category"}[$i][0] =~/^Dokumentation$/i;
                        $reportage     = 1 if $show{"category"}[$i][0] =~/^Reportage$/i;
                    }
                    for (my $i=0; $i<=$#{$show{"category"}}; $i++) {
                        ## Serie
                        if (!$serie && $show{"category"}[$i][0] =~/serie/i) {
                            push @new_categories, [ 'Series', $lang ];
                            $serie = 1;
                        }
                        ## Magazin
                        if (!$magazin && $show{"category"}[$i][0] =~/magazin/i) {
                            push @new_categories, [ 'Magazin', $lang ];
                            $magazin = 1;
                        }
                        ## Dokumentation
                        if (!$dokumentation && $show{"category"}[$i][0] =~/^(.*-?)?[Dd]oku(reihe|mentation|-\w)?$/) {
                            push @new_categories, [ 'Dokumentation', $lang ];
                            $dokumentation = 1;
                        }
                        ## Reportage
                        if (!$reportage && $show{"category"}[$i][0] =~/reportage/) {
                            push @new_categories, [ 'Reportage', $lang ];
                            $reportage = 1;
                        }
                    }
                }
                ## movies are already marked on the main page
                push @new_categories, [ 'Film', $lang ] if $movie;
                map { push @{$show{"category"}}, $_ } @new_categories;
            }

            ##-- okay, commit that data now ...
            $show{"channel"} = $grab->{channel};
            push @writebuffer, \%show;
        }
    }

    undef($grab->{url});
    return;
}

#-- read_popup($url, %$show) -- read the popup file and add the retrieved data into the %show hash
my $warned_discarding_two_channel = 0;
sub read_popup($$$) {
    my $tb = HTML::TreeBuilder->new();
    my $url = shift;
    my $show = shift;
    my $channel_name = shift;
    my $htmldata = get_page($url);

    return unless(defined($htmldata));
    $tb->parse($htmldata) or die "cannot parse content of $url\n";
    $tb->eof;

    my $desc_status = 0;
    ## short description.
    my $short_desc = $tb->look_down('_tag' => 'span', 'class' => 'tv-sendung-info');
    if ($short_desc) {
        my $desc = clean_up_str($short_desc->as_text);
        if (length($desc)>0) {
            $show->{"desc"} = [[ $desc , $lang ]];
            $desc_status = 1;
        }

    ## if missing, check for "tv-vorspann-popup"
    } else {
        $short_desc = $tb->look_down('_tag' => 'span', 'class' => 'tv-vorspann-popup');
        my $desc = clean_up_str($short_desc->as_text);
        if (length($desc)>0) {
            $show->{"desc"} = [[ $desc , $lang ]];
            $desc_status = 2;
        }
    }

    foreach my $desc_td ($tb->look_down('_tag' => 'td', 'class' => 'tv-sendung-info')) {
        if ($desc_td->as_HTML =~/^<td.*?>(.*?)?\s*<br.*?>\s*&gt;\s*([0-9]{2}\.[0-9]{2})(.*)?\s*<\/td>$/gis) {

            ## replace the short description with a longer one (or show summary) if --slow
            ## replace it only if there is no description or description eq subtitle
            if (length($1) && ($desc_status == 0 || (defined($show->{"sub-title"}) && $show->{"desc"}[0][0] eq $show->{"sub-title"}[0][0]))) {
                $show->{"desc"} = [[ clean_up_str($1) , $lang ]];
            }
            if (length($2)) {
                $show->{"stop"} = $2;  ## stop time: converted to date/time in parse_page()
            }

            ## show length
            if (length($3)) {
                my $add_info = $3;
                ## 43/45 Min. or 45 Min.. if "43/45 Min.", I take the 1st number as length
                if ($add_info =~ /\s*((([\d]{1,3})\/)?[\d]{1,3})(\s+Min\.)\s*/gi) {
                    if ($3) {
                        next if (!$3 || $3 > 300) && $channel_name =~/^Premiere/i;    ## if Premiere minutes displayed wrong
                        $show->{"length"} = $3*60;  ## xmltv converts these seconds to minutes or hours
                    } else {
                        next if (!$1 || $1 > 300) && $channel_name =~/^Premiere/i;   ## if Premiere minutes often displayed wrong
                        $show->{"length"} = $1*60;  ## xmltv converts these seconds to minutes or hours
                    }
                }
                ## showview number
                if ($add_info =~ /\s*([0-9\-]+)\s*/gi) {
                    $show->{"showview"} = $1 unless($1 eq "99-999-999");
                }
            }
        } elsif ($desc_td->as_text =~/^\s*((O:)?\s*(.*?))?\s*(R:\s*(.*?))\s*(D:\s*(.*?))\s*$/gis) {
            ## director(s)
            if ($4) {
                add_credits($show, 'director', (map { clean_up_str($_) } (split /;/, $5)));
            }
            ## actors
            if ($6) {
                add_credits($show, 'actor', ( map { clean_up_str(remove_role($_)) } (split /;/, $7)));
            }
            ## original name, country, year
            if ($1) {
                ## country year: "F 1992", "F/D 1999" or "GB/D or 1999/2000" or "F 2001/02"
                if ($3 =~/\s+([A-Z]+(\/[A-Z]+)*)\s+((19|20)[0-9]{2})(\/(19|20)?[0-9]{2})?(\s*|;)/s) {
                    $show->{"country"} = [[ $1, $lang ]] if $1;
                    $show->{"date"}    = parse_date_data($3) if $3;
                }
            }
        } elsif ($desc_td->as_text =~/\s+([A-Z]+(\/[A-Z])*)\s+((19|20)[0-9]{2})(\/(19|20)?[0-9]{2})?(\s*|;|<)/s) {
            $show->{"country"} = [[ $1, $lang ]] if !$show->{"country"};
            $show->{"date"} = parse_date_data($3) if !$show->{"date"} && $3;
        }
    }

    ## genre
    my $genre = $tb->look_down('_tag' => 'span', 'class' => 'tv-auszeichnung');
    if ($genre && $genre->as_text() =~ m/$category_regexp/o) {
        $show->{"category"} = [[ $genre->as_text(), $lang ]];
    }

    ## defaults: are there really any mono shows?
    $show->{"video"} = { present => 1, colour => 1 };
    $show->{"audio"} = { present => 1, stereo => "mono" };

    foreach my $desc_img ($tb->look_down('_tag' => 'img')) {
        next if !$desc_img->attr('alt');
        my $desc_img_name = $desc_img->attr('alt');

        if ($desc_img->attr('src') =~/sz_zk.gif$/) {
        #    $show->{"audio"}->{"multichannel"} = 1;
            warn "discarding two-channel sound flag" unless $warned_discarding_two_channel++;
            next;
        }

        if ($desc_img_name =~/Stereo/i) {
            $show->{"audio"}->{"stereo"} = "stereo";
        } elsif ($desc_img_name =~/^Surround$/i) {
            $show->{"audio"}->{"stereo"} = "surround";

        } elsif ($desc_img_name =~/^Breitbild$/i) {
            $show->{"video"}->{"aspect"} = "16:9";

        } elsif ($desc_img_name =~/^Schwarzwei(ss|ß)$/i) {
            $show->{"video"}->{"colour"} = 0;

        } elsif ($desc_img_name =~/^Untertitel$/i) {
            $show->{"subtitles"} = [{ type => 'teletext' }];

        ## ignore it here because we already set it in parse_page much securely
        #} elsif ($desc_img_name =~/^Neu$/i) {
        #    $show->{"premiere"} = [];

        #} elsif ($desc_img_name =~/Verschlüsselt/i) {
        #    $show->{"encoded"} = 1;

        } else {
            next;
        }
    }

    $tb->delete();
}

#-- add_credits(%$show, $credit, @people) -- add names to a <credits>
# subelement but only if they are not already there.
#
# Assumption: nothing is removing from credits lists.
#
sub add_credits($$@) {
    my ($show, $credit, @people) = @_;
    my %seen;
    foreach (@{$show->{credits}->{$credit}}) { $seen{$_}++ }
    push @{$show->{credits}->{$credit}},
      grep { not $seen{$_}++ } @people;
}

#-- refine_category_attr(@$desc, %$show) -- refine category attribute of %show
sub refine_category_attr($$) {
    my $desc = shift;
    my $show = shift;

    #-- refining category attributes ...
    return if not exists $show->{"category"};
    foreach (@{$show->{"category"}}) {
        die if not defined($_->[0]);
        $_->[0] =~ s/(^\s|\s$)//g;

        if($_->[0] =~ s/\s+(?:frei\s+)?(nach|von|mit)\s+([^\d]*?)\s*$//) {
            my @data = split(m/(?:\sund\s|[,;])/, $2);

            if ($1 eq "nach") { push @{$show->{"credits"}{"writer"}}, @data; }
            elsif ($1 eq "von") { push @{$show->{"credits"}{"producer"}}, @data; }
            elsif ($1 eq "mit") { push @{$show->{"credits"}{"presenter"}}, @data; }
            else { die }
        }

        if($_->[0] =~ s/\s*(\d+\. Staffel)\s*//) {
            #-- really doesn't belong into category, throw out to description
            push @$desc, $1;
        }

        #-- okay, the last word should be the actual category now,
        #   discard everything else back to description
        if($_->[0] =~ s/^\s*(.*?\s+)(?=[\wäöüßÄÖÜ\-\/]+\s*$)//) {
            push @$desc, "$1$_->[0]";
        }

        #-- discard whole entry if we don't have any text left ...
        $_->[0] =~ s/(^\s|\s$)//g;
        undef $_ unless(length($_->[0]));
    }

    # We may have set some category elements to undef, but they
    # shouldn't be left there.
    #
    $show->{"category"} = [ grep { $_ } @{$show->{"category"}} ];


    # DEBUG FEATURE
    # check the stored categories against our list ...
    1 && return;

    foreach (@{$show->{"category"}}) {
        my $title = $show->{"title"}->[0][0];

        warn "show '$title' has invalid category-language tag assigned: $_->[1]"
          unless($_->[1] eq $lang);

        next unless(m/$category_regexp/o);
        warn "show '$title' has strange category assigned: $_->[0]"
          if(length("$1$3"));
    }
}



#-- refine_credits(%$show) -- refine credits listed below %show hash
sub refine_credits($) {
    my $show = shift;

    foreach(keys(%{$show->{"credits"}})) {
        foreach(@{$show->{"credits"}{$_}}) {
            s/(^\s|\s$)//g;

            #-- remove leading articles in front of group's names, e.g. bands etc.
            s/^de[rnm]\s+//g;

            #-- trim leading proffession-names, etc ...
            #-- this is stupidly given with all these faked judgement shows
            #-- (for judges and lawyers who probably even don't have and deserve their title ...)
            s/^(Anwalt|Anwältin|Anwältinen|Richter(in)?)\s+//g;
        }
    }
}



#-- get channel logos
sub get_icons() {
    my %icons;
    my $url="http://programm.tvtoday.de/tv/programm/programm.php?ztag=0&sparte=alle&uhrzeit=Ax00&sender=";
    my $chan;
    my $tag;
    my $addr;

    my $bar = new XMLTV::ProgressBar('grabbing icons', scalar(keys(%channels)))
      if not $opt_quiet;

    foreach (keys %channels) {
        my $tb = new HTML::TreeBuilder();
        my $htmldata = get_page($url.$_);
        next unless(defined($htmldata));
        $tb->parse($htmldata) or die "cannot parse content of $url$_\n";
        $tb->eof;

        $tag = $tb->look_down('_tag' => 'img',
        sub {
            return ($_[0]->attr('src') =~ m/^\/tv\/programm\/bilder\/senderlogos\//);
        });

        update $bar if not $opt_quiet;

        unless(ref($tag) eq "HTML::Element") {
                $tb->delete;
                next;
        };

        $icons{$_} = $tag->attr('src');
        $tb->delete;
    }
    $bar->finish() if not $opt_quiet;

    return %icons;
}



#-- get channel listing
sub get_channels() {
    my %channels;
    my $url="http://www.tvtoday.de/program2007";

    my $tb=new HTML::TreeBuilder();
    my $htmldata = get_page($url);

    die "successful grab of $url required, stopping here."
    unless(defined($htmldata));

    $tb->parse($htmldata) or die "cannot parse content of $url\n";
    $tb->eof;
    foreach ($tb->look_down('_tag' => 'select', 'name' => 'channelId')->content_list()) {
        next unless(ref($_) eq "HTML::Element");
        warn "unexpected HTML::Element $_->tag", next if($_->tag ne "option");
        next if ($_->attr("value") !~ /^[A-Z0-9]{2,}$/);

        my $station_name = $_->as_text();
        $station_name =~ s/(?:^\s|\s$)//g;
        $channels{uri_escape($_->attr("value"))} = $station_name;
    }

    return %channels;
}


#-- split_up_names($names, %$show) :: Split up names into returned array
sub split_up_names($$) {
    my $names = shift;
    my $show = shift;

    $names =~ s/, unter Mitwirkung von\s+/ und /g; #- replace 'with help of' by simple and to allow match below
    my @data = split(m/\s*[,;]\s*/, $names);

    if(scalar(@data) == 2) {
        #-- check for "<name(s)>, <country> <year>" construct
        if($data[1] =~ m/\s*([^,;]*)\s+([12][09][0-9]{2}(?:[\/-][0-9]{2})?)\s*$/) {
            $show->{"country"} = [[ $1, $lang ]];
            $show->{"date"} = parse_date_data($2);

            $#data --;
            $names = $data[0];

        } elsif(scalar($data[1] =~ m/\s/g) == 0) {
            #- we most probably have a country specification
            #- here, treat it as such, ... and hope it's right
            $show->{"country"} = [[ $data[1], $lang ]];

            $#data --;
            $names = $data[0];
        }
    }

    if(scalar(@data) == 1 && $names =~ m/\s+und\s+/) {
    # looks like it didn't work, try splitting by 'und' (== and)
    @data = split(m/\s+und\s+/, $names);

    #-- check that we didn't have a "hername + hisname familyname or name + name" construct ...
    if(scalar(@data) == 2) {
        @data = $names #-- ignore split in that case
          if (scalar($data[0] =~ m/\s/g) == 0 && scalar($data[1] =~ m/\s/g) <= 1);
    }
    }

    return @data;
}


#-- parse_date_data($d) :: Parse the given "yyyy([-/]yy)?" date down to "yyyy" only
sub parse_date_data($) {
    my $date = shift;
    warn("bad date '$date' found, returning undef."), return(undef)
      unless($date =~ m/((?:19|20)[0-9]{2})(?:(?:[-\/])([0-9]{2}))?/);

    #-- return if it's a plain 'yyyy' date ...
    return $date unless(defined($2));

    my $century = substr($date, 0, 2);
    if(substr($date, 2, 2) > $2) {
    warn("bad date '$date' found, returning undef."), return(undef)
      unless($century == 19);
    $century ++;
    }

    return $century * 100 + $2;
}



#-- get_page($url) :: try to download $url via http://, look for closing </body> tag or die
sub get_page($) {
    my $url = shift;
    my $retry = 0;

    local $SIG{__DIE__} = sub { die "\n$url: $_[0]" };
    #print STDERR "get_page: $url\n";

    while($retry < 2) {
        my $got = eval { get_nice($url . ($retry ? "&retry=$retry" : "")); };
        $retry ++;

        next if($@); # unable to download, doesn't look too good for us.

        die "retrieved webpage doesn't look like a tvtoday.de page, maybe a proxy error?"
          unless(index($got, "<title>TV TODAY</title>"));

        #-- page seems to be complete, if we have a </body> tag ...
        return $got unless(index($got, "</body>") < 0);

        #-- be nice to our server, let's wait extra ...
        sleep(rand($retry * 5)) unless($debug);
        warn "got incomplete webpage from tvtoday.de" if($debug);
    }

    warn "cannot grab webpage $url, giving up after trying $retry times";
    return undef;
}