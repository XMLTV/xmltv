#!/usr/bin/perl

=pod

=head1 NAME

tv_grab_de_tvtoday - Grab TV listings for Germany (from www.tvtoday.de webpage).

=head1 SYNOPSIS

tv_grab_de_tvtoday --help

tv_grab_de_tvtoday [--config-file FILE] --configure [--gui OPTION]

tv_grab_de_tvtoday [--config-file FILE] [--output FILE]
                   [--days N] [--offset N]
                   [--quiet] [--slow] [--nosqueezeout]

tv_grab_de_tvtoday --list-channels [--icons]

tv_grab_de_tvtoday --capabilities

tv_grab_de_tvtoday --version

=head1 DESCRIPTION

Output TV listings for several channels available in Germany.
The data comes from www.tvtoday.de which is the webpage of one of
the most popular TV magazines in Germany. The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_de_tvtoday --configure> to choose, which channels
you want to download. Then running B<tv_grab_de_tvtoday> with no
arguments will output listings in XML format to standard output.

B<--configure> Ask for each available channel whether to download
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_de_tvtoday.conf>.  This is the file
written by B<--configure> and read when grabbing.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of Term::ProgressBar.

B<--output FILE> Write to FILE rather than standard output.

B<--days N> Grab N days.  The default is seven.

B<--offset N> Start N days in the future.  The default is to start
from today (= zero). Set to -1 to grab data beginning yesterday.

B<--quiet> Suppress the progress messages normally written to standard
error.

B<--slow> enables long strategy run: tvtoday.de publishes only some (vital)
information on the actual listing pages, the rest is shown in a separate
popup window. If you'd like to parse the data from these popups as well,
supply this flag. But consider that the grab process takes much longer when
doing so, since many more web pages have to be retrieved.

B<--nosqueezeout> Disables aggressive squeeze out of information field from
the index pages. If specified, the program description from tvtoday.de is
passed trough as data of the desc-tag, otherwise the data is parsed for
information about actors, director, etc. and understood data gets returned in
it's corresponding field.

B<--list-channels> Write output giving <channel> elements for every
channel available (ignoring the config file), but no programmes.

B<--icons> Get the URL for channel-logos together with the channel-list.
Mind that this takes a long time, since a webpage has to be requested for
every channel.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://membled.com/twiki/bin/view/Main/XmltvCapabilities>

B<--version> Show the version of the grabber.

B<--help> Print a help message and exit.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Stefan Siegl, stesie@brokenpipe.de. Inspired by tv_grab_fi by Matti Airas.
Modified for new tv_today design by Mirza Muharemagic <derliebegott@gmail.com>

=head1 BUGS

If you happen to find a bug, you're requested to send a mail to me
at B<stesie@brokenpipe.de> or to one of the XMLTV mailing lists, see webpages
at http://sourceforge.net/projects/xmltv/.

=cut

use warnings;
use strict;
use XMLTV::Version '$Id$ ';
use XMLTV::Capabilities qw/baseline manualconfig cache share/;
use XMLTV::Description 'Germany (www.tvtoday.de)';
use Date::Manip;
use Getopt::Long;
use HTML::TreeBuilder;
use HTML::Entities;
use URI::Escape;
use XMLTV;
use XMLTV::Ask;
use XMLTV::ProgressBar;
use XMLTV::DST;
use XMLTV::Config_file;
use XMLTV::Mode;
use XMLTV::Get_nice;
use XMLTV::Memoize;
use XMLTV::Usage <<END
$0: get German television listings from www.tvtoday.de in XMLTV format
To configure: $0 --configure [--config-file FILE] [--gui OPTION]
To grab data: $0 [--config-file FILE] [--output FILE]
                 [--days N] [--offset N]
                 [--quiet] [--slow] [--nosqueezeout]
Channel List: $0 --list-channels [--icons]
To show capabilities: $0 --capabilities
To show version: $0 --version

END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
        *t = sub {};
        *d = sub { '' };
    }
    else {
        *t = \&Log::TraceMessages::t;
        *d = \&Log::TraceMessages::d;
    #$Log::TraceMessages::On = 1;
    }
}

#-- our own prototypes first ...
sub grab_data($$$);
sub squeeze_out_desc($$);
sub refine_category_attr($$);
sub get_channels();
sub get_icons();
sub channel_id($);
sub split_up_names($$);
sub parse_date_data($);
sub get_page($);
sub add_credits($$@);
sub parse_page($$);
sub read_popup($$);
sub refine_credits($);

#-- Category-Matching RegExp
our constant $category_regexp = '^(.*?\s+)?((?:[\wï¿½ï¿½ï¿½-]+-?)?(?:[Aa]genten|[Aa]benteuer|[Aa]ction|[Aa]usland(s-?)?|[Bb]oulevard|[Cc]all-[Ii]n|[Cc]harts|[Cc]omedy|[Dd]etektiv|[Dd]oku(?:mentar|mentation)?|Daily[\s+\-][Ss]oap|[Dd]rama|[Ee]rotik|Episoden?|[Dd]rama|[Ee]rmittler|[Ff]amilien|[Gg]erichts|[Gg]esundheits?|[Jj]ournal|[Kk]rimi|[Kk]omÃ¶die|[Kk]ultur|[Ll]iteratur|[Ll]ifestyle|[Mm]agazin|[Mm]elodram|[Mm]istery|[Mm]usik|[Nn]achrichten|[Pp]olit(ik)?|[Pp]ortrÃ¤t|[Qq]uiz|[Rr]e(gion(al)|ligions?)|[Rr]eportage|[Rr]eihe|[Ss]oap|[Ss]atire|[Ss]erie|[Ss]piel|[Ss]tudie|[Tt]alk|[Tt]ier|[Tt]hriller|[Ww]erbsendung|[Ww]unschclip|[Gg]esprï¿½h|[Tt]elenovela|[Tt]eleshopping|[Ww]isssens?(schafts?)?|[Zz]eichentrick|[Aa]nimation|[Kk]ultur|[Bb]ericht|[Ww]etter|[Ww]estern)\-?(?:[Ff]ilm|[Mm]ovie|[Dd]oku(mentation)?|[Bb]ericht|[Ii]nfos|[Jj]ournal|[Ss]how|[Ss]endung|[Ss]erie|[Ss]oap|[Mm]agazin|[Tt]alk|[Rr]eport(age)?|[Re]eihe)?s?)([\s;,]+.*)?$';

#-- DEBUG FLUFF ...
my $debug = 0;
$XMLTV::Get_nice::Delay = 0 if($debug);

#-- attributes of xmltv root element
my $head = {
    'source-data-url' => 'http://programm.tvtoday.de/tv/programm/programm.php',
    'source-info-url' => 'http://www.tvtoday.de/',
    'generator-info-name'  => 'XMLTV',
    'generator-info-url'   => 'http://membled.com/work/apps/xmltv/',
};

#-- the timezone tvtoday.de lives in is, CET/CEST
my constant $TZ = "+0100";
my constant $lang = "de";

#-- Parse argv now.  First do undocumented --cache option.
XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');

my $opt_configure;
my $opt_config_file;
my $opt_gui;
my $opt_output;
my $opt_days;
my $opt_offset = 0;
my $opt_quiet = 0;
my $opt_slow = 0;
my $opt_nosqueeze = 0;
my $opt_list_channels;
my $opt_icons = 0;
my $opt_help;
my $opt_share;

GetOptions(
    'configure'      => \$opt_configure,
    'config-file=s'  => \$opt_config_file,
    'gui:s'          => \$opt_gui,
    'output=s'       => \$opt_output,
    'days=i'         => \$opt_days,
    'offset=i'       => \$opt_offset,
    'quiet'          => \$opt_quiet,
    'slow'           => \$opt_slow,
    'nosqueezeout'   => \$opt_nosqueeze,
    'list-channels'  => \$opt_list_channels,
    'icons'          => \$opt_icons,
    'help'           => \$opt_help,
    'share=s'        => \$opt_share,
) or usage(0);

usage(1) if $opt_help;

## Disabled at the moment, because not usable at the moment in this test version
die "Option '--nosqueezeout'  is disabled in this version. Use '--slow' if you want detailed program"
  if $opt_nosqueeze;

XMLTV::Ask::init($opt_gui);

#-- make sure offset+days arguments are within range
die "offset mustn't be larger than seven"
  if($opt_offset > 7);

warn "cannot fetch data before yesterday, starting yesterday", $opt_offset = -1
  if($opt_offset < -1);
$opt_days = 8 - $opt_offset unless (defined($opt_days));

die "fetching more than 8 days isn't possible, check offset+days arguments"
  if($opt_days + $opt_offset > 8);

#-- offset and days should be valid now, let's go on ...



my $mode = XMLTV::Mode::mode('grab', # default value
    $opt_configure     => 'configure',
    $opt_list_channels => 'list-channels',
);



#-- initialize config file support
my $config_file = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_de_tvtoday', $opt_quiet);
my @config_lines;

if($mode eq 'configure') {
    XMLTV::Config_file::check_no_overwrite($config_file);
}
elsif($mode eq 'grab' || $mode eq 'list-channels') {
    @config_lines = XMLTV::Config_file::read_lines($config_file);
}
else { die("never heard of XMLTV mode $mode, sorry :-(") }

my $bar = new XMLTV::ProgressBar( 'getting list of channels', 1 )
    if not $opt_quiet;

#-- hey, we can't live without channel data, so let's get that now!
my %channels = get_channels();
$bar->update() if not $opt_quiet;
$bar->finish() if not $opt_quiet;

#-- if wanted, get the channel logos (only in list-channels-mode done here!)
my %icons;
%icons = get_icons() if $opt_icons && $opt_list_channels;


# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_de_tvtoday.PL.  But we can
# use the current directory instead of share/tv_grab_de_tvtoday for
# development.
#
# The 'source' file tv_grab_de_tvtoday.in has $SHARE_DIR undef, which
# means use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_de_tvtoday" : '.';

# Read the file with channel mappings.
(my $CHANNEL_NAMES_FILE = "$OUR_SHARE_DIR/channel_ids") =~ tr!/!/!s;
my (%chid_mapping, %seen);
my $line_num = 0;
foreach (XMLTV::Config_file::read_lines($CHANNEL_NAMES_FILE, 1)) {
    ++ $line_num;

    next unless defined;
    my $where = "$CHANNEL_NAMES_FILE:$line_num";
    my @fields = split m/:/;
    die "$where: wrong number of fields"
      if @fields != 2;

    my ($xmltv_id, $tvtoday_id) = @fields;
    warn "$where: tvtoday id $tvtoday_id seen already\n"
      if defined $chid_mapping{$tvtoday_id};
    $chid_mapping{$tvtoday_id} = $xmltv_id;
    warn "$where: XMLTV id $xmltv_id seen already\n"
      if $seen{$xmltv_id}++;
}

my @requests;

#-- read our configuration file now
my $line = 1;
foreach(@config_lines) {
    $line ++;
    next unless defined;

    if (/^channel:?\s+(\S+)/) {
    warn("\nConfigured channel $1 not available anymore. \nPlease reconfigure tv_grab_de_tvtoday.\n"),
      next unless(defined($channels{$1}));
    push @requests, $1;
    }
    elsif (/^map:?\s+(\S+)\s+(\S+)/) {
    # Override anything set in the channel_ids file.
    $chid_mapping{$1} = $2;
    }
    else {
    warn "$config_file:$line: bad line\n";
    }
}



#-- if we're requested to do so, write out a new config file ...
if ($mode eq 'configure') {
    open(CONFIG, ">$config_file") or die("cannot write to $config_file, due to: $!");

    #-- now let's annoy the user, sorry, I meant ask ..
    my @chs = sort keys %channels;
    my @names = map { $channels{$_} } @chs;
    my @qs = map { "add channel $_?" } @names;
    my @want = ask_many_boolean(1, @qs);

    foreach (@chs) {
        my $w = shift @want;
        my $chname = shift @names;

        warn("cannot read input, stopping to ask questions ..."), last if not defined $w;

        print CONFIG '#' if not $w; #- comment line out if user answer 'no'

        # shall we store the display name in the config file?
        # leave it in, since it probably makes it a lot easier for the
        # user to choose which channel to comment/uncommet - when manually
        # viing the config file -- are there people who do that?
        print CONFIG "channel $_ #$chname\n";
    }

    close CONFIG or warn "unable to nicely close the config file: $!";
    say("Finished configuration.");

    exit();
}



#-- well, we don't have to write a config file, so, probably it's some xml stuff :)
#-- if not, let's go dying ...
die unless($mode eq 'grab' or $mode eq 'list-channels');

my %writer_args;
if (defined $opt_output) {
    my $handle = new IO::File(">$opt_output");
    die "cannot write to output file, $opt_output: $!" unless (defined $handle);
    $writer_args{'OUTPUT'} = $handle;
}

$writer_args{'encoding'} = 'ISO-8859-1';

if( defined( $opt_days ) ) {
  $writer_args{offset} = $opt_offset;
  $writer_args{days} = $opt_days+1;   ## add +1, because tvtoday contains program: 06h(1st day)-05h(2nd day)
  $writer_args{cutoff} = "000000";
}

#-- create our writer object
my $writer = new XMLTV::Writer(%writer_args);
$writer->start($head);

if ($mode eq 'list-channels') {
    foreach (keys %channels) {
        my %channel = ('id'           => channel_id($_),
                       'display-name' => [[$channels{$_}, $lang]]);
        $channel{'icon'} = [{'src' => "http://www.tvtoday.de" . $icons{$_}}]
          if(defined($icons{$_}));
        $writer->write_channel(\%channel);
    }

    $writer->end();
    exit();
}



#-- there's only one thing, why we might exist: write out tvdata!
die unless ($mode eq 'grab');
die "No channels specified, run me with --configure flag\n" unless(scalar(@requests));


#--  We need to wait with writing the channels, therefore buffer the program-infos
my @writebuffer;

#-- get <programme> tags
my $numdays = $opt_days + $opt_offset - 1;

$bar = new XMLTV::ProgressBar('grabbing', scalar(@requests) * $opt_days)
  if not $opt_quiet;

foreach my $channel (@requests) {
    for (my $day = $opt_offset; $day <= $numdays; $day ++) {
       grab_data($channel, $day, $day == $numdays);
       update $bar if not $opt_quiet;
    }
    last;
}
$bar->finish()
    if not $opt_quiet;

#-- write out <channel> tags
foreach(@requests) {
    my $id = channel_id($_);
    my %channel = ('id'           => $id,
                   'display-name' => [[$channels{$_}, $lang]]);
    $channel{'icon'} = [{'src' => "http://www.tvtoday.de" . $icons{$id}}]
      if(defined($icons{$id}));
    $writer->write_channel(\%channel);
}

#-- write out <program> tags
$writer->write_programme($_) foreach(@writebuffer);

#-- hey, looks like we've finished ...
$writer->end();



#-- channel_id($s) :: turn site channel id into an xmltv id
sub channel_id($) {
    for (my $s = shift) {
        $_ = lc(defined($chid_mapping{$_}) ? $chid_mapping{$_} : "$_.tvtoday.de");
        $_ = "C$_" if /^\d/;
        return $_;
    }
}

#-- grab_data($ch, $offset, $lday) :: grab the tvdata of one channel for one specific day
sub grab_data($$$) {
    my $ch = shift @_;      #- station id of the channel to grab (without the .tvtoday.de suffix)
    my $offset = shift @_;  #- offset we should use
    my $lday = shift @_;    #- true: last day to grab in row

    ## set date
    my ($sec,$min,$hour,$day,$month,$year) = localtime(time);  ## today
    ($sec,$min,$hour,$day,$month,$year) = localtime(Date_SecsSince1970($month+1,$day,$year+1900,0,0,0)+($offset*86400));
    my $myday =  $day.'.'.($month+1).'.'.($year+1900);#
    my $myday =  '30.'.($month+1).'.'.($year+1900);#

    my $grab = {
        'channel'   => channel_id($ch),
        'url'       => "http://www.tvtoday.de/program2007?channelId=$ch&slotIndex=all&format=standard&date=$myday",
        'lasttime'  => 0,
        'lastday'   => $lday,
        'myday'     => $myday
    };

    while (defined($grab->{url})) {
        my $tb = HTML::TreeBuilder->new();
        my $htmldata = get_page($grab->{url});

        die "successful grab of $grab->{url} required, stopping here."
            unless(defined($htmldata));

        $tb->parse($htmldata) or die "cannot parse content of $grab->{url}\n";
        $tb->eof;
        parse_page($tb, $grab);
        $tb->delete();
    }
}

sub convert_cp1252_chars($) {
    my $str = shift;

    $$str =~ s/\204/"/g;         # Double Low-9 Quotation Mark
    $$str =~ s/\205/.../g;       # Horizontal Ellipsis
    $$str =~ s/\221/`/g;         # Left Single Quotation Mark
    $$str =~ s/\222/'/g;         # Right Single Quotation Mark
    $$str =~ s/\223/"/g;         # Left Double Quotation Mark
    $$str =~ s/\224/"/g;         # Right Double Quotation Mark
    $$str =~ s/\225/*/g;         # Bullet
    $$str =~ s/\226/-/g;         # En Dash
    $$str =~ s/\227/-/g;         # Em Dash

    ## convert html to chars
    $$str =~ s/&auml;/ä/g;         # umlaut a
    $$str =~ s/&Auml;/Ä/g;         # umlaut A
    $$str =~ s/&ouml;/ö/g;         # umlaut o
    $$str =~ s/&Ouml;/Ö/g;         # umlaut O
    $$str =~ s/&uuml;/ü/g;         # umlaut u
    $$str =~ s/&Uuml;/Ü/g;         # umlaut U
    $$str =~ s/&szlig;/ß/g;        # sharp s (german only)
    $$str =~ s/&shy;//g;           # remove "soft hyphen" (appears for no reason on tvtoday.de)

    $$str =~ s/&amp;/&/g;          # ampersand
    $$str =~ s/&#39;/'/g;          # Single Quotation Mark
    $$str =~ s/&#34;/"/g;          # Double Quotation Mark
    $$str =~ s/&copy;/©/g;         # copyright
    $$str =~ s/&reg;/®/g;          # registered whatever
    $$str =~ s/&trade;/?/g,        # trademark
    $$str =~ s/&euro;/?/g;         # Euro

    return $str;
}

sub strip_tags {
    $_ = shift;
    s/^(\w+)-\s*<wbr\s*\/?>\s*([a-z]\w*)/$1$2/gis;    ## Auslands-<wbr/>magazin => Auslandsmagazin
    s/^\s*<wbr\s*\/?>\s*//gis;                        ## Musik-<wbr/>Magazin => Musik-Magazin
    s/<.*?>//g;                                       ## remove other tags
    return $_;
}

sub trim {
    $_ = shift;
    return $_ if !$_;
    s/^\s*//g;         ## begin of the string
    s/\s*$//g;         ## end of the string
    return $_;
}

sub parse_page($$) {
    my $page = shift(@_);
    #$page->dump(); exit 0;
    my $grab = shift @_;
    my $over_headline_table = 0;
    my $pos;
    my $day;

    #-- well, now let's scan the table for programme data
    ##
    foreach ($page->look_down('_tag' => 'tr')) {

        # get only rows with relevant content
        next if !defined($_->attr('class'));
        next if $_->attr('class') !~/^slot_([012345])$/;

        my @el = $_->content_list();
        die('no tr') unless(ref($el[0]) eq "HTML::Element" and $el[0]->tag eq "td");

        ## first td (el[0]) is our channel
        foreach my $show ($el[0]->look_down('_tag' => 'div')) {
            next if (!defined($show->attr('class')) || $show->attr('class') ne 'broadcast');

            my %show = ();
            foreach my $time_tmp ($show->look_down('_tag' => 'span')) {
                next if !defined($time_tmp->attr('class')) || $time_tmp->attr('class') ne 'tv-sendung-uhrzeit';
                if ($time_tmp->as_text() =~/([0-2][0-9])\.([0-5][0-9])/) {
                    my $begintime = $1 * 3600 + $2 * 60;
                    $begintime += 86400 if($begintime < $grab->{'lasttime'});
                    $grab->{'lasttime'} = $begintime;
                    $show{"start"} = get_unix_time($begintime,$grab->{myday});
                    last;
                }
            }

            foreach my $show_tmp ($show->look_down('_tag' => 'td')) {
                next if (!defined($show_tmp->attr('class')) || $show_tmp->attr('class') ne 'tv-sendung-info');

                my @show_details = $show_tmp->content_list();
                die("no a") unless ($show_details[0]->tag eq 'a');
                my $title = $show_details[0]->as_text();
                convert_cp1252_chars(\$title);
                $show{'title'} = [[ trim($title) , $lang ]];

                if ($show_tmp->as_HTML() =~/<a.*?\/a>(.*?)<\/td>/gis) {
                    my $desc;
                    foreach my $str (map { trim($_) } (split /<br\s*\/>/, $1)) {
                        $str = trim(strip_tags($str));
                        $str =~ s/[,;]$//g;
                        next if !length($str);
                        if ($str =~ m/$category_regexp/o && $str !~/\s+/) {
                            $show{"category"} = [[ $str, $lang ]] if $str;
                        } elsif ($str =~ /\s*([A-Z]+(\/[A-Z]+)*)\s*((19|20)[0-9]{2})([-\/](19|20)?[0-9]{2})?(\s*|,|<)/s) {
                            $show{"country"} = [[ trim($1), $lang ]] if $1;
                            $show{"date"}    = parse_date_data($3) if $3;
                        } elsif ($str =~ /\s*((19|20)[0-9]{2})([-\/](19|20)?[0-9]{2})?(\s*|,|<)/s) {
                            $show{"date"}    = parse_date_data($1) if $1;
                        } elsif ($str =~ /\s*([A-Z]+(\/[A-Z]+)*)(\s*|,|<)/s) {
                            $show{"country"} = [[ trim($1), $lang ]] if $1;
                        } else {
                            next if length(trim($str))==0;
                            $desc .= trim($str).', ';
                        }
                    }
                    $desc =~ s/[,;]\s*$//g if $desc;
                    $show{"desc"} = [[ trim($desc), $lang ]] if $desc && length($desc) > 0;
                }

                if ($opt_slow && $show_details[0]->attr('href') &&
                    $show_details[0]->attr('href') =~/detailPopup\(\'(\d+)\'\)/) {

                    my $popup = "http://www.tvtoday.de/program2007?format=detail&sid=$1";
                    read_popup($popup, \%show);
                    refine_credits(\%show);

                    if ($show{"stop"} && $show{stop} =~/^([0-9]{2})\.([0-9]{2})$/) {
                        my $endtime = $1 * 3600 + $2 * 60;
                        $endtime += 86400 if($endtime < $grab->{'lasttime'});
                        $show{"stop"} = get_unix_time($endtime,$grab->{myday});
                    }
                }
            }
            #-- okay, commit that data now ...
            $show{"channel"} = $grab->{channel};
            push @writebuffer, \%show;
        }
    }

    undef($grab->{url});
    return;
}

sub get_unix_time {
    my ($time,$myday) = @_;
    my $day;
    if ($myday =~ /([1-3]?[0-9])\.(1?[0-9])\.(20[0-9]{2})/) {
        $day = ParseDate("$3-$2-$1 00:00:00");
    } else {
        return 0;
    }
    $time = parse_local_date(DateCalc($day, "+ $time seconds"), $TZ);
    my ($time_base, $time_tz) = @{date_to_local($time, $TZ)};
    return UnixDate($time_base, '%q') . " $time_tz"
}

sub remove_role {
    $_ = shift;
    s/\(.*\)//is;
    return $_;
}

#-- read_popup($url, %$show) -- read the popup file and add the retrieved data into the %show hash
my $warned_discarding_two_channel = 0;
sub read_popup($$) {
    my $tb = HTML::TreeBuilder->new();
    my $url = shift;
    my $show = shift;
    my $htmldata = get_page($url);

    return unless(defined($htmldata));
    $tb->parse($htmldata) or die "cannot parse content of $url\n";
    $tb->eof;

    ## short description.
    my $short_desc = $tb->look_down('_tag' => 'span', 'class' => 'tv-sendung-info');
    if ($short_desc) {
        my $desc = $short_desc->as_text;
        convert_cp1252_chars(\$desc);
        $show->{"desc"} = [[ trim($desc) , $lang ]];

    ## if missing, check for "tv-vorspann-popup"
    } else {
        $short_desc = $tb->look_down('_tag' => 'span', 'class' => 'tv-vorspann-popup');
        my $desc = $short_desc->as_text;
        convert_cp1252_chars(\$desc);
        $show->{"desc"} = [[ trim($desc) , $lang ]] if length($desc)>0;
    }

    foreach my $desc_td ($tb->look_down('_tag' => 'td', 'class' => 'tv-sendung-info')) {
        if ($desc_td->as_HTML =~/^<td.*?>(.*?)?\s*<br.*?>\s*&gt;\s*([0-9]{2}\.[0-9]{2})(.*)?\s*<\/td>$/gis) {
            #
            # add this longer description only if there is no description
            if (length($1)) {
                if (!$show->{"desc"}) {
                    my $desc = $1;
                    convert_cp1252_chars(\$desc);
                    $show->{"desc"} = [[ trim($desc) , $lang ]];
                }
            }
            if (length($2)) {
                $show->{"stop"} = $2;  ## stop time: converted to date/time in parse_page()
            }

            ## show length
            if (length($3)) {
                my $add_info = $3;
                ## 43/45 Min. or 45 Min.. if "43/45 Min.", I take the 1st number as length
                if ($add_info =~ /\s*((([\d]{1,3})\/)?[\d]{1,3})(\s+Min\.)\s*/gi) {
                    if ($3) {
                        $show->{"length"} = $3*60;  ## xmltv converts these seconds to minutes or hours
                    } else {
                        $show->{"length"} = $1*60;
                    }

                ## showview number
                } elsif ($add_info =~ /\s*([0-9\-]+)\s*/gi) {
                    $show->{"showview"} = $1 unless($1 eq "99-999-999");
                }
            }
        } elsif ($desc_td->as_text =~/^\s*(O:\s*(.*?))?\s*(R:\s*(.*?))\s*(D:\s*(.*?))\s*$/gis) {
            ## director(s)
            if ($3) {
                add_credits($show, 'director', (map { trim($_) } (split /;/, $4)));
            }
            ## actors
            if ($5) {
                add_credits($show, 'actor', ( map { trim(remove_role($_)) } (split /;/, $6)));
            }
            ## original name, country, year
            if ($1) {
                ## country year: "F 1992", "F/D 1999" or "GB/D or 1999/2000" or "F 2001/02"
                if ($2 =~/\s+([A-Z]+(\/[A-Z]+)*)\s+((19|20)[0-9]{2})(\/(19|20)?[0-9]{2})?(\s*|;)/s) {
                    $show->{"country"} = [[ $1, $lang ]] if $1;
                    $show->{"date"}    = parse_date_data($3) if $3;
                }
            }
        } elsif ($desc_td->as_text =~/\s+([A-Z]+(\/[A-Z])*)\s+((19|20)[0-9]{2})(\/(19|20)?[0-9]{2})?(\s*|;|<)/s) {
            $show->{"country"} = [[ $1, $lang ]] if !$show->{"country"};
            $show->{"date"} = parse_date_data($3) if !$show->{"date"} && $3;
        }
    }

    ## genre
    my $genre = $tb->look_down('_tag' => 'span', 'class' => 'tv-auszeichnung');
    if ($genre && $genre =~ m/$category_regexp/o) {
        $show->{"category"} = [[ $genre->as_text(), $lang ]];
    }

    ## defaults
    $show->{"video"} = { present => 1, colour => 1 };
    $show->{"audio"} = { present => 1, stereo => "mono" };

    foreach my $desc_img ($tb->look_down('_tag' => 'img')) {
        next if !$desc_img->attr('alt');
        my $desc_img_name = $desc_img->attr('alt');

        if ($desc_img_name =~/Stereo/i) {
            $show->{"audio"}->{"stereo"} = "stereo";

        } elsif ($desc_img_name =~/Zweikanal/i) {
        #    $show->{"audio"}->{"multichannel"} = 1;
            warn "discarding two-channel sound flag"
            unless $warned_discarding_two_channel++;

        } elsif ($desc_img_name =~/Surround/i) {
            $show->{"audio"}->{"stereo"} = "surround";

        } elsif ($desc_img_name =~/Breitbild/i) {
            $show->{"video"}->{"aspect"} = "16:9";

        } elsif ($desc_img_name =~/Schwarzwei(ï¿½ss)/i) {
            $show->{"video"}->{"colour"} = 0;

        } elsif ($desc_img_name =~/Untertitel/i) {
            $show->{"subtitles"} = [{ type => 'teletext' }];

        #} elsif ($desc_img_name =~/VerschlÃ¼sselt/i) {
        #    $show->{"encoded"} = 1;
        } else {
            next;
        }
    }

    $tb->delete();
}


#-- squeeze_out_desc($$desc, %$show)
sub squeeze_out_desc($$) {
    my $desc = shift;
    my $show = shift;
    my @newdesc;


    # try to match <category>, <country> <year>; R: <names>; D: <names> construct
    # where <country>/<year> or the [RD]: stuff may be missing ...
    if(my @parts = ($$desc =~ m/^\s*(\(([^\)]*)\))?\s+([^,;0-9]+)(,?\s+([^,;]+)\s+([12][09][0-9]{2}(?:[\/-][0-9]{2})?))?\s*; (?:(?:; )?(Buch\/Regie|R): ([^;]+))?\s*((?:; )?D: (.+))?\s*$/)) {
        t "split rule: <category>, <country> <year> ...";
    $$desc = "";

    #-- $parts[1] is the show title in English (doesn't have to be available)
    #-- second title doesn't have to be Enlish, if you've got a French
    #-- movie, $parts[1] will be in French! => undef
    $show->{"title"}->[1] = [ $parts[1], undef ] if($parts[1]);

    #-- $parts[2] is the show's genre in German
    $show->{"category"} = [[ $parts[2], $lang ]];
    warn "misdetected category: $parts[2]"
      if($parts[2] =~ m/\d{4}/);

    if ($parts[3]) {
        #-- $parts[4] specifies where the film was made, [5] when
        $show->{"country"} = [[ $parts[4], $lang ]];
        $show->{"date"} = parse_date_data($parts[5]);
    }

    #-- $parts[7] specifies the director (German: Regisseur)
    if (defined($parts[7])) {
        $parts[7] =~ s/\s*u.a.\s*$//;
        $parts[7] =~ s/\([^\(\)]+\)//g;
        $parts[7] =~ s/&amp;/&/g;

        my @people = split m/(?:\s+und\s+|\s*[,;]\s*)/, $parts[7];
        my @jobs;
        if ($parts[6] eq 'R') {
        @jobs = qw(director);
        }
        elsif ($parts[6] eq 'Buch/Regie') {
        @jobs = qw(director writer);
        }
        else {
        warn "don't understand 'director' type $parts[6]";
        }

        push @{$show->{credits}{$_}}, @people
          foreach @jobs;
    }

    if (defined($parts[9])) {
        #-- $parts[9] specifies the actors (German: Darsteller)
        $parts[9] =~ s/\s*u.a.\s*$//;
        $parts[9] =~ s/\([^\(\)]+\)//g;
        $parts[9] =~ s/&amp;/&/g;

        my @actor = split m/(?:\s+und\s+|\s*[,;]\s*)/, $parts[9];
        push @{$show->{"credits"}{"actor"}}, @actor;
    }
    }
    else {
        t "split rule: dot splitting";
    my @data = split "", $$desc;
    s/(^\s|\s$)//g foreach(@data); #CHG#

    for(0 .. (scalar(@data) - 1)) {
        t "dot-split part $_: " . $data[$_];
    }

    if(scalar(@data) == 3
       && not($data[1] =~ m/[\wï¿½ï¿½ï¿½]+:/) #- FIX false positive: tvtoday.de seems to publish "guests: <names>" here some (rare) times :-(
       && $data[2] =~ m/^Mit (.*?)$/) {
        my $actors = $1; #- BUGFIX, cache $1 as $actors

        # $data[0] --> sub title of show
        # $data[1] --> genre, may be "<genre>, <country> <year"
        # $data[2] --> actors

        #for ($data[0]) { s/^\s+//; s/\s+$// }
        s/(^\s|\s$)//g foreach(@data);
        $show->{"sub-title"} = [[ $data[0], $lang ]];

        if($data[1] =~ m/([^,;]+)(?:,\s+([^,;]*)\s+([12][09][0-9]{2}(?:[\/-][0-9]{2})?))?/) {
        my ($cat, $country, $date) = ($1, $2, $3);
        if ($cat =~ /\S/) {
                warn "misdetected category: $cat"
              if($cat =~ m/\d{4}/);
            $show->{"category"} = [[ $cat, $lang ]];
        }
        else { warn "bad category '$cat'" }

        if (defined $country) {
            if ($country =~ /\S/) {
                $show->{"country"} = [[ $country, $lang ]];
            }
            else { warn "bad country '$country'" }
        }

        $show->{"date"} = parse_date_data($date) if(defined($date));
        }
        else {
        warn "<genre>(, <country> <year>)? expection not met, THIS SHOULD NOT HAPPEN";
        #-- try to get out here ...
        push @newdesc, $data[1];
        }

        my @actors = split(",", $actors); #- BUGFIX: relied on $1, which get's destroyed by insertions above
        push @{$show->{"credits"}{"actor"}}, @actors;
    }
    else {
        foreach (@data) {
        if (m/^Thema: (.*)$/) {
            push @newdesc, $_, next if($show->{"sub-title"});
            $show->{"sub-title"} = [[ $1, $lang ]];
            next;
        }

        if (m/^\(Live\s*(.*)?\)$/) {
            #-- it's a live show, location: $1 (if defined)
            push @newdesc, $_; #- xmltv.dtd doesn't support it (yet) -- copy to desc field
            #undef $_;
            next;
        }

        if (my ($nocat, $cat, $rest1, $names, $guests, $rest2) = m/^(([^,.%^&*();]+?)((?:\s+-\s+..+?)*)|.+) - Moderation: (.+?) - Gï¿½te: (..+?)(?:\s+-\s+(.+))?$/) {
            my @data = split_up_names($names, $show);
            push @{$show->{"credits"}{"presenter"}}, @data;
            my @guest_data = split_up_names($guests, $show);
            push @{$show->{"credits"}{"guest"}}, @guest_data;

            if(defined($cat)) {
            $show->{"category"} = [[ $cat, $lang ]];

            warn "misdetected category: $cat"
              if($cat =~ m/\d{4}/);
            }
            else {
                t "no-cat match: $nocat";
            $rest1 = $nocat;
            }

            my @rest;
            foreach(defined($rest1) ? split(m/\s+-\s+/, $rest1) : undef, $rest2) {
            push @rest, $_ if(defined($_) && length($_));
            }
            $_ = join " * ", @rest;
            next unless length($_);
        }

        if (my ($nocat, $cat, $rest1, $names, $rest2) = m/^(([^,]+?)((?:\s+-\s+..+?)*)|.+) - Moderation: (.+?)(?:\s+-\s+(.+))?$/) {
            my @data = split_up_names($names, $show);
            push @{$show->{"credits"}{"presenter"}}, @data;

            if(defined($cat)) {
            $show->{"category"} = [[ $cat, $lang ]];

            warn "misdetected category: $cat"
              if($cat =~ m/\d{4}/);
            }
            else {
                t "no-cat match: $nocat";
            $rest1 = $nocat;
            }

            my @rest;
            foreach(defined($rest1) ? split(m/\s+-\s+/, $rest1) : undef, $rest2) {
            push @rest, $_ if(defined($_) && length($_));
            }
            $_ = join " * ", @rest;
            next unless length($_);
        }

        if (my ($type, $names) = m/^\s*(Reporter:|Moderation:|Kommentar:|Gast:|Gï¿½te:|Mit|Film von)\s+(?!de[nm]\s+)(.*?)\s*$/) {
            $names =~ s/\s*u.a.\s*$//;
            $names =~ s/\([^\(\)]+\)//g; #-- remove all brackets, that further describe the person
            $names =~ s/&amp;/&/g; #- the semicolon behind &amp; causes trouble, replace it -- other entities shouldn't appear ...

            #-- try to split up ...
            my @data = split_up_names($names, $show);

            if(scalar(@data) > 1 || scalar($data[0] =~ m/\s/g)) {
            #-- if there's only one word, we seem to be wrong ...
            #-- ignore and go on without squeezing out too much info
            if($type eq "Reporter:" || $type eq "Moderation:") {
                push @{$show->{"credits"}{"presenter"}}, @data;
            }
            elsif($type eq "Kommentar:") {
                push @{$show->{"credits"}{"commentator"}}, @data;
            }
            elsif($type eq "Gast:" || $type eq "Gï¿½te:" || $type eq "Mit") {
                if($type eq "Mit" && $names =~ m/(?:Rundschau|Sport|Wetter|Nachrichten|Wirtschaft)/ || $names =~ m/^".*"$/) {
                push @newdesc, $_;
                next;
                }

                push @{$show->{"credits"}{"guest"}}, @data;
            }
            elsif($type eq "Film von") {
                push @{$show->{"credits"}{"producer"}}, @data;
            }
            else { die }

            undef $_;
            next;
            }
        }

        if (m/^\s*u.a.\s*/) {
            # "u.a." means and others, this is a left over thing,
            # e.g. if you've got a comedy series with comedian1,
            # comedian2 + separator + 'u.a.' -> simply ignore
            undef $_;
            next;
        }

        if (m/^\s*([^,;!-%\(\)=\+]+), ([^,;!-%\(\)=\+]+) ([12][90][0-9]{2}(?:[\/-][0-9]{2})?)\s*$/) {
            $show->{"category"} = [[ $1, $lang ]];
            $show->{"country"} = [[ $2, $lang ]];
            $show->{"date"} = parse_date_data($3);

            $_ = $1; warn "misdetected category: $_" if(m/\d{4}/);

            undef $_;
            next;
        }

        if (my ($category, $subtitle) = m/^(.*?) - (.*?)( - ((Free-TV|Deutschland)-Premiere(; )?)?([0-9]+\/(I{1,3}V?|V|VI{1,3}))?)?$/) {
            if ($category =~ m/$category_regexp/o
                and not $subtitle =~ m/ (am|um) [0-9\.\:]+/
                and not $subtitle =~ m/ - /) {
            $show->{"category"} = [[ $category, $lang ]];
            $show->{"sub-title"} = [[ $subtitle, $lang ]];

            warn "misdetected category: $category"
              if($category =~ m/\d{4}/);

            next;
            }
        }

        #-- don't know what it means, ....
        push @newdesc, $_;
        }
    }
    }

    unless(defined($show->{"category"})) {
    foreach(@newdesc) {
    next unless(my ($leftpart, $category, $rightpart) = m/$category_regexp/o);
    $leftpart = "" unless(defined($leftpart));
    $rightpart = "" unless(defined($rightpart));

    warn "misdetected category: $category"
      if($category =~ m/\d{4}/);

    warn("already had category for ".$show->{"title"}->[0][0]." available (".$show->{"category"}->[0][0]."), replacing by '$category', this should not happen") if($show->{"category"});
    warn "misdetected category: $category" if($category =~ m/\d{4}/);
    $show->{"category"} = [[ $category, $lang ]];

    $leftpart =~ s/(^\s|\s$)//g;
    $rightpart =~ s/(^\s|\s$)//g;

    if(not length("$leftpart$rightpart")) {
        #- $#newdesc --;
        undef $_;
    }
    elsif($rightpart =~ m/^mit\s+(.*)$/) { #-- mit means "with" in German
        my @data = split_up_names($1, $show);
        add_credits($show, 'presenter', @data);

        undef $_ unless(length($leftpart));
    }
    elsif($rightpart =~ m/^von(?: und mit)?\s+(.+)$/) { #-- mit means "with" in German
        my @data = split_up_names($1, $show);
        add_credits($show, 'producer', @data);

        undef $_ unless(length($leftpart));
    }

    last;
    }
    }

    if(defined($show->{"category"})) {
        foreach (@{$show->{"category"}}) {
            die if not defined($_->[0]);
        warn "we assigned some strange category: $_->[0]"
          if($_->[0] =~ m/\d{4}/);
    }
    }

    refine_category_attr(\@newdesc, $show);
    $$desc = join " * ", (grep $_, @newdesc);
}

#-- add_credits(%$show, $credit, @people) -- add names to a <credits>
# subelement but only if they are not already there.
#
# Assumption: nothing is removing from credits lists.
#
sub add_credits($$@) {
    my ($show, $credit, @people) = @_;
    my %seen;
    foreach (@{$show->{credits}->{$credit}}) { $seen{$_}++ }
    push @{$show->{credits}->{$credit}},
      grep { not $seen{$_}++ } @people;
}

#-- refine_category_attr(@$desc, %$show) -- refine category attribute of %show
sub refine_category_attr($$) {
    my $desc = shift;
    my $show = shift;

    #-- refining category attributes ...
    return if not exists $show->{"category"};
    foreach (@{$show->{"category"}}) {
    die if not defined($_->[0]);
    $_->[0] =~ s/(^\s|\s$)//g;

    if($_->[0] =~ s/\s+(?:frei\s+)?(nach|von|mit)\s+([^\d]*?)\s*$//) {
        my @data = split(m/(?:\sund\s|[,;])/, $2);

        if ($1 eq "nach") { push @{$show->{"credits"}{"writer"}}, @data; }
        elsif ($1 eq "von") { push @{$show->{"credits"}{"producer"}}, @data; }
        elsif ($1 eq "mit") { push @{$show->{"credits"}{"presenter"}}, @data; }
        else { die }
    }

    if($_->[0] =~ s/\s*(\d+\. Staffel)\s*//) {
        #-- really doesn't belong into category, throw out to description
        push @$desc, $1;
    }

    #-- okay, the last word should be the actual category now,
    #   discard everything else back to description
    if($_->[0] =~ s/^\s*(.*?\s+)(?=[\wï¿½ï¿½ï¿½\-\/]+\s*$)//) {
        push @$desc, "$1$_->[0]";
    }

    #-- discard whole entry if we don't have any text left ...
    $_->[0] =~ s/(^\s|\s$)//g;
    undef $_ unless(length($_->[0]));
    }

    # We may have set some category elements to undef, but they
    # shouldn't be left there.
    #
    $show->{"category"} = [ grep { $_ } @{$show->{"category"}} ];


    # DEBUG FEATURE
    # check the stored categories against our list ...
    1 && return;

    foreach (@{$show->{"category"}}) {
    my $title = $show->{"title"}->[0][0];

    warn "show '$title' has invalid category-language tag assigned: $_->[1]"
      unless($_->[1] eq $lang);

    next unless(m/$category_regexp/o);
    warn "show '$title' has strange category assigned: $_->[0]"
      if(length("$1$3"));
    }
}



#-- refine_credits(%$show) -- refine credits listed below %show hash
sub refine_credits($) {
    my $show = shift;

    foreach(keys(%{$show->{"credits"}})) {
        foreach(@{$show->{"credits"}{$_}}) {
            s/(^\s|\s$)//g;

            #-- remove leading articles in front of group's names, e.g. bands etc.
            s/^de[rnm]\s+//g;

            #-- trim leading proffession-names, etc ...
            #-- this is stupidly given with all these faked judgement shows (for juges and lawyers who probably even don't have and deserve their title ...)
            s/^(Anwalt|Anwï¿½tin|Anwï¿½ten|Richter(in)?)\s+//g;
        }
    }
}



#-- get channel logos
sub get_icons() {
    my %icons;
    my $url="http://programm.tvtoday.de/tv/programm/programm.php?ztag=0&sparte=alle&uhrzeit=Ax00&sender=";
    my $chan;
    my $tag;
    my $addr;

    my $bar = new XMLTV::ProgressBar('grabbing icons', scalar(keys(%channels)))
      if not $opt_quiet;

    foreach (keys %channels) {
        my $tb = new HTML::TreeBuilder();
    my $htmldata = get_page($url.$_);
    next unless(defined($htmldata));
        $tb->parse($htmldata) or die "cannot parse content of $url$_\n";
    $tb->eof;

        $tag = $tb->look_down('_tag' => 'img',
        sub {
            return ($_[0]->attr('src') =~ m/^\/tv\/programm\/bilder\/senderlogos\//);
        });

        update $bar if not $opt_quiet;

        unless(ref($tag) eq "HTML::Element") {
                $tb->delete;
                next;
        };

        $icons{$_} = $tag->attr('src');
        $tb->delete;
    }
    $bar->finish() if not $opt_quiet;

    return %icons;
}



#-- get channel listing
sub get_channels() {
    my %channels;
    my $url="http://www.tvtoday.de/program2007";

    my $tb=new HTML::TreeBuilder();
    my $htmldata = get_page($url);

    die "successful grab of $url required, stopping here."
    unless(defined($htmldata));

    $tb->parse($htmldata) or die "cannot parse content of $url\n";
    $tb->eof;
    foreach ($tb->look_down('_tag' => 'select', 'name' => 'channelId')->content_list()) {
    next unless(ref($_) eq "HTML::Element");
    warn "unexpected HTML::Element $_->tag", next if($_->tag ne "option");

    my $station_name = $_->as_text();
    $station_name =~ s/(?:^\s|\s$)//g;

    next if ($station_name eq "Senderdirektwahl");

    $channels{uri_escape($_->attr("value"))} = $station_name;
    }

    return %channels;
}


#-- split_up_names($names, %$show) :: Split up names into returned array
sub split_up_names($$) {
    my $names = shift;
    my $show = shift;

    $names =~ s/, unter Mitwirkung von\s+/ und /g; #- replace 'with help of' by simple and to allow match below
    my @data = split(m/\s*[,;]\s*/, $names);

    if(scalar(@data) == 2) {
    #-- check for "<name(s)>, <country> <year>" construct
    if($data[1] =~ m/\s*([^,;]*)\s+([12][09][0-9]{2}(?:[\/-][0-9]{2})?)\s*$/) {
        $show->{"country"} = [[ $1, $lang ]];
        $show->{"date"} = parse_date_data($2);

        $#data --;
        $names = $data[0];

    }
    elsif(scalar($data[1] =~ m/\s/g) == 0) {
        #- we most probably have a country specification
        #- here, treat it as such, ... and hope it's right
        $show->{"country"} = [[ $data[1], $lang ]];

        $#data --;
        $names = $data[0];
    }
    }

    if(scalar(@data) == 1 && $names =~ m/\s+und\s+/) {
    # looks like it didn't work, try splitting by 'und' (== and)
    @data = split(m/\s+und\s+/, $names);

    #-- check that we didn't have a "hername + hisname familyname or name + name" construct ...
    if(scalar(@data) == 2) {
        @data = $names #-- ignore split in that case
          if (scalar($data[0] =~ m/\s/g) == 0 && scalar($data[1] =~ m/\s/g) <= 1);
    }
    }

    return @data;
}


#-- parse_date_data($d) :: Parse the given "yyyy([-/]yy)?" date down to "yyyy" only
sub parse_date_data($) {
    my $date = shift;
    warn("bad date '$date' found, returning undef."), return(undef)
      unless($date =~ m/((?:19|20)[0-9]{2})(?:(?:[-\/])([0-9]{2}))?/);

    #-- return if it's a plain 'yyyy' date ...
    return $date unless(defined($2));

    my $century = substr($date, 0, 2);
    if(substr($date, 2, 2) > $2) {
    warn("bad date '$date' found, returning undef."), return(undef)
      unless($century == 19);
    $century ++;
    }

    return $century * 100 + $2;
}



#-- get_page($url) :: try to download $url via http://, look for closing </body> tag or die
sub get_page($) {
    my $url = shift;
    my $retry = 0;

    local $SIG{__DIE__} = sub { die "\n$url: $_[0]" };
    #print STDERR "get_page: $url\n";

    while($retry < 2) {
    my $got = eval { get_nice($url . ($retry ? "&retry=$retry" : "")); };
    $retry ++;

    next if($@); # unable to download, doesn't look too good for us.

    die "retrieved webpage doesn't look like a tvtoday.de page, maybe a proxy error?"
      unless(index($got, "<title>TV TODAY</title>"));

    #-- page seems to be complete, if we have a </body> tag ...
    return $got unless(index($got, "</body>") < 0);

    #-- be nice to our server, let's wait extra ...
    sleep(rand($retry * 5)) unless($debug);
    warn "got incomplete webpage from tvtoday.de" if($debug);
    }

    warn "cannot grab webpage $url, giving up after trying $retry times";
    return undef;
}

