#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_grab_na - Grab Canadian and US TV listings.

=head1 SYNOPSIS

tv_grab_na [--help] [--debug] [--config-file FILE] --configure CONFIG_OPTIONS

tv_grab_na [--help] [--debug] [--config-file FILE] GRAB_OPTIONS

=head1 DESCRIPTION

Output TV listings for Canada and the USA in XMLTV format.  The data
currently comes from the zap2it.com site.

First you must run B<tv_grab_na --configure> to set your local area,
service provider and which channels you wish to download.  Then
running B<tv_grab_na> with no arguments will get a weekE<39>s listings
for the channels you chose.  If the upstream data changes (for
example, new channels appear) you will be prompted to rerun
B<--configure> to update your choices.

Some options are available in both configure and grab mode:

B<--help> Print help to standard output and exit successfully.

B<--debug> Turn on debugging checks.

B<--config-file FILE> The location of the config file, which is
written in configure mode and read in grab mode.  The default location
is B<~/.xmltv/tv_grab_na>.

Configuration is normally interactive, but it can be run
noninteractively, usually to update an existing set of choices.  The
following options are used to invoke --configure in a non-interactive
mode:

B<--retry-limit X> Specify retry limit on www site failures.

B<--retry-delay X> Specify number of seconds to delay before retrying
www site failures.

B<--postalcode X>, B<--zipcode X> Specify your postal code or zip code.

B<--provider ID> Specify the id of your service provider.  This is a
number assigned by the zap2it site.  During interactive configuration
you are presented with a list of provider names, but if you already
know the id you can specify it here.

B<--auto-fail-on-provider-changes BOOLEAN> If true, exit with failure
if the provider id has changed on the zap2it site.

B<--auto-new-channels [ignore|add]> Ignore or automatically add new
channels in schedule listing.

B<--auto-missing-channels [ignore|remove]> Ignore or remove channels
no longer in schedule listing.

B<--list-providers> Produce a list of providers and thier descriptions
for the postal/zip code provided in --postalcode or --zipcode arguments.
This option is here to support gui tools who want to reproduce the
configure process.

Interactive mode is entered if some necessary information is not given
(for example no postal or zip code in the existing configuration file,
and not given on the command line).

After successful configuration you can start grabbing.  The options
here are:

B<--debuglistings> Add debugging information to the output as XML
comments.

B<--quiet> disable all status messages (that normally appear on stderr).

B<--stats> force output of grab stats (stats output disabled in --quiet mode).

B<--output FILE> Write output to FILE rather than standard output.
If the file exists it is overwritten. FILE may contain L<date(1)>
and keyword substitions like B<--listings>. 

B<--listings FILE> Write output to FILE rather than standard output.
FILE may contain L<date(1)> style substitutions, for example use
B<--listings "listings-%d%m%Y.xml"> to separate output by day.
Similarily, keywords B<%postalcode> and B<%zipcode> are also substituted from
settings current configuration.  The filename is only re-evaluated
when a new dayE<39>s listings is started.

B<--listings-overwrite X> Should tv_grab_na overwrite existing --listings output
files or skip the ones that exist? (default=false - do not overwrite
already grabbed listings files)

B<--days N> When grabbing, grab N days of listings.  The default is 7.

B<--offset N> Number of days in the future to offset the start of the
listings.  The default is 0, meaning today.

B<--retry-limit X> Specify retry limit on www site failures.

B<--retry-delay X> Specify number of seconds to delay before retrying
www site failures.

B<--gzip-command X> Specify the command line for .gz output files.
The default is "gzip".

B<--zip-command X> Specify the command line for .zip output files.
The default is "zip".

B<--bzip2-command X> Specify the command line for .bz2 output files.
The default is "bzip2".

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.zap2it.com/>

=head1 AUTHOR

Jerry Veldhuis, jerry@matilda.com

=head1 BUGS

There is no way to get listings for only part of each day; the old
B<--startHour> and B<--endHour> options no longer exist.  This makes
grabbing slower than it needs to be if you only want listings for
certain hours.

The zap2it site has a long list of program qualifiers such as Live,
Animated, HDTV and so on.  Most of these are understood by tv_grab_na
and included in the XMLTV output.  But some new ones pop up
occasionally and generate a warning message (which should be reported
to the author).  Some qualifiers such as Live do not yet have a
good translation into XMLTV format.

=cut

my $VersionMajor=2;
my $VersionMinor;

my $Date = q$Date$;
if ( !($Date=~m;^\s*Date: (\d{4})/(\d\d)/(\d\d) \d\d:\d\d:\d\d\s*$;)) {
    die "can't decipher date line ($Date)\n";
}
else {
    # Take the day as the minor version, eg 20020224.
    $VersionMinor="$1$2$3";
}

my $VersionID="tv_grab_na V$VersionMajor\.$VersionMinor";

#
# define name of tv_grab_na config file
#
my $ConfigFileName_g="tv_grab_na";
my $ConfigPathName_g;

# default location of config file is $HOME or ./ if HOME not set
if ( defined($ENV{HOME}) ) {
    $ConfigPathName_g="$ENV{HOME}/.xmltv/$ConfigFileName_g";
}
else {
    $ConfigPathName_g="./$ConfigFileName_g";
}

use strict;

package myConfig;

sub new
{
    my($type) = shift;
    my $self={ @_ };            # remaining args become attributes
    
    bless($self, $type);
    return($self);
}

sub setValue($$$)
{
    my ($self, $key, $value)=@_;
    $self->{$key}=$value;
    if ( $key ne "option_postalcode" &&
	 $key ne "option_zipcode" &&
	 $key ne "option_provider" &&
	 $key ne "option_provider_desc" &&
	 $key ne "option_retry_limit" &&
	 $key ne "option_retry_delay" ) {
	die "attempt to set invalid key $key to $value";
    }
}

sub unsetValue($$$)
{
    my ($self, $key, $value)=@_;
    delete($self->{$key}) if ( defined($self->{$key}));
}

#
# get list of stations in display-name order
#
# sad but true, I can't figure a better way of
# doing this, but then again I don't care - jv
#
sub stationsInDisplayOrder($)
{
    my $self=shift;

    # create reverse hash with key/values swapped
    my @nums;
    foreach my $station (keys (%{$self->{channels}})) {
	my $key=0;
	if ( $station=~m/^\s*(\d+)/o ) {
	    $key=$1;
	}
	# seems very odd, but occasionally, you get two channels with the
	# same channel # on the dial
	if ( defined($nums[$key]) ) {
	    $nums[$key]="$nums[$key],$station";
	}
	else {
	    $nums[$key]="$station";
	}
    }
    
    my @ret;
    for (my $n=0; $n<scalar(@nums) ; $n++ ) {
	if ( defined($nums[$n]) ) {
	    push(@ret, sort (split(',', $nums[$n])))
	}
    }
    return(@ret);
}

sub haveAnyChannels($)
{
    my $self=shift;
    return(defined($self->{channels}));
}

sub stationRemove($$)
{
    my ($self, $station)=@_;
    delete($self->{channels}->{$station});
}

sub stationExists($$)
{
    my ($self, $station)=@_;
    return(defined($self->{channels}->{$station}));
}

sub setStationIncluded($$$)
{
    my ($self, $station, $in)=@_;
    $self->{channels}->{$station}->{in}=$in;
}

sub stationIncluded($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{in});
}

sub stationIcon($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{icon});
}

sub setStationIcon($$$)
{
    my ($self, $station, $icon)=@_;
    $self->{channels}->{$station}->{icon}=$icon;
}

sub setStationTransientFlag($$$$)
{
    my ($self, $station, $flag, $value)=@_;
    $self->{channels}->{$station}->{transient}->{$flag}=$value;
}

sub getStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    return($self->{channels}->{$station}->{transient}->{$flag});
}

sub removeStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    delete($self->{channels}->{$station}->{transient}->{$flag});
}

sub save($$)
{
    my ($self, $file)=@_;

    if ( main::mkpathtofile($file, 0) != 1 ) {
	print STDERR "mkdir failed on directory for $file:$!\n";
	return(-1);
    }

    open(FD, "> $file") || return(-1);
    print FD "# config file: tv_grab_na $VersionMajor.$VersionMinor\n";
    print FD "#\n";
    print FD "# this file is generated by running tv_grab_na --configure\n";
    print FD "# the only change you should make is prefixing 'channel:' lines\n";
    print FD "# with a '#' to signal that they should be ignored during the\n";
    print FD "# grab step\n";
    print FD "#\n";
    if ( defined($self->{option_retry_limit})) {
	print FD "retry limit: $self->{option_retry_limit}\n";
    }
    if ( defined($self->{option_retry_delay})) {
	print FD "retry delay: $self->{option_retry_delay}\n";
    }
    if ( defined($self->{option_postalcode})) {
	print FD "postal code: $self->{option_postalcode}\n";
    }
    if ( defined($self->{option_zipcode}) ) {
	print FD "zip code: $self->{option_zipcode}\n";
    }
    print FD "provider: $self->{option_provider} \# ".
	$self->{option_provider_desc}."\n";
    
    foreach my $station ($self->stationsInDisplayOrder()) {
	if ( $self->stationIncluded($station) ) {
	    print FD "channel: $station\n"
	}
	else {
	    print FD "#channel: $station\n";
	}
    }
    close(FD);
    return(0);
}

sub load($$$)
{
    my ($self, $file, $debug)=@_;

    my $majorVersion;
    open(FD, "< $file") || return(-1);
    while (<FD>) {
	s/\n$//o;

	# auto-upgrading from version 1 to 2
	if ( defined($majorVersion) && $majorVersion == 1 ) {
	    if ( m/^\#+channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="#channel: $2";
	    }
	    elsif ( m/^channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="channel: $2";
	    }
	}

	if ( $. == 1 ) {
	    if ( m/^\#\s+config\s+file:\s*(?:g.tlistings|tv_grab)_na (\d+)\.(\d+)/o ) {
		$majorVersion=$1;
		if ( $1 == 1 ) {
		    print STDERR "$file: older format identified, coping, re-run --configure to upgrade\n";
		}
		elsif ( $1 != $VersionMajor || $2 > $VersionMinor ) {
		    print STDERR "$0: $file:$.: $1\.$2 is an unsupported version number\n";
		    close(FD);
		    return(-1);
		}
	    }
	    else {
		print STDERR "$0: $file:$.: unsupported version header\n";
		close(FD);
		return(-1);
	    }
	}
	elsif ( m/^retry limit:\s*([^\s]+)$/o ) {
	    $self->setValue("option_retry_limit", $1);
	}
	elsif ( m/^retry delay:\s*([^\s]+)$/o ) {
	    $self->setValue("option_retry_delay", $1);
	}
	elsif ( m/^postal code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_postalcode", $1);
	}
	elsif ( m/^zip code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_zipcode", $1);
	}
	elsif ( m/^provider:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->setValue("option_provider", $1);
	    $self->setValue("option_provider_desc", $2);
	}
	elsif ( m/^\#+channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 0);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 1);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^#/o ) {
	    next;
	}
	elsif ( m/^\s*$/o ) {
	    # ignore empty lines
	}
	else {
	    print STDERR "$0: $file:$.: invalid\n";
	    close(FD);
	    return(-1);
	}
	   
    }
    close(FD);
    if ( defined($self->{option_postalcode}) && defined($self->{option_zipcode})) {
	print STDERR "$0: $file: corrupt, only one of postal or zip can be defined\n";
	return(-1);
    }
    return(0);
}

1;

package main;

use strict;
#use diagnostics;
use Fcntl qw(:DEFAULT);
use XML::Writer;
use IO;
use Getopt::Long;
use Date::Manip; #Date_Init('TZ=UTC');
use File::Basename;

use XMLTV::ZapListings;
use XMLTV::Ask;

use vars qw/$opt_debug $opt_quiet $opt_stats/;

sub statusMessage($)
{
    if ( !$opt_quiet ) {
	print STDERR "STATUS:$opt_quiet:".$_[0];
    }
}

sub statsMessage($)
{
    if ( $opt_stats ) {
	print STDERR $_[0];
    }
}

sub debugMessage($)
{
    if ( $opt_debug ) {
	print STDERR @_;
    }
}

sub errorMessage($)
{
    print STDERR @_;
}

sub mkpathtofile($)
{
    my ($file)=@_;
    my @paths;

    my $path=dirname($file);
    if ( -d $path ) {
	return(1);
    }
    debugMessage("making path: $path..\n");
    while (length($path)!=0 && $path ne "." && $path ne "/" ) {
	last if ( -d $path );
	push(@paths, $path);
	$path=dirname($path);
    }

    foreach my $dir (reverse @paths) {
	if ( ! -d $dir ) {
	    mkdir($dir, 0775) || return(-1);
	}
	else {
	    debugMessage("$dir exists, not making\n");
	}
    }
    return(1);
}

#
# How this grabber works:

# Step 1 - Configure
#  
#   The configure step is meant to be run interactively.
#   You can use 'tv_grab_na --configure --help' to see
#   how to run non-interactively, providing information on
#   the command line.

#   run 'tv_grab_na --configure'
#
#   Follow the prompts to provide the necessary information.
#
#   When finished, configure will create a file $HOME/.xmltv/$ConfigFileName_g
#   which contains the postal/zip code, the provider id
#   and a line for each channel that provider supplies.
#   This file is what you specify with the --config command
#   line option to "Step 2 Grabbing Data". See Step 2 for details
#   of how this file is interpreted.
#

sub ConfigureUsage($)
{
    no strict 'subs';
    no strict 'refs';
    my $stdout=shift;

    my $fp=STDERR;
    if ( $stdout ) {
	$fp=STDOUT;
    }
    print $fp "usage $0 --configure [options]\n";
    print $fp "where options are:\n";
    print $fp "   --help\n";
    print $fp "     print $fp configure help\n";
    print $fp "\n";
    print $fp "   --debug\n";
    print $fp "     turn on debugging\n";
    print $fp "\n";
    print $fp "   --postalcode XXXXXX\n";
    print $fp "     specify postal code, don't use with --zipcode\n";
    print $fp "\n";
    print $fp "   --zipcode YYYYYY\n";
    print $fp "     specify zip code, don't use with --postalcode\n";
    print $fp "\n";
    print $fp "   --provider ZZZZZZZ\n";
    print $fp "     specify provider id\n";
    print $fp "\n";
    print $fp "   --config-file <file>\n";
    print $fp "     write results of configure to <file> instead of \$HOME/.xmltv/$ConfigFileName_g\n";
    print $fp "\n";
    print $fp "   --retry-limit <count>\n";
    print $fp "       upon possible www site failure, retry <count> times before hard failure.\n";
    print $fp "       (default 2)\n";
    print $fp "\n";
    print $fp "   --retry-delay <seconds>\n";
    print $fp "       number of seconds to sleep between retries (default 30).\n";
    print $fp "\n";
    print $fp "  The following options are used to invoke --configure in a non-interactive mode\n";
    print $fp "   --auto-fail-on-provider-changes <boolean>\n";
    print $fp "     true/false - exit 1 if provider has changed\n";
    print $fp "\n";
    print $fp "   --auto-new-channels [ignore|add]\n";
    print $fp "     ignore/add - ignore or automatically add new channels in schedule listing\n";
    print $fp "\n";
    print $fp "   --auto-missing-channels [ignore|remove]\n";
    print $fp "     ignore/remove - ignore or remove channels no longer in schedule listing\n";
    print $fp "\n";
    print $fp "The following options are available to support gui frontends who want to reproduce\n";
    print $fp "the configure process.\n";
    print $fp "\n";
    print $fp "   --list-providers\n";
    print $fp "     produce a list of providers and their descriptions.\n";
    print $fp "     requires one of --postalcode or --zipcode specified.\n";
    print $fp "\n";
    print $fp "   --list-channels\n";
    print $fp "     produce a list of channels available.\n";
    print $fp "     requires --provider and one of --postalcode or --zipcode specifed.\n";
    print $fp "\n";
    print $fp "If any neccessary options are given, interactive mode is enabled\n";
    print $fp "(ie no postal/zip code in config file and not on command line)\n";
    print $fp "Result of running configure is a configuration file\n";
    print $fp "\$HOME/.xmltv/$ConfigFileName_g (use --config to override location).\n";
}

# Step 2 - Grab
#   
#   The grab step uses the information collected during
#   configuration to get tv listings.
#  
#
#

sub Usage($)
{
    no strict 'subs';
    no strict 'refs';
    my $stdout=shift;

    my $fp=STDERR;
    if ( $stdout ) {
	$fp=STDOUT;
    }

    print $fp "usage $0 [--help|--configure [configure-options] |[grab-options]]\n";
    print $fp "command line options are:\n";
    print $fp "   --help\n";
    print $fp "     print this help\n";
    print $fp "     use --configure --help for configure help or\n";
    print $fp "     use --grab --help for grab help\n";
    print $fp "\n";
    print $fp "   --configure\n";
    print $fp "     run configuration step, see --configure --help for more info\n";
    print $fp "\n";
    print $fp "grab-options are:\n";
    print $fp "   --debug\n";
    print $fp "     turn on debugging\n";
    print $fp "\n";
    print $fp "   --debuglistings\n";
    print $fp "     add debugging material in output xml as comments\n";
    print $fp "\n";
    print $fp "   --quiet\n";
    print $fp "     disable all status messages (that normally appear on stderr).\n";
    print $fp "\n";
    print $fp "   --stats\n";
    print $fp "     force output of grab stats (stats output disabled in --quiet mode).\n";
    print $fp "\n";
    print $fp "   --config-file <file>\n";
    print $fp "     specify file that contains config information, default in\n";
    print $fp "     \$HOME/.xmltv/$ConfigFileName_g (created by using --configure)\n";
    print $fp "\n";
    print $fp "   --output <file>\n";
    print $fp "       redirect listings to <file> instead of stdout. <file> may contain\n";
    print $fp "       L<date(1)> and keyword substitions like --listings.\n";
    print $fp "\n";
    print $fp "   --listings <file>\n";
    print $fp "       specify listings.xml filename(s) for channel & program info\n";
    print $fp "       <file> may contain Date::Manip::Unix substitutions\n";
    print $fp "       for instance, use --listings \"listings-%d%m%Y.xml\" to separate output\n";
    print $fp "       by day. Similarily, %postalcode, %zipcode, are also substituted from\n";
    print $fp "       settings in the current configuration.\n";
    print $fp "       The filename is only re-evaluated when a new days listings is started.\n";
    print $fp "       if no --listings is specified stdout is used\n";
    print $fp "\n";
    print $fp "   --listings-overwrite <boolean>\n";
    print $fp "       should tv_grab_na overwrite existing --listings output files or skip the\n";
    print $fp "       ones that exist? (default=false - don't overwrite already grabbed\n";
    print $fp "       listings files)\n";
    print $fp "\n";
    print $fp "   --days n\n";
    print $fp "       specify number of days to include in output (default 7)\n";
    print $fp "\n";
    print $fp "   --offset n\n";
    print $fp "       specify number of days (in the future) to offset the\n";
    print $fp "       start of the listings (default 0)\n";
    print $fp "\n";
    print $fp "   --retry-limit <count>\n";
    print $fp "       upon possible www site failure, retry <count> times before hard failure.\n";
    print $fp "       (default 2)\n";
    print $fp "\n";
    print $fp "   --retry-delay <seconds>\n";
    print $fp "       number of seconds to sleep between retries (default 30).\n";
    print $fp "\n";
    print $fp "   --gzip-command <command>\n";
    print $fp "       specify the command line for .zip output files.(default is \"gzip\")\n";
    print $fp "\n";
    print $fp "   --zip-command <command>\n";
    print $fp "       specify the command line for .zip output files.(default is \"zip\")\n";
    print $fp "\n";
    print $fp "   --bzip2-command <command>\n";
    print $fp "       specify the command line for .bz2 output files.(default is \"bzip2\")\n";
    print $fp "\n";
}


# First lets check to see if someone asked for help.
# this is easier to do here than later.
my $configure=0;
if ( @ARGV ) {
    foreach my $arg (@ARGV) {
	$configure=1 if ( $arg=~m/^--configure/o );
        if ( $arg=~m/^--debug$/o ) { $SIG{__WARN__} = sub { die $_[0] }; }
    }
}

# Accept older --config as synonym for --config-file.
foreach ( @ARGV ) {
    last if $_ eq '--';
    next if /^--config-/;
    s/^--config\b/--config-file/;
}

if ( $configure ) {
    use vars qw/$opt_configure $opt_help $opt_postalcode $opt_zipcode $opt_provider $opt_config_file $opt_retry_limit $opt_retry_delay $opt_auto_fail_on_provider_changes $opt_auto_new_channels $opt_auto_missing_channels $opt_list_providers $opt_list_channels/;

    $opt_auto_fail_on_provider_changes="false";

    if ( ! GetOptions('configure', 'help', 'postalcode=s', 'zipcode=s', 'provider=s', 'config-file=s', 'debug', 'retry-limit=i', 'retry-delay=i', 'auto-fail-on-provider-changes=s', 'auto-new-channels=s', 'auto-missing-channels=s', 'list-providers', 'list-channels', 'quiet') ) {
	ConfigureUsage(0);
	exit(1);
    }

    $opt_quiet=(defined($opt_quiet));
    if ( !defined($opt_stats) ) {
	$opt_stats=!$opt_quiet;
    }
    else {
	$opt_stats=(defined($opt_stats));
    }

    if ( defined($opt_help) ) {
	ConfigureUsage(1);
	exit(0);
    }

    if ( defined($opt_list_providers) ) {
	if ( !defined($opt_postalcode) && !defined($opt_zipcode) ||
	     defined($opt_postalcode) && defined($opt_zipcode) ) {
	    errorMessage("$0: invalid usage, --list-providers requires ONE of --postalcode or --zipcode\n");
	    exit(1);
	}
	my @providers=XMLTV::ZapListings::getProviders($opt_postalcode, $opt_zipcode, $opt_debug);
	if ( ! @providers || !defined($providers[0]) ) {
	    exit(1);
	}
	# output list of providers to STDOUT
	foreach ( @providers ) {
	    my ($id, $desc) = ($_->{id}, $_->{description});
	    print STDOUT "$id:$desc\n";
	}
	exit(0);
    }

    if ( defined($opt_list_channels) ) {
	if ( !defined($opt_provider) ) {
	    errorMessage("$0: invalid usage, --list-channels requires --provider specified\n");
	    exit(1);
	}
	if ( !defined($opt_postalcode) && !defined($opt_zipcode) ||
	     defined($opt_postalcode) && defined($opt_zipcode) ) {
	    errorMessage("$0: invalid usage, --list-channels requires ONE of --postalcode or --zipcode\n");
	    exit(1);
	}
	my @channels=XMLTV::ZapListings::getChannelList($opt_postalcode,
							$opt_zipcode,
							$opt_provider,
							$opt_debug);
	if ( ! @channels || !defined($channels[0]) ) {
	    exit(1);
	}
	# output list of channels to STDOUT
	foreach my $channel (@channels) {
	    print STDOUT $channel->{description}."\n";
	}
	exit(0);
    }

    $opt_auto_fail_on_provider_changes=($opt_auto_fail_on_provider_changes=~m;^t;i);

    if ( defined($opt_auto_new_channels) ) {
	if ( $opt_auto_new_channels=~m;^ignore;i ) {
	    $opt_auto_new_channels="ignore";
	}
	elsif ( $opt_auto_new_channels=~m;^add;i ) {
	    $opt_auto_new_channels="add";
	}
	else {
	    errorMessage("$0: invalid argument to --auto_new_channels, must be 'ignore' or 'add'\n");
	    ConfigureUsage(1);
	}
    }

    if ( defined($opt_auto_missing_channels) ) {
	if ( $opt_auto_missing_channels=~m;^ignore;i ) {
	    $opt_auto_missing_channels="ignore";
	}
	elsif ( $opt_auto_missing_channels=~m;^remove;i ) {
	    $opt_auto_missing_channels="remove";
	}
	else {
	    errorMessage("$0: invalid argument to --auto_missing_channels, must be 'ignore' or 'remove'\n");
	    ConfigureUsage(1);
	}
    }

    # versions starting with 0.5 have configuration information in $HOME/.xmltv by default.
    if ( defined($ENV{HOME}) && -f "$ENV{HOME}/.xmltv_na" ) {
	statusMessage("$0: updating configuration file location from\n");
	statusMessage("    $ENV{HOME}/.xmltv_na to \$HOME/.xmltv/tv_grab_na\n");
	if ( ! -d "$ENV{HOME}/.xmltv" ) {
	    mkdir("$ENV{HOME}/.xmltv", 0775) || die "mkdir $ENV{HOME}/.xmltv:$!";
	}
	rename("$ENV{HOME}/.xmltv_na", $ConfigPathName_g) || 
	    die "mv $ENV{HOME}/.xmltv_na $ConfigPathName_g:$!";
    }

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config_file) ) {
	$configfile=$opt_config_file;
    }

    if ( -f $configfile && $config->load($configfile, $opt_debug) != 0 ) {
	errorMessage("$0: Failed to read $configfile\n");
	exit(1);
    }

    if ( defined($opt_postalcode) && defined($opt_zipcode) ) {
	errorMessage("$0: only one of --postalcode and --zipcode is allowed\n");
	exit(1);
    }

    # command line arguments
    if ( defined($opt_postalcode) ) {
	$config->setValue("option_postalcode", $opt_postalcode);
	$config->unsetValue("option_zipcode");
	$config->unsetValue("option_provider");
    }

    if ( defined($opt_zipcode) ) {
	$config->setValue("option_zipcode", $opt_zipcode);
	$config->unsetValue("option_postalcode");
	$config->unsetValue("option_provider");
    }
    
    if ( defined($opt_provider) ) {
	$config->setValue("option_provider", $opt_provider);
	$config->setValue("option_provider_desc", ""); # unknown so reset to ''
    }

    # sanity check
    if ( defined($config->{option_postalcode}) && defined($config->{option_zipcode})) {
	errorMessage("$0: only one of postal or zip code can be defined\n");
	exit(1);
    }

    if ( defined($opt_retry_limit) ) {
	$config->setValue("option_retry_limit", $opt_retry_limit);
    }

    if ( defined($opt_retry_delay) ) {
	$config->setValue("option_retry_delay", $opt_retry_delay);
    }

    #
    # Go interactive to collect what we don't have
    #

    my $msg="Welcome to XMLTV $VersionID for Canada and US tv listings";
    statusMessage("$msg\n");
    statusMessage("-" x length($msg));
    statusMessage("\nPlease report any problems, bugs or suggestions to:\n");
    statusMessage("\txmltv-users\@lists.sourceforge.net\n");
    statusMessage("For more information consult http://xmltv.sourceforge.net\n\n");
    statusMessage("starting manual configuration process..\n\n");
  
    while ( !defined($config->{option_retry_limit}) ) {
	my $res=ask('how many times do you want to retry on www site failures ? (default=2)');
	if ( !defined($res) || length($res) == 0 ) {
	    $res="2";
	}
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	    $res=int($res);
	    if ( $res >= 0 ) {
		$config->setValue("option_retry_limit", $res);
		last;
	    }
	}
	errorMessage("$0: please specify an integer retry count\n\n");
    }

    while ( !defined($config->{option_retry_delay}) ) {
	my $res=ask('how many seconds do you want to between retries ? (default=30)');
	if ( !defined($res) || length($res) == 0 ) {
	    $res="30";
	}
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	    $res=int($res);
	    if ( $res >= 0 ) {
		$config->setValue("option_retry_delay", $res);
		last;
	    }
	}
	errorMessage("$0: please specify an integer retry delay\n\n");
    }
    $opt_retry_limit=$config->{option_retry_limit};
    $opt_retry_delay=$config->{option_retry_delay};

    # if we have no postal code or zip code, the prompt for it
    if ( !defined($config->{option_postalcode}) && !defined($config->{option_zipcode})) {
	my $res=ask('what is your postal/zip code ?');
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	   # $res=~tr/[a-z]/[A-Z]/;
	    if ( $res=~m/^[a-zA-Z]/o ) {
		$config->setValue("option_postalcode", $res);
	    }
	    else {
		$config->setValue("option_zipcode", $res);
	    }
	}
	else {
	    errorMessage("$0: failed to get postal/zip code\n");
	    exit(1);
	}
    }
    
    # double check or get list of providers and give them the choice
    if ( 1 ) {

	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	statusMessage("\ngetting list of providers for postal/zip code $code, be patient..\n");

	my @providers;
	my $failed=0;
	for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	    if ( $retry != 0 ) {
		errorMessage("failed $retry times, will retry after $opt_retry_delay seconds..\n");
		sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	    }
	    @providers=XMLTV::ZapListings::getProviders($config->{option_postalcode},
						       $config->{option_zipcode},
						       $opt_debug);
	    if ( ! @providers || !defined($providers[0]) ) {
		$failed=1;
	    }
	    else {
		$failed=0;
		last;
	    }
	}
	if ( $failed ) {
	    #errorMessage("$0: failed to get list of providers for postal/zip code $code\n");
	    #errorMessage("   visit zap2it.com and try the postal/zip code for more information\n");
	    exit(1);
	}

	my $defaultProviderId;

	if ( $config->{option_provider} ) {
	    my $still_valid=0;
	    for my $p (@providers) {
		if ( $p->{id} eq $config->{option_provider} ) {
		    if ( $config->{option_provider_desc} ne $p->{description} ) {
			if ( $opt_auto_fail_on_provider_changes ) {
			    statusMessage("provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
					  "\nhas new description (".$p->{description}."), exiting\n");
			    exit(1);
			}
			statusMessage("updating provider description to: $p->{description}\n");
			$config->{option_provider_desc}=$p->{description};
		    }
		    $still_valid=1;
		}
		if ( $config->{option_provider_desc} eq $p->{description} ) {
		    $defaultProviderId=$p->{id};
		}
	    }
	    if ( $still_valid == 0 ) {
		if ( $opt_auto_fail_on_provider_changes ) {
		    statusMessage("provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
				  "\nis no longer valid, exiting\n");
		    exit(1);
		}
		statusMessage("provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
			      "\nis no longer valid, choose a new one\n");
		delete($config->{option_provider});
		delete($config->{option_provider_desc});
	    }
	}

	while ( !$config->{option_provider} ) {
	    statusMessage("\n");
	    my (%descToId, %idToDesc);
	    die "no providers found" if not @providers;
	    foreach ( @providers ) {
		my ($id, $desc) = ($_->{id}, $_->{description});
		die if not defined $id;
		if ( not defined $desc ) {
		    warn "provider with id $id has no description\n";
		    next;
		}

		warn "two providers called $desc\n"
		  if exists $descToId{$desc};
		$descToId{$desc} = $id;
		die "two providers with id $id\n"
		  if exists $idToDesc{$id};
		$idToDesc{$id} = $desc;
	    }
	    if ( defined $defaultProviderId
		 and not exists $idToDesc{$defaultProviderId} ) {
		warn "cannot find default provider $defaultProviderId\n";
		undef $defaultProviderId;
	    }
	    if ( not defined $defaultProviderId ) {
		$defaultProviderId = $providers[0]->{id};
	    }

	    my $res = askQuestion("Choose a service provider: ",
				  $idToDesc{$defaultProviderId},
				  map { $_->{description} } @providers);
	    my $id = $descToId{$res}; die if not defined $id;
	    $config->{option_provider}=$id;
	    $config->{option_provider_desc}=$res;
	    statusMessage("\nyou choose $id \# $res\n");
	}
    }

    # if we're in the configure step, lets refresh the list of channels
    # being careful to warn about additions and deletions
    
    if ( $config->haveAnyChannels() ) {
	statusMessage("\nchecking for changes to channel list, be patient..\n");
    }
    else {
	statusMessage("\ngetting channel list, be patient..\n");
    }

    my @channels;
    my $failed=0;
    for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	if ( $retry != 0 ) {
	    errorMessage("failed $retry times, will retry after $opt_retry_delay seconds..\n");
	    sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	}
	@channels=XMLTV::ZapListings::getChannelList($config->{option_postalcode},
						     $config->{option_zipcode},
						     $config->{option_provider},
						     $opt_debug);
	if ( ! @channels || !defined($channels[0]) ) {
	    $failed=1;
	}
	else {
	    $failed=0;
	    last;
	}
    }

    if ( $failed ) {
	#errorMessage("$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n");
	#errorMessage("   visit zap2it.com and try the postal/zip code for more information\n");
	exit(1);
    }

    my $channelsUpdated=0;
    my $easyAnswer;

    if ( defined($opt_auto_new_channels) ) {
	if ( $opt_auto_new_channels eq "ignore" ) {
	    $easyAnswer='no';
	}
	elsif ( $opt_auto_new_channels eq "add" ) {
	    $easyAnswer='yes';
	}
	else {
	    die "invalid auto_new_channels $opt_auto_new_channels\n";
	}
    }

    # notify user about update channel ids and new channels
    foreach my $channel (@channels) {
	my $station=$channel->{description};
	if ( $config->haveAnyChannels() ) {
	    if ( $config->stationExists($station) ) {
		$config->setStationTransientFlag($station, 'found', 1);
	    }
	    else {
		my $res;
		if ( $easyAnswer ) {
		    $res=$easyAnswer;
		    if ( $res eq 'yes' ) {
			statusMessage("adding channel $station..\n");
		    }
		    else {
			statusMessage("ignoring new channel $station..\n");
		    }
		}
		else {
		    $res=askQuestion("add channel $station ?", 'yes', ('yes', 'no', 'all'));
		    if ( $res eq 'all' ) {
			$easyAnswer='yes';
			$res=$easyAnswer;
		    }
		}
		$config->setStationIncluded($station, ($res eq 'yes'));
		$config->setStationTransientFlag($station, 'found', 1);
		#$config->setStationDescription($station, $channel->{description});
		$channelsUpdated++;
	    }
	}
	else {
	    my $res;
	    if ( $easyAnswer ) {
		$res=$easyAnswer;
		if ( $res eq 'yes' ) {
		    statusMessage("adding channel $station..\n");
		}
	    }
	    else {
		$res=askQuestion("add channel $station ?", 'yes', ('yes', 'no', 'all'));
		if ( $res eq 'all' ) {
		    $easyAnswer='yes';
		    $res=$easyAnswer;
		}
	    }
	    $config->setStationIncluded($station, ($res eq 'yes'));
	    $config->setStationTransientFlag($station, 'found', 1);
	    #$config->setStationDescription($station, $channel->{description});
	    $channelsUpdated++;
	}
    }

    undef($easyAnswer);

    if ( defined($opt_auto_missing_channels) ) {
	if ( $opt_auto_missing_channels eq "ignore" ) {
	    $easyAnswer='no';
	}
	elsif ( $opt_auto_missing_channels eq "remove" ) {
	    $easyAnswer='yes';
	}
	else {
	    die "invalid auto_missing_channels $opt_auto_missing_channels\n";
	}
    }

    # warn about channel declarations we didn't find
    foreach my $station ($config->stationsInDisplayOrder()) {
	if ( defined($config->getStationTransientFlag($station, 'found')) ) {
	    $config->removeStationTransientFlag($station, 'found');
	}
	else {
	    my $res;
	    if ( $easyAnswer ) {
		$res=$easyAnswer;
		if ( $res eq 'yes' ) {
		    statusMessage("removing channel $station..\n");
		}
		else {
		    statusMessage("ignoring missing channel $station..\n");
		}
	    }
	    else {
		$res=askQuestion("remove no-longer available channel $station ?", 'yes', ('yes', 'no', 'all'));
		if ( $res eq 'all' ) {
		    $easyAnswer='yes';
		    $res=$easyAnswer;
		}
	    }
	    if ( $res eq 'yes' ) {
		#errorMessage("warning: didn't find channel id: $station \#".$config->stationDescription($station)."\n");
		$config->stationRemove($station);
		$channelsUpdated++;
	    }
	}
    }

    if ( $channelsUpdated == 0 ) {
	if ( $config->haveAnyChannels() ) {
	    statusMessage("\nchannel line-up hasn't changed\n");
	}
	else {
	    statusMessage("\nno channels added\n");
	}
    } 

    # write out config file
    statusMessage("\nupdating $configfile..\n");
    if ( $config->save($configfile) != 0 ) {
	errorMessage("$0: $configfile save failed\n");
	exit(1);

    }

    statusMessage("\nconfiguration step complete, let the games begin !\n");
    exit(0);
}

# in grabber mode - yeah !

use vars qw/$opt_help $opt_config_file $opt_programs $opt_channels $opt_listings $opt_output $opt_days $opt_debuglistings $opt_offset $opt_retry_limit $opt_retry_delay/;
use vars qw/$opt_gzip_command $opt_zip_command $opt_bzip2_command $opt_listings_overwrite/;

$opt_debuglistings=0;
$opt_gzip_command="gzip";
$opt_zip_command="zip";
$opt_bzip2_command="bzip2";

if ( ! GetOptions('help', 'config-file=s', 'debug', 'programs=s', 'channels=s', 'listings=s', 'output=s', 'days=i', 'debuglistings', 'offset=i', 'retry-limit=i', 'retry-delay=i',  'gzip-command=s', 'zip-command=s', 'bzip2-command=s', 'listings-overwrite=s', 'quiet', 'stats') ) {
    Usage(0);
    exit(1);
}

# translate --quiet flag to a boolean
$opt_quiet=(defined($opt_quiet))?1:0;

# stats are enabled if not specified or if no --quiet used
$opt_stats=(defined($opt_stats))?1:($opt_quiet==1)?0:1;

die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);

# throw error for invalid use of both --listings and --output
if ( defined($opt_output) && defined($opt_listings) ) {
    errorMessage("$0: only one of --listings or --output can be used at once\n");
    exit(1);
}

if ( defined($opt_output) && defined($opt_listings_overwrite) ) {
    errorMessage("$0: --listings-overwrite ignored when --output is used\n");
    $opt_listings_overwrite=undef;
}
if ( !defined($opt_listings_overwrite) ) {
    $opt_listings_overwrite="false";
}

if ( defined($opt_help) ) {
    Usage(1);
    exit(0);
}

#
# detect old style usage
#
if ( defined($opt_programs) || defined($opt_channels) ) {
    errorMessage("$0: new xmltv.dtd format, use --listings instead of\n");
    errorMessage("                --programs and/or --channels\n");
    exit(1);
}

# set defaults if they didn't appear on command line
$opt_days=7 if ( !defined($opt_days) );
$opt_offset=0 if ( !defined($opt_offset) );

if ( $opt_days < 0 || $opt_days > 14 ) {
    errorMessage("specified days must be between 1 and 14\n");
    Usage(0);
    exit(1);
}

STDOUT->autoflush(1);

my @FilesWeOpened_g;

my $failed=grab();

if ( $failed ) {
    if ( @FilesWeOpened_g ) {
	for my $file (@FilesWeOpened_g) {
	    if ( -f $file ) {
		errorMessage("removing $file after failure..\n");
		unlink($file) || warn("unable to remove tv_grab_na file: $file");
	    }
	}
    }
    exit(1);
}
exit(0);

sub writeListingsXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date                  =>Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      'source-info-url'     =>"http://www.zap2it.com",
		      'source-info-name'    =>"Zap2It",
		      'source-data-url'     =>"http://tvlistings2.zap2it.com/textall.asp",
		      'generator-info-name' =>"$VersionID",
		      'generator-info-url'  =>'http://www.sourceforge.net/projects/xmltv');
}

sub writeListingsXMLFooter($)
{
    my $writer=shift;
    $writer->endTag('tv');
}

sub openOutputFileFD($)
{
    my $filename=$_[0];

    if ( $filename=~m/\.gz$/o ) {
        debugMessage("output filter: $opt_gzip_command\n");
	return(new IO::File("| $opt_gzip_command > $filename"));
    }
    elsif ( $filename=~m/\.zip$/o ) {
        debugMessage("output filter: $opt_zip_command\n");
	return(new IO::File("| $opt_zip_command > $filename"));
    }
    elsif ( $filename=~m/\.bz2$/o ) {
        debugMessage("output filter: $opt_bzip2_command\n");
	return(new IO::File("| $opt_bzip2_command > $filename"));
    }
    else {
	return(new IO::File("> $filename"));
    }
}

sub closeOutputFileFD($)
{
    $_[0]->close() if ( defined($_[0]) );
}

sub grab
{
    # initalize global XML::Writer if we're writting listings to stdout
    # or if all listings are to being output'd to a single file.
    # The later allows us to use --listings tv.xml with more than one days listings.
    my $writer_g;

    # output_g is only used if we are writting all Listings to the same file.
    my $output_g;

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config_file) ) {
	if ( ! -f $opt_config_file ) {
	    errorMessage("$0: specified config file '$opt_config_file' does not exist, run --configure\n");
	    return(1);
	}
	$configfile=$opt_config_file;
    }
    else {
	# versions starting with 0.5 have configuration information in $HOME/.xmltv by default.
	if ( defined($ENV{HOME}) && -f "$ENV{HOME}/.xmltv_na" ) {
	    errorMessage("$0: location of config file (~/.xmltv_na) needs upgrade, run --configure\n");
	    $configfile="$ENV{HOME}/.xmltv_na";
	}
	if ( ! -f $configfile ) {
	    errorMessage("$0: config file '$configfile' does not exist, run --configure\n");
	    return(1);
	}
    }

    if ( $config->load($configfile, $opt_debug) != 0 ) {
	errorMessage("$0: Failed to read $configfile\n");
	return(1);
    }
    
    if ( !defined($opt_retry_limit) ) {
	if ( !defined($config->{option_retry_limit}) ) {
	    errorMessage("no retry limit set in configuration, re-run --configure\n");
	    $opt_retry_limit=2;
	}
	else {
	    $opt_retry_limit=$config->{option_retry_limit};
	}
    }

    if ( !defined($opt_retry_delay) ) {
	if ( !defined($config->{option_retry_delay}) ) {
	    errorMessage("no retry delay set in configuration, re-run --configure\n");
	    $opt_retry_delay=30;
	}
	else {
	    $opt_retry_delay=$config->{option_retry_delay};
	}
    }

    # check provider information, usually fast anyway.
    #
    if ( 1 ) {
	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	statusMessage("\nchecking provider information for postal/zip code $code, be patient..\n");

	my @providers;
	my $failed=0;
	for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	    if ( $retry != 0 ) {
		errorMessage("failed $retry times, will retry after $opt_retry_delay seconds..\n");
		sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	    }
	    @providers=XMLTV::ZapListings::getProviders($config->{option_postalcode},
							$config->{option_zipcode},
							$opt_debug);
	    if ( ! @providers || !defined($providers[0]) ) {
		$failed=1;
	    }
	    else {
		$failed=0;
		last;
	    }
	}
	if ( $failed ) {
	    #errorMessage("$0: failed to get list of providers for postal/zip code $code\n");
	    #errorMessage("   visit zap2it.com and try the postal/zip code for more information\n");
	    exit(1);
	}

	my $still_valid=0;
	for my $p (@providers) {
	    if ( $p->{id} eq $config->{option_provider} ) {
		if ( $config->{option_provider_desc} ne $p->{description} ) {
		    errorMessage("provider description changed ($p->{description}), think about re-running --configure\n");
		}
		$still_valid=1;
	    }
	}
	if ( $still_valid == 0 ) {
	    errorMessage("noticed provider changed (for postal/zip code $code), re-run --configure\n");
	    # return failed
	    return(1);
	}
    }

    # collect information about channels.
    if ( 1 ) {
	statusMessage("double checking channel information, be patient..\n");

	my @channels;
	my $failed=0;
	for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	    if ( $retry != 0 ) {
		errorMessage("failed $retry times, will retry after $opt_retry_delay seconds..\n");
		sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	    }
	    @channels=XMLTV::ZapListings::getChannelList($config->{option_postalcode},
							 $config->{option_zipcode},
							 $config->{option_provider},
							 $opt_debug);
	    
	    if ( ! @channels || !defined($channels[0]) ) {
		$failed++;
		#errorMessage("$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n");
		#errorMessage("   visit zap2it.com and try the postal/zip code for more information\n");
		#exit(1);
	    }
	    else {
		$failed=0;
		last;
	    }
	}
	if ( $failed ) {
	    exit(1);
	}
	
	my $channelsUpdated=0;

	# notify user about update channel ids and new channels
	foreach my $channel (@channels) {
	    my $station=$channel->{description};
	    if ( $config->haveAnyChannels() ) {
		if ( $config->stationExists($station) ) {
		    $config->setStationTransientFlag($station, 'found', 1);

		    # save zap2it channel id for grabbing url usage
		    $config->setStationTransientFlag($station, 'zap2it-id', $channel->{stationid});
		    
		    if ( defined($channel->{icon}) ) {
			$config->setStationIcon($station, $channel->{icon});
		    }
		}
		else {
		    errorMessage("noticed new station available ($station), re-run --configure\n");
		}
	    }
	    else {
		errorMessage("noticed new station available ($station), re-run --configure\n");
	    }
	}

	# warn about channel declarations we didn't find
	foreach my $station ($config->stationsInDisplayOrder()) {
	    if ( defined($config->getStationTransientFlag($station, 'found')) ) {
		$config->removeStationTransientFlag($station, 'found');
	    }
	    else {
		errorMessage("noticed station unavailable ($station), re-run --configure\n");
		$config->setStationTransientFlag($station, 'notavailable', 1);
	    }
	}

	if ( $channelsUpdated++ ) {
	    errorMessage("some channel information is out of date, re-run --configure\n");
	}
    }

    my $stats;

    $stats->{num_channels}=0;
    $stats->{num_programs}=0;
    $stats->{num_days}=0;
    $stats->{num_readScheduleFailed}=0;
    $stats->{num_alreadyHad}=0;

    # start time only includes programming grabs, no channel detail grab
    my $startTime=time();
    my $listingsDefinition;
    my $overwrite;

    # implement --output as synonym for --listings
    if ( defined($opt_output) ) {
	$listingsDefinition=$opt_output;
	undef($opt_output);
	$overwrite=1;
    }
    elsif ( defined($opt_listings) ) {
	$listingsDefinition=$opt_listings;
	$overwrite=($opt_listings_overwrite eq "true");
    }
    else {
	$listingsDefinition=undef; # stdout
	$overwrite=0;
    }

    if ( defined($listingsDefinition) ) {
	# do %postalcode and %zipcode substitutions now since they can't change
	# if they don't appear, we remove them
	if ( defined($config->{option_postalcode}) ) {
	    $listingsDefinition=~s/%(postal|zip)code/$config->{option_postalcode}/og;
	}
	elsif ( defined($config->{option_zipcode}) ) {
	    $listingsDefinition=~s/%(postal|zip)code/$config->{option_zipcode}/og;
	}
	else {
	    $listingsDefinition=~s/%(postal|zip)code//og;
	}
    }

    my $skipAllGrabs;
    if ( !defined($listingsDefinition) ) {
	statusMessage("writing listings to stdout\n");
	$writer_g = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 2 );
	writeListingsXMLHeader($writer_g);
	$stats->{num_channels}=writeOutChannels($config, $writer_g);
	$skipAllGrabs=0;
    }
    elsif ( UnixDate("now","$listingsDefinition") eq $listingsDefinition ) {
	if ( !$overwrite && -f $listingsDefinition ) {
	    statusMessage("listings in $listingsDefinition exist, skipping\n");
	    $stats->{num_alreadyHad}++;
	    $skipAllGrabs=1;
	}
	else {
	    mkpathtofile($listingsDefinition) || die "mkdir $listingsDefinition:$!";
	    statusMessage("writing listings to $listingsDefinition\n");
	    $output_g = openOutputFileFD($listingsDefinition) || die "$listingsDefinition: $!";
	    push(@FilesWeOpened_g, $listingsDefinition);
	    $writer_g = new XML::Writer(OUTPUT=>$output_g,
					DATA_MODE => 1, DATA_INDENT => 2 );
	    writeListingsXMLHeader($writer_g);
	    $stats->{num_channels}=writeOutChannels($config, $writer_g);
	    $skipAllGrabs=0;
	}
    }

    if ( !$skipAllGrabs ) {
 	my $failedCount=0;
	my ($y,$m,$d,$h,$mn,$s)=Date::Manip::Date_Split(ParseDateString("now"));
	my $startNDay=Date_DayOfYear($m,$d,$y);
	my $tz=Date_TimeZone();
	
	my $failHardOnReadScheduleFailure=0;
	
	#
	# So that the output a day at a time, this allows for separate files per day
	#
	my $year=$y;
	my $runNDayOfYear=$startNDay + $opt_offset;
	for (my $nday=0; $nday<$opt_days ; $nday++) {
	    my $writer;
	    my $output;

	    # handle cross-year listings
	    while ( $runNDayOfYear+$nday > Date_DaysInYear($year) ) {
		$runNDayOfYear-=Date_DaysInYear($year);
		$year++;
	    }
	
	    $stats->{num_days}++;;

	    my $dateStr=createDateString(0, $runNDayOfYear+$nday, $year, 0, $tz);

	    my $dayFilename;
	    my $skipGrabThisFileExists;
	    if ( defined($writer_g) ) {
		$writer=$writer_g;
		$skipGrabThisFileExists=0;
	    }
	    else {
		$dayFilename=UnixDate($dateStr, "$listingsDefinition");
		if ( $listingsDefinition eq $dayFilename ) {
		    die "This case should have been caught before here";
		}
		if ( !$overwrite && -f $dayFilename ) {
		    statusMessage("listings in $dayFilename exist, skipping\n");
		    $stats->{num_alreadyHad}++;
		    $skipGrabThisFileExists=1;
		}
		else {
		    mkpathtofile($dayFilename) || die "mkdir $listingsDefinition:$!";
		    statusMessage("writing listings to $dayFilename\n");
		    $output = openOutputFileFD($dayFilename) || die "$dayFilename: $!";
		    $writer = new XML::Writer(OUTPUT=>$output,
					      DATA_MODE => 1, DATA_INDENT => 2 );
		    writeListingsXMLHeader($writer);
		    $stats->{num_channels}=writeOutChannels($config, $writer);
		    $skipGrabThisFileExists=0;
		}
	    }
	    
	    if ( !$skipGrabThisFileExists ) {
		my $failEntireDay=0;

		my $lg=new XMLTV::ZapListings::Scraper('PostalCode'=>$config->{option_postalcode},
						       'ZipCode'   =>$config->{option_zipcode},
						       'ProviderID'=>$config->{option_provider},
						       'Debug'     =>$opt_debug,
						       'DebugListings'=>$opt_debuglistings);
		
		foreach my $station ($config->stationsInDisplayOrder()) {
		    
		    next if ( !$config->stationIncluded($station) );
		    
		    if ( defined($config->getStationTransientFlag($station, 'notavailable')) ) {
			statusMessage("skipping unavailable channel $station\n");
			next;
		    }
		    
		    if ( !defined($config->getStationTransientFlag($station, 'zap2it-id')) ) {
			warn "ignoring channel without zap2it channel id $station\n";
			next;
		    }
		    
		    my ($Year,$month,$day,$hr,$min,$sec)=Date::Manip::Date_NthDayOfYear($year, $runNDayOfYear+$nday);
		    
		    for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
			if ( $retry != 0 ) {
			    errrorMessage("failed $retry times, will retry after $opt_retry_delay seconds..\n");
			    sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
			}
			my $ret=$lg->readSchedule($config->getStationTransientFlag($station, 'zap2it-id'),
					       $station,
					       $day, $month, $Year);
			if ( $ret == -1) {
			    errrorMessage("failed to read schedule for $Year-$month-$day for station $station\n");
			    # fail hard on first failure
			    $failedCount++;
			}
			elsif ( $ret == -2 ) {
			    errrorMessage("unretry-able error reading schedule for $Year-$month-$day for station $station\n");
			    # fail hard on first failure
			    $failedCount++;
			    last;
			}
			else {
			    $failedCount=0;
			    last;
			}
		    }
		    
		    if ( $failedCount ) {
			# hard failure means fail the entire grab when any channel's
			# schedule fails to come
			if ( $failHardOnReadScheduleFailure ) {
			    if ( !defined($writer_g) || $writer != $writer_g ) {
				writeListingsXMLFooter($writer);
				$writer->end();
				closeOutputFileFD($output);
			    }
			    if ( defined($writer_g) ) {
				writeListingsXMLFooter($writer_g);
				$writer_g->end();
				closeOutputFileFD($output_g) if ( defined($output_g) );
			    }
			    if ( defined($dayFilename) ) {
				unlink($dayFilename) || warn("unable to remove tv_grab_na file: $dayFilename");
			    }
			    return($failedCount);
			}
			else {
			    # if we're writting to files, one per day, fail entire
			    # day (the file) if any channel fails
			    if ( !defined($writer_g) || $writer != $writer_g ) {
				$failEntireDay=1;
				last; # break early
			    }
			    else {
				# writting to stdout, so just track these
				$stats->{num_readScheduleFailed}++;
			    }
			}
		    }
		    else {
			# set time zone for date conversions
			#Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
			#Date::Manip::Date_Init();
			
			$stats->{num_programs}+=writeOutPrograms($lg, $runNDayOfYear+$nday, $Year, $tz, $writer, $station);
		    }
		}

		if ( !defined($writer_g) || $writer != $writer_g ) {
		    writeListingsXMLFooter($writer);
		    $writer->end();
		    closeOutputFileFD($output);
		}
		if ( $failEntireDay ) {
		    if ( defined($dayFilename) ) {
			errrorMessage("channel schedule failed, so we're removing $dayFilename\n");
			unlink($dayFilename) || warn("unable to remove tv_grab_na file: $dayFilename");
		    }
		}
		else {
		    push(@FilesWeOpened_g, $dayFilename) if ( defined($dayFilename) );
		}
	    }
	}
    }

    if ( defined($writer_g) ) {
	writeListingsXMLFooter($writer_g);
	$writer_g->end();
	closeOutputFileFD($output_g) if ( defined($output_g) );
    }

    if ( $opt_stats ) {
	my $endTime=time();

	$stats->{calcProgramsPerSecond}=($endTime!=$startTime &&
					 $stats->{num_programs} != 0)?
					     $stats->{num_programs}/($endTime-$startTime): 0;
	
	$stats->{calcSecondsPerlWWWPage}=($endTime!=$startTime &&
					  $stats->{num_days}*$stats->{num_channels}!=0)?
					      ($endTime-$startTime)/($stats->{num_days}*$stats->{num_channels}): 0;
	
	statsMessage(sprintf("Grabbed %d programs on %d channels over %d day(s) in %d seconds\n",
			     $stats->{num_programs},
			     $stats->{num_channels},
			     $stats->{num_days},
			     $endTime-$startTime));
	
	statsMessage(sprintf("  not too bad, that's %.2f programs/sec and %.2f seconds/www page\n",
			     $stats->{calcProgramsPerSecond}, $stats->{calcSecondsPerlWWWPage}));
	
	if ( $stats->{num_readScheduleFailed} != 0 ) {
	    statsMessage(sprintf("  does not include %d failed channel schedules\n",
				 $stats->{num_readScheduleFailed}));
	}
	if ( $stats->{num_alreadyHad} != 0 ) {
	    statsMessage(sprintf("  does not include %d output file(s) that already existed\n",
				 $stats->{num_alreadyHad}));
	}
    }
    return(0);
}

# create a conversion string
sub createDateString($$$$$)
{
    my ($minuteOfDay, $dayOfYear, $year, $additionalMin, $time_zone)=@_;
    
    if ( $additionalMin != 0 ) {
	$minuteOfDay+=$additionalMin;

	# deal with case where additional minutes pushes us over end of day
	if ( $minuteOfDay > 24*60 ) {
	    $minuteOfDay-=24*60;
	    $dayOfYear++;

	    # check and deal with case where this pushes us past end of year
	    my $isleap=Date_LeapYear($year);
	    if ($dayOfYear >= ($isleap ? 367 : 366)) {
		$year++;
		$dayOfYear-=($isleap ? 367 : 366);
	    }
	}
    }

    # account for end of year boundaries
    while ( $dayOfYear > Date_DaysInYear($year) ) {
	$dayOfYear-=Date_DaysInYear($year);
	$year++;
    }

    # calculate year,month and day from nth day of year info
    my ($pYEAR,$pMONTH,$pDAY,$pHR,$pMIN,$pSEC)=Date::Manip::Date_NthDayOfYear($year, $dayOfYear);

    # set HR and MIN to what they should really be
    $pHR=int($minuteOfDay/60);
    $pMIN=$minuteOfDay-($pHR*60);

    return(sprintf("%4d%02d%02d%02d%02d00 %s", $pYEAR, $pMONTH, $pDAY, $pHR, $pMIN, $time_zone));
}

sub writeOutPrograms($$$$$$)
{
    my ($lg, $dayOfYear, $year, $mytz, $writer, $channel)=@_;
    my $IncludePartialPrograms=0;

    my @programs=$lg->getPrograms();

    for my $progTop (@programs) {
	my $prog=$progTop;

	if ( $opt_debug ) {
	    debugMessage("before write: prog:".XMLTV::ZapListings::Scraper::dumpMe($prog)."\n");
	}

	$prog->{start}=createDateString(($prog->{start_hour}*60+$prog->{start_min}), $dayOfYear, $year, 0, $mytz);
	delete($prog->{start_hour});
	delete($prog->{start_min});
	if ( $prog->{end_hour} >= 24 ) {
	    $prog->{end}=createDateString((($prog->{end_hour}-24)*60+$prog->{end_min}), $dayOfYear+1, $year, 0, $mytz);
	}
	else {
	    $prog->{end}=createDateString(($prog->{end_hour}*60+$prog->{end_min}), $dayOfYear, $year, 0, $mytz);
	}
	delete($prog->{end_hour});
	delete($prog->{end_min});

	my $title=$prog->{title};
	delete($prog->{title});
	    
	#debugMessage("storing $title..\n");

	if ( defined($prog->{contFromPreviousListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#errorMessage("warning: not including program $prog->{title} which starts previous to listing\n");
		next;
	    }
	    $title="(<-cont) $title";
	    delete($prog->{contFromPreviousListing});
	}
	if ( defined($prog->{contToNextListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#errorMessage("warning: not including program $prog->{title} which ends past listing boundaries\n");
		next;
	    }
	    $title="$title (cont->)";
	    delete($prog->{contToNextListing});
	}
	
	$writer->startTag('programme', start=> $prog->{start}, 
			  stop => $prog->{end}, channel=> "$channel");
	delete($prog->{start});
	delete($prog->{end});

	if ( defined($prog->{precomment}) ) {
	    # -- in comments causes carp() calls in Writer.pm
	   $prog->{precomment}=~s/\-\-/\=\=/og;

	   # imbed in programme output a comment
	   # this is here for debugging listings and their results
	   $writer->comment("\n   ".$prog->{precomment});
	   delete($prog->{precomment});
	}
	$writer->dataElement('title', $title);
	if ( defined($prog->{subtitle}) ) {
	    $writer->dataElement('sub-title', $prog->{subtitle});
	    delete($prog->{subtitle});
	}

	if ( defined($prog->{qualifiers}) ) {
	    for my $qf ('Live', 'Taped', 'If Necessary', 'Subject to Blackout') {
		if ( defined($prog->{qualifiers}->{$qf}) ) {
		    # nowhere in xmltv.dtd to put this
		    if ( defined($prog->{desc}) ) {
			if ( $prog->{desc}=~m/\)$/o ) {
			    $prog->{desc}.="($qf)" ;
			}
			else {
			    $prog->{desc}.=" ($qf)" ;
			}
		    }
		    delete($prog->{qualifiers}->{$qf});
		}
	    }
	}

	if ( defined($prog->{desc}) ) {
	    $writer->dataElement('desc', $prog->{desc});
	    delete($prog->{desc});
	}
		
	if ( defined($prog->{director}) || defined($prog->{actors}) ) {
	    $writer->startTag('credits');
	    $writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
	    if ( defined($prog->{actors}) ) {
		foreach my $actor (@{$prog->{actors}}) {
		    $writer->dataElement('actor', $actor);
		}
	    }
	    $writer->endTag('credits');
	    delete($prog->{director}) if ( defined($prog->{director}) );
	    delete($prog->{actors}) if ( defined($prog->{actors}) );
	}
	if ( defined($prog->{year}) ) {
	    $writer->dataElement('date', $prog->{year});
	    delete($prog->{year});
	}
	
	if ( defined($prog->{category}) ) {
	    foreach my $cat(@{$prog->{category}}) {
		$writer->dataElement('category', $cat);
	    }
	    delete($prog->{category});
	}

	# hunt for things in the "qualifiers bucket" where alot of things fall.
	if ( defined($prog->{qualifiers}) ) {
	    if ( defined($prog->{qualifiers}->{Language}) ) {
		if ( defined($prog->{qualifiers}->{Dubbed}) ) {
		    $writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		    $writer->dataElement('language', $prog->{qualifiers}->{Dubbed});
		    delete($prog->{qualifiers}->{Dubbed});
		}
		else {
		    $writer->dataElement('language', $prog->{qualifiers}->{Language});
		}
		delete($prog->{qualifiers}->{Language});
	    }
	    
	    if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		# nowhere to put this
		# comes in the form of "Part 1 of 2"
		$writer->dataElement('episode-num', $prog->{qualifiers}->{PartInfo});
		delete($prog->{qualifiers}->{PartInfo});
	    }
	    if ( defined($prog->{qualifiers}->{HDTV}) ) {
		# nowhere to put this 
		delete($prog->{qualifiers}->{HDTV});
	    }
	    if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		$writer->startTag('video');
		$writer->dataElement('colour', 'no');
		$writer->endTag('video');
		delete($prog->{qualifiers}->{BlackAndWhite});
	    }
	    if ( defined($prog->{qualifiers}->{InStereo}) ) {
		$writer->startTag('audio');
		# The 'stereo' element requires some text inside it,
		# so you have to say <stereo>stereo</stereo>.  :-P.
		$writer->dataElement('stereo', 'stereo');
		$writer->endTag('audio');
		delete($prog->{qualifiers}->{InStereo});
	    }
	    if ( defined($prog->{qualifiers}->{PreviouslyShown}) ) {
		# Write as <previously-shown /> to indicate there is
		# no textual content, not even the empty string :-).
		$writer->emptyTag('previously-shown');
		delete($prog->{qualifiers}->{PreviouslyShown});
	    }
	    if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		$writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
		delete($prog->{qualifiers}->{PremiereShowing});
	    }
	    if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		$writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
		delete($prog->{qualifiers}->{LastShowing});
	    }

	    if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		$writer->startTag('subtitles', 'type' => 'onscreen');
		$writer->dataElement('language', $prog->{qualifiers}->{Subtitles});
		$writer->endTag('subtitles');
		delete($prog->{qualifiers}->{Subtitles});
	    }
	    elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		$writer->emptyTag('subtitles', 'type' => "teletext");
		delete($prog->{qualifiers}->{ClosedCaptioned});
	    }
	    if ( scalar(keys %{$prog->{qualifiers}}) == 0 ) {
		delete($prog->{qualifiers});
	    }
	}
	if ( defined($prog->{ratings_VCHIP}) ) {
	    $writer->startTag('rating', system => 'VCHIP');
	    if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		$writer->dataElement('value', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}");
		delete($prog->{ratings_VCHIP_Expanded});
	    }
	    else {
		$writer->dataElement('value', $prog->{ratings_VCHIP});
	    }
	    $writer->endTag('rating');
	    delete($prog->{ratings_VCHIP});
	}
	if ( defined($prog->{ratings_MPAA}) ) {
	    $writer->startTag('rating', 'system' =>'MPAA');
	    $writer->dataElement('value', $prog->{ratings_MPAA});
	    $writer->endTag('rating');
	    delete($prog->{ratings_MPAA});
	}
	if ( defined($prog->{ratings_ESRB}) ) {
	    $writer->startTag('rating', 'system' => 'ESRB');
	    $writer->dataElement('value', $prog->{ratings_ESRB});
	    $writer->endTag('rating');
	    delete($prog->{ratings_ESRB});
	}
	if ( defined($prog->{ratings_Warnings}) ) {
	    my %hash;
	    foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		$hash{$k}=1;
	    }
	    foreach my $k ( keys %hash ) {
		$writer->startTag('rating', 'system' => 'General Warning');
		$writer->dataElement('value', $k);
		$writer->endTag('rating');
	    }
	    delete($prog->{ratings_Warnings});
	}
	if ( defined($prog->{star_rating}) ) {
	    # comes in the form of a rating out fraction X/Y (X out of Y)
	    $writer->startTag('star-rating');
	    $writer->dataElement('value', $prog->{star_rating});
	    $writer->endTag('star-rating');
	    delete($prog->{star_rating});
	}

	if ( scalar(keys %$prog) != 0 ) {
	    if ( $opt_debuglistings ) {
		$writer->comment("\n   Left Over keys:".XMLTV::ZapListings::Scraper::dumpMe($prog));
	    }
	    if ( $opt_debug ) {
		debugMessage("after write: prog:".XMLTV::ZapListings::Scraper::dumpMe($prog)."\n");
	    }
	}
	$writer->endTag('programme');
    }
    return(scalar(@programs));
}

# write the channels in xml format
sub writeOutChannels($$)
{
    my ($config, $writer)=@_;

    my $count=0;
    foreach my $station ($config->stationsInDisplayOrder()) {
	
	next if ( defined($config->getStationTransientFlag($station, 'notavailable')) );
	next if ( !$config->stationIncluded($station));

	$writer->startTag('channel', id=> $station);

	# just for testing - may be enabled (properly supported) in a future release 
	if ( 0 ) {
	    if ( defined($config->getStationTransientFlag($station, 'zap2it-id')) ) {
		$writer->emptyTag('channel-id', system=>"TMSID",
				  id=>$config->getStationTransientFlag($station, 'zap2it-id'));
	    }
	}

	# just for testing - may be enabled (properly supported) in a future release 
	if ( 0 ) {
	    if ( $station=~m/^\s*(\d+)\s*(.*)/o ) {
		my $number=$1;
		my $callletters=$2;
		$writer->dataElement('channel-number', $number);
		$writer->dataElement('channel-callletters', $callletters);
	    }
	}

	$writer->dataElement('display-name', "Channel $station");
	if ( defined($config->stationIcon($station)) ) {
	    # Write as empty tag because icon can never contain anything.
	    $writer->emptyTag('icon', 'src'=>$config->stationIcon($station));
	}

	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
	$count++;
    }

    return($count);
}

1;
