#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_grab_na - Grab Canadian and US TV listings.

=head1 SYNOPSIS

tv_grab_na [--help] [--debug] [--config-file FILE] --configure CONFIG_OPTIONS

tv_grab_na [--help] [--debug] [--config-file FILE] GRAB_OPTIONS

=head1 DESCRIPTION

Output TV listings for Canada and the USA in XMLTV format.  The data
currently comes from the zap2it.com site.

First you must run B<tv_grab_na --configure> to set your local area,
service provider and which channels you wish to download.  Then
running B<tv_grab_na> with no arguments will get a weekE<39>s listings
for the channels you chose.  If the upstream data changes (for
example, new channels appear) you will be prompted to rerun
B<--configure> to update your choices.

Some options are available in both configure and grab mode:

B<--help> Print help to standard output and exit successfully.

B<--debug> Turn on debugging checks.

B<--config-file FILE> The location of the config file, which is
written in configure mode and read in grab mode.  The default location
is B<~/.xmltv/tv_grab_na>.

Configuration is normally interactive, but it can be run
noninteractively, usually to update an existing set of choices.  The
following options are used to invoke --configure in a non-interactive
mode:

B<--retry-limit X> Specify retry limit on www site failures.

B<--retry-delay X> Specify number of seconds to delay before retrying
www site failures.

B<--postalcode X>, B<--zipcode X> Specify your postal code or zip code.

B<--provider ID> Specify the id of your service provider.  This is a
number assigned by the zap2it site.  During interactive configuration
you are presented with a list of provider names, but if you already
know the id you can specify it here.

B<--auto-fail-on-provider-changes BOOLEAN> If true, exit with failure
if the provider id has changed on the zap2it site.

B<--auto-new-channels [ignore|add]> Ignore or automatically add new
channels in schedule listing.

B<--auto-missing-channels [ignore|remove]> Ignore or remove channels
no longer in schedule listing.

Interactive mode is entered if some necessary information is not given
(for example no postal or zip code in the existing configuration file,
and not given on the command line).

After successful configuration you can start grabbing.  The options
here are:

B<--debuglistings> Add debugging information to the output as XML
comments.

B<--listings FILE>, B<--output FILE> Write output to FILE rather than
standard output.  FILE may contain L<date(1)> style substitutions, for
example use B<--listings "listings-%d%m%Y.xml"> to separate output by
day.   Similarily, B<%postalcode> and B<%zipcode> are also substituted from
settings current configuration.  The filename is only re-evaluated
when a new dayE<39>s listings is started.

B<--days N> When grabbing, grab N days of listings.  The default is 7.

B<--offset N> Number of days in the future to offset the start of the
listings.  The default is 0, meaning today.

B<--retry-limit X> Specify retry limit on www site failures.

B<--retry-delay X> Specify number of seconds to delay before retrying
www site failures.

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.zap2it.com/>

=head1 AUTHOR

Jerry Veldhuis, jerry@matilda.com

=head1 BUGS

There is no way to get listings for only part of each day; the old
B<--startHour> and B<--endHour> options no longer exist.  This makes
grabbing slower than it needs to be if you only want listings for
certain hours.

The zap2it site has a long list of program qualifiers such as Live,
Animated, HDTV and so on.  Most of these are understood by tv_grab_na
and included in the XMLTV output.  But some new ones pop up
occasionally and generate a warning message (which should be reported
to the author).  Some qualifiers such as Live donE<39>t yet have a
good translation into XMLTV format.

=cut

my $VersionMajor=2;
my $VersionMinor;

my $Date = q$Date$;
if ( !($Date=~m;^\s*Date: (\d{4})/(\d\d)/(\d\d) \d\d:\d\d:\d\d\s*$;)) {
    die "can't decipher date line ($Date)\n";
}
else {
    # Take the day as the minor version, eg 20020224.
    $VersionMinor="$1$2$3";
}

my $VersionID="tv_grab_na V$VersionMajor\.$VersionMinor";

#
# define name of tv_grab_na config file
#
my $ConfigFileName_g="tv_grab_na";
my $ConfigPathName_g;

# default location of config file is $HOME or ./ if HOME not set
if ( defined($ENV{HOME}) ) {
    $ConfigPathName_g="$ENV{HOME}/.xmltv/$ConfigFileName_g";
}
else {
    $ConfigPathName_g="./$ConfigFileName_g";
}

use strict;

package myConfig;

sub new
{
    my($type) = shift;
    my $self={ @_ };            # remaining args become attributes
    
    bless($self, $type);
    return($self);
}

sub setValue($$$)
{
    my ($self, $key, $value)=@_;
    $self->{$key}=$value;
    if ( $key ne "option_postalcode" &&
	 $key ne "option_zipcode" &&
	 $key ne "option_provider" &&
	 $key ne "option_provider_desc" &&
	 $key ne "option_retry_limit" &&
	 $key ne "option_retry_delay" ) {
	die "attempt to set invalid key $key to $value";
    }
}

sub unsetValue($$$)
{
    my ($self, $key, $value)=@_;
    delete($self->{$key}) if ( defined($self->{$key}));
}

#
# get list of stations in display-name order
#
# sad but true, I can't figure a better way of
# doing this, but then again I don't care - jv
#
sub stationsInDisplayOrder($)
{
    my $self=shift;

    # create reverse hash with key/values swapped
    my @nums;
    foreach my $station (keys (%{$self->{channels}})) {
	my $key=0;
	if ( $station=~m/^\s*(\d+)/o ) {
	    $key=$1;
	}
	# seems very odd, but occasionally, you get two channels with the
	# same channel # on the dial
	if ( defined($nums[$key]) ) {
	    $nums[$key]="$nums[$key],$station";
	}
	else {
	    $nums[$key]="$station";
	}
    }
    
    my @ret;
    for (my $n=0; $n<scalar(@nums) ; $n++ ) {
	if ( defined($nums[$n]) ) {
	    push(@ret, sort (split(',', $nums[$n])))
	}
    }
    return(@ret);
}

sub haveAnyChannels($)
{
    my $self=shift;
    return(defined($self->{channels}));
}

sub stationRemove($$)
{
    my ($self, $station)=@_;
    delete($self->{channels}->{$station});
}

sub stationExists($$)
{
    my ($self, $station)=@_;
    return(defined($self->{channels}->{$station}));
}

sub setStationIncluded($$$)
{
    my ($self, $station, $in)=@_;
    $self->{channels}->{$station}->{in}=$in;
}

sub stationIncluded($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{in});
}

sub stationIcon($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{icon});
}

sub setStationIcon($$$)
{
    my ($self, $station, $icon)=@_;
    $self->{channels}->{$station}->{icon}=$icon;
}

sub setStationTransientFlag($$$$)
{
    my ($self, $station, $flag, $value)=@_;
    $self->{channels}->{$station}->{transient}->{$flag}=$value;
}

sub getStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    return($self->{channels}->{$station}->{transient}->{$flag});
}

sub removeStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    delete($self->{channels}->{$station}->{transient}->{$flag});
}

sub save($$)
{
    my ($self, $file)=@_;

    if ( main::mkpathtofile($file, 0) != 1 ) {
	print STDERR "mkdir failed on directory for $file:$!\n";
	return(-1);
    }

    open(FD, "> $file") || return(-1);
    print FD "# config file: tv_grab_na $VersionMajor.$VersionMinor\n";
    print FD "#\n";
    print FD "# this file is generated by running tv_grab_na --configure\n";
    print FD "# the only change you should make is prefixing 'channel:' lines\n";
    print FD "# with a '#' to signal that they should be ignored during the\n";
    print FD "# grab step\n";
    print FD "#\n";
    if ( defined($self->{option_retry_limit})) {
	print FD "retry limit: $self->{option_retry_limit}\n";
    }
    if ( defined($self->{option_retry_delay})) {
	print FD "retry delay: $self->{option_retry_delay}\n";
    }
    if ( defined($self->{option_postalcode})) {
	print FD "postal code: $self->{option_postalcode}\n";
    }
    if ( defined($self->{option_zipcode}) ) {
	print FD "zip code: $self->{option_zipcode}\n";
    }
    print FD "provider: $self->{option_provider} \# ".
	$self->{option_provider_desc}."\n";
    
    foreach my $station ($self->stationsInDisplayOrder()) {
	if ( $self->stationIncluded($station) ) {
	    print FD "channel: $station\n"
	}
	else {
	    print FD "#channel: $station\n";
	}
    }
    close(FD);
    return(0);
}

sub load($$$)
{
    my ($self, $file, $debug)=@_;

    my $majorVersion;
    open(FD, "< $file") || return(-1);
    while (<FD>) {
	s/\n$//o;

	# auto-upgrading from version 1 to 2
	if ( defined($majorVersion) && $majorVersion == 1 ) {
	    if ( m/^\#+channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="#channel: $2";
	    }
	    elsif ( m/^channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="channel: $2";
	    }
	}

	if ( $. == 1 ) {
	    if ( m/^\#\s+config\s+file:\s*(?:g.tlistings|tv_grab)_na (\d+)\.(\d+)/o ) {
		$majorVersion=$1;
		if ( $1 == 1 ) {
		    print STDERR "$file: older format identified, coping, re-run --configure to upgrade\n";
		}
		elsif ( $1 != $VersionMajor || $2 > $VersionMinor ) {
		    print STDERR "$0: $file:$.: $1\.$2 is an unsupported version number\n";
		    close(FD);
		    return(-1);
		}
	    }
	    else {
		print STDERR "$0: $file:$.: unsupported version header\n";
		close(FD);
		return(-1);
	    }
	}
	elsif ( m/^retry limit:\s*([^\s]+)$/o ) {
	    $self->setValue("option_retry_limit", $1);
	}
	elsif ( m/^retry delay:\s*([^\s]+)$/o ) {
	    $self->setValue("option_retry_delay", $1);
	}
	elsif ( m/^postal code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_postalcode", $1);
	}
	elsif ( m/^zip code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_zipcode", $1);
	}
	elsif ( m/^provider:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->setValue("option_provider", $1);
	    $self->setValue("option_provider_desc", $2);
	}
	elsif ( m/^\#+channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 0);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 1);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^#/o ) {
	    next;
	}
	elsif ( m/^\s*$/o ) {
	    # ignore empty lines
	}
	else {
	    print STDERR "$0: $file:$.: invalid\n";
	    close(FD);
	    return(-1);
	}
	   
    }
    close(FD);
    if ( defined($self->{option_postalcode}) && defined($self->{option_zipcode})) {
	print STDERR "$0: $file: corrupt, only one of postal or zip can be defined\n";
	return(-1);
    }
    return(0);
}

1;

package main;

use strict;
#use diagnostics;
use Fcntl qw(:DEFAULT);
use XML::Writer;
use IO;
use Getopt::Long;
use Date::Manip;
use File::Basename;

use XMLTV::ZapListings;
use XMLTV::Ask;

sub mkpathtofile($$)
{
    my ($file, $debug)=@_;
    my @paths;

    my $path=dirname($file);
    if ( -d $path ) {
	return(1);
    }
    print STDERR "making path: $path..\n" if ( $debug );
    while (length($path)!=0 && $path ne "." && $path ne "/" ) {
	push(@paths, $path);
	$path=dirname($path);
    }

    foreach my $dir (@paths) {
	if ( ! -d $dir ) {
	    print STDERR "mkdir($dir, 0775)\n" if ( $debug > 1 );
	    mkdir($dir, 0775) || return(-1);
	}
	else {
	    print STDERR "$dir exists, not making\n" if ( $debug > 1);
	}
    }
    return(1);
}

#
# How this grabber works:

# Step 1 - Configure
#  
#   The configure step is meant to be run interactively.
#   You can use 'tv_grab_na --configure --help' to see
#   how to run non-interactively, providing information on
#   the command line.

#   run 'tv_grab_na --configure'
#
#   Follow the prompts to provide the necessary information.
#
#   When finished, configure will create a file $HOME/$ConfigFileName_g
#   which contains the postal/zip code, the provider id
#   and a line for each channel that provider supplies.
#   This file is what you specify with the --config command
#   line option to "Step 2 Grabbing Data". See Step 2 for details
#   of how this file is interpreted.
#

sub ConfigureUsage($)
{
    no strict 'subs';
    no strict 'refs';
    my $stdout=shift;

    my $fp=STDERR;
    if ( $stdout ) {
	$fp=STDOUT;
    }
    print $fp "usage $0 --configure [options]\n";
    print $fp "where options are:\n";
    print $fp "   --help\n";
    print $fp "     print $fp configure help\n";
    print $fp "\n";
    print $fp "   --debug\n";
    print $fp "     turn on debugging\n";
    print $fp "\n";
    print $fp "   --postalcode XXXXXX\n";
    print $fp "     specify postal code, don't use with --zipcode\n";
    print $fp "\n";
    print $fp "   --zipcode YYYYYY\n";
    print $fp "     specify zip code, don't use with --postalcode\n";
    print $fp "\n";
    print $fp "   --provider ZZZZZZZ\n";
    print $fp "     specify provider id\n";
    print $fp "\n";
    print $fp "   --config-file <file>\n";
    print $fp "     write results of configure to <file> instead of \$HOME/$ConfigFileName_g\n";
    print $fp "\n";
    print $fp "  The following options are used to invoke --configure in a non-interactive mode\n";
    print $fp "   --auto-fail-on-provider-changes <boolean>\n";
    print $fp "     true/false - exit 1 if provider has changed\n";
    print $fp "\n";
    print $fp "   --auto-new-channels [ignore|add]\n";
    print $fp "     ignore/add - ignore or automatically add new channels in schedule listing\n";
    print $fp "\n";
    print $fp "   --auto-missing-channels [ignore|remove]\n";
    print $fp "     ignore/remove - ignore or remove channels no longer in schedule listing\n";
    print $fp "\n";
    print $fp "   --retry-limit <count>\n";
    print $fp "       upon possible www site failure, retry <count> times before hard failure.\n";
    print $fp "       (default 2)\n";
    print $fp "\n";
    print $fp "   --retry-delay <seconds>\n";
    print $fp "       number of seconds to sleep between retries (default 30).\n";
    print $fp "\n";
    print $fp "If any neccessary options are given, interactive mode is enabled\n";
    print $fp "(ie no postal/zip code in config file and not on command line)\n";
    print $fp "Result of running configure is a configuration file\n";
    print $fp "\$HOME/$ConfigFileName_g (use --config to override location).\n";
}

# Step 2 - Grab
#   
#   The grab step uses the information collected during
#   configuration to get tv listings.
#  
#
#

sub Usage($)
{
    no strict 'subs';
    no strict 'refs';
    my $stdout=shift;

    my $fp=STDERR;
    if ( $stdout ) {
	$fp=STDOUT;
    }

    print $fp "usage $0 [--help|--configure [configure-options] |[grab-options]]\n";
    print $fp "command line options are:\n";
    print $fp "   --help\n";
    print $fp "     print this help\n";
    print $fp "     use --configure --help for configure help or\n";
    print $fp "     use --grab --help for grab help\n";
    print $fp "\n";
    print $fp "   --configure\n";
    print $fp "     run configuration step, see --configure --help for more info\n";
    print $fp "\n";
    print $fp "grab-options are:\n";
    print $fp "   --debug\n";
    print $fp "     turn on debugging\n";
    print $fp "\n";
    print $fp "   --debuglistings\n";
    print $fp "     add debugging material in output xml as comments\n";
    print $fp "\n";
    print $fp "   --config-file <file>\n";
    print $fp "     specify file that contains config information, default in \$HOME/$ConfigFileName_g\n";
    print $fp "     (created by using --configure)\n";
    print $fp "\n";
    print $fp "   --listings <file>\n";
    print $fp "       specify listings.xml filename(s) for channel & program info\n";
    print $fp "       <file> may contain Date::Manip::Unix substitutions\n";
    print $fp "       for instance, use --listings \"listings-%d%m%Y.xml\" to separate output by day.\n";
    print $fp "       similarily, %postalcode, %zipcode, are also substituted from settings\n";
    print $fp "       current configuration.\n";
    print $fp "       The filename is only re-evaluated when a new days listings is started.\n";
    print $fp "       if no --listings is specified stdout is used\n";
    print $fp "\n";
    print $fp "   --output <file>\n";
    print $fp "       synonym for --listings\n";
    print $fp "\n";
    print $fp "   --days n\n";
    print $fp "       specify number of days to include in output (default 7)\n";
    print $fp "\n";
    print $fp "   --offset n\n";
    print $fp "       specify number of days (in the future) to offset the\n";
    print $fp "       start of the listings (default 0)\n";
    print $fp "\n";
    print $fp "   --retry-limit <count>\n";
    print $fp "       upon possible www site failure, retry <count> times before hard failure.\n";
    print $fp "       (default 2)\n";
    print $fp "\n";
    print $fp "   --retry-delay <seconds>\n";
    print $fp "       number of seconds to sleep between retries (default 30).\n";
    print $fp "\n";
}

# First lets check to see if someone asked for help.
# this is easier to do here than later.
my $configure=0;
if ( @ARGV ) {
    foreach my $arg (@ARGV) {
	$configure=1 if ( $arg=~m/^--configure/o );
        if ( $arg=~m/^--debug/o ) { $SIG{__WARN__} = sub { die $_[0] }; }
    }
}

# Accept older --config as synonym for --config-file.
foreach ( @ARGV ) {
    last if $_ eq '--';
    next if /^--config-/;
    s/^--config\b/--config-file/;
}

if ( $configure ) {
    use vars qw/$opt_configure $opt_help $opt_postalcode $opt_zipcode $opt_provider $opt_config_file $opt_debug $opt_auto_fail_on_provider_changes $opt_auto_new_channels $opt_auto_missing_channels $opt_retry_limit $opt_retry_delay/;

    $opt_debug=0;
    $opt_auto_fail_on_provider_changes="false";

    if ( ! GetOptions('configure', 'help', 'postalcode=s', 'zipcode=s', 'provider=s', 'config-file=s', 'debug', 'auto-fail-on-provider-changes=s', 'auto-new-channels=s', 'auto-missing-channels=s', 'retry=i', 'retry-delay=i') ) {
	ConfigureUsage(0);
	exit(1);
    }

    if ( defined($opt_help) ) {
	ConfigureUsage(1);
	exit(0);
    }

    $opt_auto_fail_on_provider_changes=($opt_auto_fail_on_provider_changes=~m;^t;i);

    if ( defined($opt_auto_new_channels) ) {
	if ( $opt_auto_new_channels=~m;^ignore;i ) {
	    $opt_auto_new_channels="ignore";
	}
	elsif ( $opt_auto_new_channels=~m;^add;i ) {
	    $opt_auto_new_channels="add";
	}
	else {
	    print STDERR "$0: invalid argument to --auto_new_channels, must be 'ignore' or 'add'\n";
	    ConfigureUsage(1);
	}
    }

    if ( defined($opt_auto_missing_channels) ) {
	if ( $opt_auto_missing_channels=~m;^ignore;i ) {
	    $opt_auto_missing_channels="ignore";
	}
	elsif ( $opt_auto_missing_channels=~m;^remove;i ) {
	    $opt_auto_missing_channels="remove";
	}
	else {
	    print STDERR "$0: invalid argument to --auto_missing_channels, must be 'ignore' or 'remove'\n";
	    ConfigureUsage(1);
	}
    }

    # versions starting with 0.5 have configuration information in $HOME/.xmltv by default.
    if ( defined($ENV{HOME}) && -f "$ENV{HOME}/.xmltv_na" ) {
	print STDERR "$0: updating configuration file location from\n";
	print STDERR "    $ENV{HOME}/.xmltv_na to \$HOME/.xmltv/tv_grab_na\n";
	mkdir("$ENV{HOME}/.xmltv", 0775) || die "mkdir $ENV{HOME}/.xmltv:$!";
	rename("$ENV{HOME}/.xmltv_na", $ConfigPathName_g) || 
	    die "mv $ENV{HOME}/.xmltv_na $ConfigPathName_g:$!";
    }

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config_file) ) {
	$configfile=$opt_config_file;
    }

    if ( -f $configfile && $config->load($configfile, $opt_debug) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	exit(1);
    }

    if ( defined($opt_postalcode) && defined($opt_zipcode) ) {
	print STDERR "$0: only one of --postalcode and --zipcode is allowed\n";
	exit(1);
    }

    # command line arguments
    if ( defined($opt_postalcode) ) {
	$config->setValue("option_postalcode", $opt_postalcode);
	$config->unsetValue("option_zipcode");
	$config->unsetValue("option_provider");
    }

    if ( defined($opt_zipcode) ) {
	$config->setValue("option_zipcode", $opt_zipcode);
	$config->unsetValue("option_postalcode");
	$config->unsetValue("option_provider");
    }
    
    if ( defined($opt_provider) ) {
	$config->setValue("option_provider", $opt_provider);
	$config->setValue("option_provider_desc", ""); # unknown so reset to ''
    }

    # sanity check
    if ( defined($config->{option_postalcode}) && defined($config->{option_zipcode})) {
	print STDERR "$0: only one of postal or zip code can be defined\n";
	exit(1);
    }

    if ( defined($opt_retry_limit) ) {
	$config->setValue("option_retry_limit", $opt_retry_limit);
    }

    if ( defined($opt_retry_delay) ) {
	$config->setValue("option_retry_delay", $opt_retry_delay);
    }

    #
    # Go interactive to collect what we don't have
    #

    my $msg="Welcome to XMLTV $VersionID for Canada and US tv listings";
    print "$msg\n";
    print "-" x length($msg);
    #for (my $i=0; $i<length($msg); $i++ ) {print "-";};
    print "\n";
    print "Please report any problems, bugs or suggestions to:\n";
    print "\txmltv-users\@lists.sourceforge.net\n";
    print "For more information consult http://xmltv.sourceforge.net\n\n";
    print "starting manual configuration process..\n";
    print "\n";
  
    while ( !defined($config->{option_retry_limit}) ) {
	my $res=ask('how many times do you want to retry on www site failers ? (default=2)');
	if ( !defined($res) || length($res) == 0 ) {
	    $res="2";
	}
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	    $res=int($res);
	    if ( $res >= 0 ) {
		$config->setValue("option_retry_limit", $res);
		last;
	    }
	}
	print STDERR "$0: please specify an integer retry count\n\n";
    }

    while ( !defined($config->{option_retry_delay}) ) {
	my $res=ask('how many seconds do you want to between retries ? (default=30)');
	if ( !defined($res) || length($res) == 0 ) {
	    $res="30";
	}
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	    $res=int($res);
	    if ( $res >= 0 ) {
		$config->setValue("option_retry_delay", $res);
		last;
	    }
	}
	print STDERR "$0: please specify an integer retry delay\n\n";
    }
    $opt_retry_limit=$config->{option_retry_limit};
    $opt_retry_delay=$config->{option_retry_delay};

    # if we have no postal code or zip code, the prompt for it
    if ( !defined($config->{option_postalcode}) && !defined($config->{option_zipcode})) {
	my $res=ask('what is your postal/zip code ?');
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	   # $res=~tr/[a-z]/[A-Z]/;
	    if ( $res=~m/^[a-zA-Z]/o ) {
		$config->setValue("option_postalcode", $res);
	    }
	    else {
		$config->setValue("option_zipcode", $res);
	    }
	}
	else {
	    print STDERR "$0: failed to get postal/zip code\n";
	    exit(1);
	}
    }
    
    # double check or get list of providers and give them the choice
    if ( 1 ) {

	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	print "\ngetting list of providers for postal/zip code $code, be patient..\n";

	my @providers;
	my $failed=0;
	for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	    if ( $retry != 0 ) {
		print STDERR "failed, will retry after \#$opt_retry_limit seconds..\n";
		sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	    }
	    @providers=XMLTV::ZapListings::getProviders($config->{option_postalcode},
						       $config->{option_zipcode},
						       $opt_debug);
	    if ( ! @providers || !defined($providers[0]) ) {
		$failed=1;
	    }
	    else {
		$failed=0;
		last;
	    }
	}
	if ( $failed ) {
	    #print STDERR "$0: failed to get list of providers for postal/zip code $code\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}

	my $defaultProviderId;

	if ( $config->{option_provider} ) {
	    my $still_valid=0;
	    for my $p (@providers) {
		if ( $p->{id} eq $config->{option_provider} ) {
		    if ( $config->{option_provider_desc} ne $p->{description} ) {
			if ( $opt_auto_fail_on_provider_changes ) {
			    print "provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
				"\nhas new description (".$p->{description}."), exiting\n";
			    exit(1);
			}
			print "updating provider description to: $p->{description}\n";
			$config->{option_provider_desc}=$p->{description};
		    }
		    $still_valid=1;
		}
		if ( $config->{option_provider_desc} eq $p->{description} ) {
		    $defaultProviderId=$p->{id};
		}
	    }
	    if ( $still_valid == 0 ) {
		if ( $opt_auto_fail_on_provider_changes ) {
		    print "provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
			"\nis no longer valid, exiting\n";
		    exit(1);
		}
		print "provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
		    "\nis no longer valid, choose a new one\n";
		delete($config->{option_provider});
		delete($config->{option_provider_desc});
	    }
	}

	while ( !$config->{option_provider} ) {
	    print "\n";
	    my (%descToId, %idToDesc);
	    die "no providers found" if not @providers;
	    foreach ( @providers ) {
		my ($id, $desc) = ($_->{id}, $_->{description});
		die if not defined $id;
		if ( not defined $desc ) {
		    warn "provider with id $id has no description\n";
		    next;
		}

		warn "two providers called $desc\n"
		  if exists $descToId{$desc};
		$descToId{$desc} = $id;
		die "two providers with id $id\n"
		  if exists $idToDesc{$id};
		$idToDesc{$id} = $desc;
	    }
	    if ( defined $defaultProviderId
		 and not exists $idToDesc{$defaultProviderId} ) {
		warn "cannot find default provider $defaultProviderId\n";
		undef $defaultProviderId;
	    }
	    if ( not defined $defaultProviderId ) {
		$defaultProviderId = $providers[0]->{id};
	    }

	    my $res = askQuestion("Choose a service provider: ",
				  $idToDesc{$defaultProviderId},
				  map { $_->{description} } @providers);
	    my $id = $descToId{$res}; die if not defined $id;
	    $config->{option_provider}=$id;
	    $config->{option_provider_desc}=$res;
	    print "\nyou choose $id \# $res\n";
	}
    }

    # if we're in the configure step, lets refresh the list of channels
    # being careful to warn about additions and deletions
    
    if ( $config->haveAnyChannels() ) {
	print "\nchecking for changes to channel list, be patient..\n";
    }
    else {
	print "\ngetting channel list, be patient..\n";
    }

    my @channels;
    my $failed=0;
    for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	if ( $retry != 0 ) {
	    print STDERR "failed, will retry after \#$opt_retry_limit seconds..\n";
	    sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	}
	@channels=XMLTV::ZapListings::getChannelList($config->{option_postalcode},
						     $config->{option_zipcode},
						     $config->{option_provider},
						     $opt_debug);
	if ( ! @channels || !defined($channels[0]) ) {
	    $failed=1;
	}
	else {
	    $failed=0;
	    last;
	}
    }

    if ( $failed ) {
	#print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
	#print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	exit(1);
    }

    my $channelsUpdated=0;
    my $easyAnswer;

    if ( defined($opt_auto_new_channels) ) {
	if ( $opt_auto_new_channels eq "ignore" ) {
	    $easyAnswer='no';
	}
	elsif ( $opt_auto_new_channels eq "add" ) {
	    $easyAnswer='yes';
	}
	else {
	    die "invalid auto_new_channels $opt_auto_new_channels\n";
	}
    }

    # notify user about update channel ids and new channels
    foreach my $channel (@channels) {
	my $station=$channel->{description};
	if ( $config->haveAnyChannels() ) {
	    if ( $config->stationExists($station) ) {
		$config->setStationTransientFlag($station, 'found', 1);
	    }
	    else {
		my $res;
		if ( $easyAnswer ) {
		    $res=$easyAnswer;
		    if ( $res eq 'yes' ) {
			print "adding channel $station..\n";
		    }
		    else {
			print "ignoring new channel $station..\n";
		    }
		}
		else {
		    $res=askQuestion("add channel $station ?", 'yes', ('yes', 'no', 'all'));
		    if ( $res eq 'all' ) {
			$easyAnswer='yes';
			$res=$easyAnswer;
		    }
		}
		$config->setStationIncluded($station, ($res eq 'yes'));
		$config->setStationTransientFlag($station, 'found', 1);
		#$config->setStationDescription($station, $channel->{description});
		$channelsUpdated++;
	    }
	}
	else {
	    my $res;
	    if ( $easyAnswer ) {
		$res=$easyAnswer;
		if ( $res eq 'yes' ) {
		    print "adding channel $station..\n";
		}
	    }
	    else {
		$res=askQuestion("add channel $station ?", 'yes', ('yes', 'no', 'all'));
		if ( $res eq 'all' ) {
		    $easyAnswer='yes';
		    $res=$easyAnswer;
		}
	    }
	    $config->setStationIncluded($station, ($res eq 'yes'));
	    $config->setStationTransientFlag($station, 'found', 1);
	    #$config->setStationDescription($station, $channel->{description});
	    $channelsUpdated++;
	}
    }

    undef($easyAnswer);

    if ( defined($opt_auto_missing_channels) ) {
	if ( $opt_auto_missing_channels eq "ignore" ) {
	    $easyAnswer='no';
	}
	elsif ( $opt_auto_missing_channels eq "remove" ) {
	    $easyAnswer='yes';
	}
	else {
	    die "invalid auto_missing_channels $opt_auto_missing_channels\n";
	}
    }

    # warn about channel declarations we didn't find
    foreach my $station ($config->stationsInDisplayOrder()) {
	if ( defined($config->getStationTransientFlag($station, 'found')) ) {
	    $config->removeStationTransientFlag($station, 'found');
	}
	else {
	    my $res;
	    if ( $easyAnswer ) {
		$res=$easyAnswer;
		if ( $res eq 'yes' ) {
		    print "removing channel $station..\n";
		}
		else {
		    print "ignoring missing channel $station..\n";
		}
	    }
	    else {
		$res=askQuestion("remove no-longer available channel $station ?", 'yes', ('yes', 'no', 'all'));
		if ( $res eq 'all' ) {
		    $easyAnswer='yes';
		    $res=$easyAnswer;
		}
	    }
	    if ( $res eq 'yes' ) {
		#print STDERR "warning: didn't find channel id: $station \#".
		#    $config->stationDescription($station)."\n";
		$config->stationRemove($station);
		$channelsUpdated++;
	    }
	}
    }

    if ( $channelsUpdated == 0 ) {
	if ( $config->haveAnyChannels() ) {
	    print "\nchannel line-up hasn't changed\n";
	}
	else {
	    print "\nno channels added\n";
	}
    } 

    # write out config file
    print "\nupdating $configfile..\n";
    if ( $config->save($configfile) != 0 ) {
	print "$0: $configfile save failed\n";
	exit(1);

    }

    print "\nconfiguration step complete, let the games begin !\n";
    exit(0);
}

# in grabber mode - yeah !

use vars qw/$opt_help $opt_config_file $opt_debug $opt_programs $opt_channels $opt_listings $opt_output $opt_days $opt_debuglistings $opt_offset $opt_retry_limit $opt_retry_delay/;

$opt_debug=0;
$opt_debuglistings=0;

if ( ! GetOptions('help', 'config-file=s', 'debug', 'programs=s', 'channels=s', 'listings=s', 'output=s', 'days=i', 'debuglistings', 'offset=i', 'retry=i', 'retry-delay=i') ) {
    Usage(0);
    exit(1);
}
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);

# throw error for invalid use of both --listings and --output
if ( defined($opt_output) && defined($opt_listings) ) {
    print STDERR "$0: only one of --listings or --output can be used at once\n";
    exit(1);
}

# implement --output as synonym for --listings
if ( defined($opt_output) ) {
    $opt_listings=$opt_output;
    undef($opt_output);
}

if ( defined($opt_help) ) {
    Usage(1);
    exit(0);
}

#
# detect old style usage
#
if ( defined($opt_programs) || defined($opt_channels) ) {
    print STDERR "$0: new xmltv.dtd format, use --listings instead of\n";
    print STDERR "                --programs and/or --channels\n";
    exit(1);
}

# set defaults if they didn't appear on command line
$opt_listings="" if ( !defined($opt_listings) );
$opt_days=7 if ( !defined($opt_days) );
$opt_offset=0 if ( !defined($opt_offset) );

if ( $opt_days < 0 || $opt_days > 14 ) {
    print STDERR "specified days must be between 1 and 14\n";
    Usage(0);
    exit(1);
}

STDOUT->autoflush(1);

my @FilesWeOpened_g;

my $failed=grab();

if ( $failed ) {
    if ( @FilesWeOpened_g ) {
	for my $file (@FilesWeOpened_g) {
	    if ( -f $file ) {
		#print STDERR "   removing $file\n";
		print STDERR "removing $file after failure..\n";
		unlink($file);
	    }
	}
    }
    exit(1);
}
exit(0);

sub writeListingsXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date                  =>Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      'source-info-url'     =>"http://www.zap2it.com",
		      'source-info-name'    =>"Zap2It",
		      'source-data-url'     =>"http://tvlistings2.zap2it.com/textall.asp",
		      'generator-info-name' =>"$VersionID",
		      'generator-info-url'  =>'http://www.sourceforge.net/projects/xmltv');
}

sub writeListingsXMLFooter($)
{
    my $writer=shift;
    $writer->endTag('tv');
}

sub grab
{
    # initalize global XML::Writer if we're writting listings to stdout
    # or if all listings are to being output'd to a single file.
    # The later allows us to use --listings tv.xml with more than one days listings.
    my $writer_g;

    # output_g is only used if we are writting all Listings to the same file.
    my $output_g;

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config_file) ) {
	if ( ! -f $opt_config_file ) {
	    print STDERR "$0: specified config file '$opt_config_file' does not exist, run --configure\n";
	    return(1);
	}
	$configfile=$opt_config_file;
    }
    else {
	# versions starting with 0.5 have configuration information in $HOME/.xmltv by default.
	if ( defined($ENV{HOME}) && -f "$ENV{HOME}/.xmltv_na" ) {
	    print STDERR "$0: location of config file (~/.xmltv_na) needs upgrade, run --configure\n";
	    $configfile="$ENV{HOME}/.xmltv_na";
	}
	if ( ! -f $configfile ) {
	    print STDERR "$0: config file '$configfile' does not exist, run --configure\n";
	    return(1);
	}
    }

    if ( $config->load($configfile, $opt_debug) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	return(1);
    }
    
    if ( !defined($opt_retry_limit) ) {
	if ( !defined($config->{option_retry_limit}) ) {
	    print STDERR "no retry limit set in configuration, re-run --configure\n";
	    $opt_retry_limit=2;
	}
	else {
	    $opt_retry_limit=$config->{option_retry_limit};
	}
    }

    if ( !defined($opt_retry_delay) ) {
	if ( !defined($config->{option_retry_delay}) ) {
	    print STDERR "no retry delay set in configuration, re-run --configure\n";
	    $opt_retry_delay=30;
	}
	else {
	    $opt_retry_delay=$config->{option_retry_delay};
	}
    }

    # check provider information, usually fast anyway.
    #
    if ( 1 ) {
	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	print STDERR "\nchecking provider information for postal/zip code $code, be patient..\n";

	my @providers;
	my $failed=0;
	for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	    if ( $retry != 0 ) {
		print STDERR "failed, will retry after \#$opt_retry_limit seconds..\n";
		sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	    }
	    @providers=XMLTV::ZapListings::getProviders($config->{option_postalcode},
							$config->{option_zipcode},
							$opt_debug);
	    if ( ! @providers || !defined($providers[0]) ) {
		$failed=1;
	    }
	    else {
		$failed=0;
		last;
	    }
	}
	if ( $failed ) {
	    #print STDERR "$0: failed to get list of providers for postal/zip code $code\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}

	my $still_valid=0;
	for my $p (@providers) {
	    if ( $p->{id} eq $config->{option_provider} ) {
		if ( $config->{option_provider_desc} ne $p->{description} ) {
		    print STDERR "provider description changed ($p->{description}), think about re-running --configure\n";
		}
		$still_valid=1;
	    }
	}
	if ( $still_valid == 0 ) {
	    print STDERR "noticed provider changed (for postal/zip code $code), re-run --configure\n";
	    # return failed
	    return(1);
	}
    }

    # collect information about channels.
    if ( 1 ) {
	print STDERR "double checking channel information, be patient..\n";

	my @channels;
	my $failed=0;
	for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
	    if ( $retry != 0 ) {
		print STDERR "failed, will retry after \#$opt_retry_limit seconds..\n";
		sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
	    }
	    @channels=XMLTV::ZapListings::getChannelList($config->{option_postalcode},
							 $config->{option_zipcode},
							 $config->{option_provider},
							 $opt_debug);
	    
	    if ( ! @channels || !defined($channels[0]) ) {
		$failed++;
		#print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
		#print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
		#exit(1);
	    }
	    else {
		$failed=0;
		last;
	    }
	}
	if ( $failed ) {
	    exit(1);
	}
	
	my $channelsUpdated=0;

	# notify user about update channel ids and new channels
	foreach my $channel (@channels) {
	    my $station=$channel->{description};
	    if ( $config->haveAnyChannels() ) {
		if ( $config->stationExists($station) ) {
		    $config->setStationTransientFlag($station, 'found', 1);

		    # save zap2it channel id for grabbing url usage
		    $config->setStationTransientFlag($station, 'zap2it-id', $channel->{stationid});
		    
		    if ( defined($channel->{icon}) ) {
			$config->setStationIcon($station, $channel->{icon});
		    }
		}
		else {
		    print STDERR "noticed new station available ($station), re-run --configure\n";
		}
	    }
	    else {
		print STDERR "noticed new station available ($station), re-run --configure\n";
	    }
	}

	# warn about channel declarations we didn't find
	foreach my $station ($config->stationsInDisplayOrder()) {
	    if ( defined($config->getStationTransientFlag($station, 'found')) ) {
		$config->removeStationTransientFlag($station, 'found');
	    }
	    else {
		print STDERR "noticed station unavailable ($station), re-run --configure\n";
		$config->setStationTransientFlag($station, 'notavailable', 1);
	    }
	}

	if ( $channelsUpdated++ ) {
	    print STDERR "some channel information is out of date, re-run --configure\n";
	}
    }

    my $stats;

    $stats->{num_channels}=0;
    $stats->{num_programs}=0;
    $stats->{num_days}=0;

    # start time only includes programming grabs, no channel detail grab
    my $startTime=time();

    # do %postalcode and %zipcode substitutions now since they can't change
    # if they don't appear, we remove them
    if ( defined($config->{option_postalcode}) ) {
	$opt_listings=~s/%(postal|zip)code/$config->{option_postalcode}/og;
    }
    elsif ( defined($config->{option_zipcode}) ) {
	$opt_listings=~s/%(postal|zip)code/$config->{option_zipcode}/og;
    }
    else {
	$opt_listings=~s/%(postal|zip)code//og;
    }

    if ( !length($opt_listings) ) {
	print STDERR "writing listings to stdout\n";
	$writer_g = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 2 );
    }
    elsif ( UnixDate("now","$opt_listings") eq $opt_listings ) {
	mkpathtofile($opt_listings, $opt_debug) || die "mkdir $opt_listings:$!";
	print STDERR "writing listings to $opt_listings\n";
	$output_g = new IO::File("> $opt_listings") || die "$opt_listings: $!";
	push(@FilesWeOpened_g, $opt_listings);
	$writer_g = new XML::Writer(OUTPUT=>$output_g,
				     DATA_MODE => 1, DATA_INDENT => 2 );
    }
    
    if ( defined($writer_g) ) {
	writeListingsXMLHeader($writer_g);
	$stats->{num_channels}=writeOutChannels($config, $writer_g);
    }

    my $failedCount=0;
    my ($y,$m,$d,$h,$mn,$s)=Date::Manip::Date_Split(ParseDateString("now"));
    my $startNDay=Date_DayOfYear($m,$d,$y);
    my $tz=Date_TimeZone();

    #
    # So that the output a day at a time, this allows for separate files per day
    #
    my $year=$y;
    my $runNDayOfYear=$startNDay + $opt_offset;
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	my $writer;
	my $output;

	# handle cross-year listings
	while ( $runNDayOfYear+$nday > Date_DaysInYear($year) ) {
	    $runNDayOfYear-=Date_DaysInYear($year);
	    $year++;
	}
	

	$stats->{num_days}++;;

	my $dateStr=createDateString(0, $runNDayOfYear+$nday, $year, 0, $tz);

	if ( defined($writer_g) ) {
	    $writer=$writer_g;
	}
	else {
	    my $filename=UnixDate($dateStr, "$opt_listings");
	    if ( $opt_listings eq $filename ) {
		die "This case should have been caught before here";
	    }
	    
	    mkpathtofile($filename, $opt_debug) || die "mkdir $opt_listings:$!";
	    print STDERR "writing listings to $filename\n";
	    $output = new IO::File("> $filename") || die "$filename: $!";
	    push(@FilesWeOpened_g, $filename);
	    $writer = new XML::Writer(OUTPUT=>$output,
					 DATA_MODE => 1, DATA_INDENT => 2 );
	    writeListingsXMLHeader($writer);
	    $stats->{num_channels}=writeOutChannels($config, $writer);
	}
	
	my $lg=new XMLTV::ZapListings::Scraper('PostalCode'=> $config->{option_postalcode},
					       'ZipCode'   =>$config->{option_zipcode},
					       'ProviderID'=>$config->{option_provider},
					       'Debug'     =>$opt_debug,
					       'DebugListings'     =>$opt_debuglistings);

	foreach my $station ($config->stationsInDisplayOrder()) {
	    
	    next if ( !$config->stationIncluded($station) );
	    
	    if ( defined($config->getStationTransientFlag($station, 'notavailable')) ) {
		print STDERR "skipping unavailable channel $station\n";
		next;
	    }

	    if ( !defined($config->getStationTransientFlag($station, 'zap2it-id')) ) {
		warn "ignoring channel without zap2it channel id $station\n";
		next;
	    }

	    my ($Year,$month,$day,$hr,$min,$sec)=Date::Manip::Date_NthDayOfYear($year, $runNDayOfYear+$nday);
	    
	    for (my $retry=0 ; $retry<=$opt_retry_limit; $retry++ ) {
		if ( $retry != 0 ) {
		    print STDERR "will retry schedule $Year-$month-$day for station $station after \#$opt_retry_limit seconds..\n";
		    sleep($opt_retry_delay) if ( $opt_retry_delay > 0 );
		}
		if ( $lg->readSchedule($config->getStationTransientFlag($station, 'zap2it-id'),
				       $station,
				       $day, $month, $Year) == -1 ) {
		    warn("readSchedule failed for $Year-$month-$day for station $station");
		    # fail hard on first failure
		    $failedCount++;
		}
		else {
		    last;
		}
	    }

	    if ( $failedCount ) {
		return($failedCount);
	    }

	    # set time zone for date conversions
	    #Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
	    #Date::Manip::Date_Init();
	    
	    $stats->{num_programs}+=writeOutPrograms($lg, $runNDayOfYear+$nday, $Year, $tz, $writer, $station);
	}
	
	if ( !defined($writer_g) || $writer != $writer_g ) {
	    writeListingsXMLFooter($writer);
	    $writer->end();
	    $output->close();
	}
    }

    if ( defined($writer_g) ) {
	writeListingsXMLFooter($writer_g);
	$writer_g->end();
	$output_g->close() if ( defined($output_g) );
    }

    my $endTime=time();
    printf(STDERR "Grabbed %d programs on %d channels over %d day(s) in %d seconds\n",
	   $stats->{num_programs},
	   $stats->{num_channels},
	   $stats->{num_days},
	   $endTime-$startTime);

    printf(STDERR "  not too bad, that's %.2f programs/sec and %.2f seconds/www page\n",
	   $stats->{num_programs}/($endTime-$startTime),
	   ($endTime-$startTime)/($stats->{num_days}*$stats->{num_channels}));
	    
    return($failedCount);
}

# create a conversion string
sub createDateString($$$$$)
{
    my ($minuteOfDay, $dayOfYear, $year, $additionalMin, $time_zone)=@_;
    
    if ( $additionalMin != 0 ) {
	$minuteOfDay+=$additionalMin;

	# deal with case where additional minutes pushes us over end of day
	if ( $minuteOfDay > 24*60 ) {
	    $minuteOfDay-=24*60;
	    $dayOfYear++;

	    # check and deal with case where this pushes us past end of year
	    my $isleap=Date_LeapYear($year);
	    if ($dayOfYear >= ($isleap ? 367 : 366)) {
		$year++;
		$dayOfYear-=($isleap ? 367 : 366);
	    }
	}
    }

    # account for end of year boundaries
    while ( $dayOfYear > Date_DaysInYear($year) ) {
	$dayOfYear-=Date_DaysInYear($year);
	$year++;
    }

    # calculate year,month and day from nth day of year info
    my ($pYEAR,$pMONTH,$pDAY,$pHR,$pMIN,$pSEC)=Date::Manip::Date_NthDayOfYear($year, $dayOfYear);

    # set HR and MIN to what they should really be
    $pHR=int($minuteOfDay/60);
    $pMIN=$minuteOfDay-($pHR*60);

    return(sprintf("%4d%02d%02d%02d%02d00 %s", $pYEAR, $pMONTH, $pDAY, $pHR, $pMIN, $time_zone));
}

sub writeOutPrograms($$$$$$)
{
    my ($lg, $dayOfYear, $year, $mytz, $writer, $channel)=@_;
    my $IncludePartialPrograms=0;

    my @programs=$lg->getPrograms();

    for my $prog (@programs) {

	$prog->{start}=createDateString(($prog->{start_hour}*60+$prog->{start_min}), $dayOfYear, $year, 0, $mytz);
	delete($prog->{start_hour});
	delete($prog->{start_min});
	if ( $prog->{end_hour} >= 24 ) {
	    $prog->{end}=createDateString((($prog->{end_hour}-24)*60+$prog->{end_min}), $dayOfYear+1, $year, 0, $mytz);
	}
	else {
	    $prog->{end}=createDateString(($prog->{end_hour}*60+$prog->{end_min}), $dayOfYear, $year, 0, $mytz);
	}
	delete($prog->{end_hour});
	delete($prog->{end_min});

	my $title=$prog->{title};
	    
	#print STDERR "storing $title..\n";

	if ( defined($prog->{contFromPreviousListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which starts previous to listing\n";
		next;
	    }
	    $title="(<-cont) $title";
	}
	if ( defined($prog->{contToNextListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which ends past listing boundaries\n";
		next;
	    }
	    $title="$title (cont->)";
	}
	
	$writer->startTag('programme', start=> $prog->{start}, 
			  stop => $prog->{end}, channel=> "$channel");
	if ( defined($prog->{precomment}) ) {
	    # -- in comments causes carp() calls in Writer.pm
	   $prog->{precomment}=~s/\-\-/\=\=/og;

	   # imbed in programme output a comment
	   # this is here for debugging listings and their results
	   $writer->comment("\n   ".$prog->{precomment});
	}
	$writer->dataElement('title', $title);
	$writer->dataElement('sub-title', $prog->{subtitle}) if ( defined($prog->{subtitle}) );
	$writer->dataElement('desc', $prog->{desc}) if ( defined($prog->{desc}) );
		
	if ( defined($prog->{director}) || defined($prog->{actors}) ) {
	    $writer->startTag('credits');
	    $writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
	    if ( defined($prog->{actors}) ) {
		foreach my $actor (@{$prog->{actors}}) {
		    $writer->dataElement('actor', $actor);
		}
	    }
	    $writer->endTag('credits');
	}
	$writer->dataElement('date', $prog->{year}) if ( defined($prog->{year}) );
	
	if ( defined($prog->{category}) ) {
	    foreach my $cat(@{$prog->{category}}) {
		$writer->dataElement('category', $cat);
	    }
	}
	# hunt for things in the "qualifiers bucket" where alot of things fall.
	if ( defined($prog->{qualifiers}) ) {
	    if ( defined($prog->{qualifiers}->{PaidProgram}) ) {
		# FIXME I don't that payment counts as a
		# 'category'.  Though there should probably be
		# some way to include it.  -- epa98@doc.ic.ac.uk
		# 
		$writer->dataElement('category', "advertisement");
	    }
	    if ( defined($prog->{qualifiers}->{Language}) ) {
		if ( defined($prog->{qualifiers}->{Dubbed}) ) {
		    $writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		    $writer->dataElement('language', $prog->{qualifiers}->{Dubbed});
		}
		else {
		    $writer->dataElement('language', $prog->{qualifiers}->{Language});
		}
	    }
	    
	    if ( defined($prog->{qualifiers}->{Taped}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{InProgress}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		# nowhere to put this
		# comes in the form of "Part 1 of 2"
		$writer->dataElement('episode-num', $prog->{qualifiers}->{PartInfo});
	    }
	    if ( defined($prog->{qualifiers}->{Live}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{CallIn}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{Animated}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{HDTV}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		$writer->startTag('video');
		$writer->dataElement('colour', 'no');
		$writer->endTag('video');
	    }
	    if ( defined($prog->{qualifiers}->{InStereo}) ) {
		$writer->startTag('audio');
		# The 'stereo' element requires some text inside it,
		# so you have to say <stereo>stereo</stereo>.  :-P.
		$writer->dataElement('stereo', 'stereo');
		$writer->endTag('audio');
	    }
	    if ( defined($prog->{qualifiers}->{PreviouslyShown}) ) {
		# Write as <previously-shown /> to indicate there is
		# no textual content, not even the empty string :-).
		$writer->emptyTag('previously-shown');
	    }
	    if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		$writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
	    }
	    if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		$writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
	    }

	    if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		$writer->startTag('subtitles', 'type' => 'onscreen');
		if ( defined($prog->{qualifiers}->{Subtitles}->{Language}) ) {
		    $writer->dataElement('language', $prog->{qualifiers}->{Subtitles}->{Language});
		}
		$writer->endTag('subtitles');
	    }
	    elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		# Write as <subtitles></subtitles> to show that there
		# _could_ be subelements, they're just not there.
		$writer->dataElement('subtitles', '', 'type' => "teletext");
	    }
	}
	if ( defined($prog->{ratings_VCHIP}) ) {
	    $writer->startTag('rating', system => 'VCHIP');
	    if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		$writer->dataElement('value', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}");
	    }
	    else {
		$writer->dataElement('value', $prog->{ratings_VCHIP});
	    }
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_MPAA}) ) {
	    $writer->startTag('rating', 'system' =>'MPAA');
	    $writer->dataElement('value', $prog->{ratings_MPAA});
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_ESRB}) ) {
	    $writer->startTag('rating', 'system' => 'ESRB');
	    $writer->dataElement('value', $prog->{ratings_ESRB});
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_Warnings}) ) {
	    my %hash;
	    foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		$hash{$k}=1;
	    }
	    foreach my $k ( keys %hash ) {
		$writer->startTag('rating', 'system' => 'General Warning');
		$writer->dataElement('value', $k);
		$writer->endTag('rating');
	    }
	}
	if ( defined($prog->{star_rating}) ) {
	    # comes in the form of a rating out fraction X/Y (X out of Y)
	    $writer->startTag('star-rating');
	    $writer->dataElement('value', $prog->{star_rating});
	    $writer->endTag('star-rating');
	}
	$writer->endTag('programme');
    }
    return(scalar(@programs));
}

# write the channels in xml format
sub writeOutChannels($$)
{
    my ($config, $writer)=@_;

    my $count=0;
    foreach my $station ($config->stationsInDisplayOrder()) {
	
	next if ( defined($config->getStationTransientFlag($station, 'notavailable')) );
	next if ( !$config->stationIncluded($station));

	$writer->startTag('channel', id=> $station);

	$writer->dataElement('display-name', "Channel $station");
	if ( defined($config->stationIcon($station)) ) {
	    # Write as empty tag because icon can never contain anything.
	    $writer->emptyTag('icon', 'src'=>$config->stationIcon($station));
	}

	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
	$count++;
    }

    return($count);
}

1;
