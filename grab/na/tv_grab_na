#!/usr/bin/perl -w
#
# This script scrapes www.zap2it.com tv listings, producing
# xmltv.dtd and channels.dtd compliant output. Zap2it supports
# both Canadian and US listings.
#
# Feel free to contact me with comments, contributions,
# and the like. jerry@matilda.com 
#
# Known Bugs
#  - no longer supports --startHour and --endHour parameters
#    defaults to scraping an entire day's schedules. 
#  - not all program qualifiers have been defined, so sometimes
#    program descriptions include qualifiers that are unidentified
#    These should be reported to the author
#
# $Id$
#

my $VersionMajor=2;
my $VersionMinor;

my $Date = q$Date$;
if ( !($Date=~m;^\s*Date: (\d{4})/(\d\d)/(\d\d) \d\d:\d\d:\d\d\s*$;)) {
    die "can't decipher date line ($Date)\n";
}
else {
    # Take the day as the minor version, eg 20020224.
    $VersionMinor="$1$2$3";
}

my $VersionID="tv_grab_na V$VersionMajor\.$VersionMinor";

#
# define name of tv_grab_na config file
#
my $ConfigFileName_g="tv_grab_na";
my $ConfigPathName_g;

# default location of config file is $HOME or ./ if HOME not set
if ( defined($ENV{HOME}) ) {
    $ConfigPathName_g="$ENV{HOME}/.xmltv/$ConfigFileName_g";
}
else {
    $ConfigPathName_g="./$ConfigFileName_g";
}

use strict;

package myConfig;

sub new
{
    my($type) = shift;
    my $self={ @_ };            # remaining args become attributes
    
    bless($self, $type);
    return($self);
}

sub setValue($$$)
{
    my ($self, $key, $value)=@_;
    $self->{$key}=$value;
    if ( $key ne "option_postalcode" &&
	 $key ne "option_zipcode" &&
	 $key ne "option_provider" &&
	 $key ne "option_provider_desc" ) {
	die "attempt to set invalid key $key to $value";
    }
}

sub unsetValue($$$)
{
    my ($self, $key, $value)=@_;
    delete($self->{$key}) if ( defined($self->{$key}));
}

#
# get list of stations in display-name order
#
# sad but true, I can't figure a better way of
# doing this, but then again I don't care - jv
#
sub stationsInDisplayOrder($)
{
    my $self=shift;

    # create reverse hash with key/values swapped
    my @nums;
    foreach my $station (keys (%{$self->{channels}})) {
	my $key=0;
	if ( $station=~m/^\s*(\d+)/o ) {
	    $key=$1;
	}
	# seems very odd, but occasionally, you get two channels with the
	# same channel # on the dial
	if ( defined($nums[$key]) ) {
	    $nums[$key]="$nums[$key],$station";
	}
	else {
	    $nums[$key]="$station";
	}
    }
    
    my @ret;
    for (my $n=0; $n<scalar(@nums) ; $n++ ) {
	if ( defined($nums[$n]) ) {
	    push(@ret, sort (split(',', $nums[$n])))
	}
    }
    return(@ret);
}

sub haveAnyChannels($)
{
    my $self=shift;
    return(defined($self->{channels}));
}

sub stationRemove($$)
{
    my ($self, $station)=@_;
    delete($self->{channels}->{$station});
}

sub stationExists($$)
{
    my ($self, $station)=@_;
    return(defined($self->{channels}->{$station}));
}

sub setStationIncluded($$$)
{
    my ($self, $station, $in)=@_;
    $self->{channels}->{$station}->{in}=$in;
}

sub stationIncluded($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{in});
}

sub stationIcon($$)
{
    my ($self, $station)=@_;
    return($self->{channels}->{$station}->{icon});
}

sub setStationIcon($$$)
{
    my ($self, $station, $icon)=@_;
    $self->{channels}->{$station}->{icon}=$icon;
}

sub setStationTransientFlag($$$$)
{
    my ($self, $station, $flag, $value)=@_;
    $self->{channels}->{$station}->{transient}->{$flag}=$value;
}

sub getStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    return($self->{channels}->{$station}->{transient}->{$flag});
}

sub removeStationTransientFlag($$$)
{
    my ($self, $station, $flag)=@_;
    delete($self->{channels}->{$station}->{transient}->{$flag});
}

sub save($$)
{
    my ($self, $file)=@_;

    if ( main::mkpathtofile($file, 0) != 1 ) {
	print STDERR "mkdir failed on directory for $file:$!\n";
	return(-1);
    }

    open(FD, "> $file") || return(-1);
    print FD "# config file: tv_grab_na $VersionMajor.$VersionMinor\n";
    print FD "#\n";
    print FD "# this file is generated by running tv_grab_na --configure\n";
    print FD "# the only change you should make is prefixing 'channel:' lines\n";
    print FD "# with a '#' to signal that they should be ignored during the\n";
    print FD "# grab step\n";
    print FD "#\n";
    if ( defined($self->{option_postalcode})) {
	print FD "postal code: $self->{option_postalcode}\n";
    }
    if ( defined($self->{option_zipcode}) ) {
	print FD "zip code: $self->{option_zipcode}\n";
    }
    print FD "provider: $self->{option_provider} \# ".
	$self->{option_provider_desc}."\n";
    
    foreach my $station ($self->stationsInDisplayOrder()) {
	if ( $self->stationIncluded($station) ) {
	    print FD "channel: $station\n"
	}
	else {
	    print FD "#channel: $station\n";
	}
    }
    close(FD);
    return(0);
}

sub load($$$)
{
    my ($self, $file, $debug)=@_;

    my $majorVersion;
    open(FD, "< $file") || return(-1);
    while (<FD>) {
	s/\n$//o;

	# auto-upgrading from version 1 to 2
	if ( defined($majorVersion) && $majorVersion == 1 ) {
	    if ( m/^\#+channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="#channel: $2";
	    }
	    elsif ( m/^channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
		$_="channel: $2";
	    }
	}

	if ( $. == 1 ) {
	    if ( m/^\#\s+config\s+file:\s*(?:g.tlistings|tv_grab)_na (\d+)\.(\d+)/o ) {
		$majorVersion=$1;
		if ( $1 == 1 ) {
		    print STDERR "$file: older format identified, coping, re-run --configure to upgrade\n";
		}
		elsif ( $1 != $VersionMajor || $2 > $VersionMinor ) {
		    print STDERR "$0: $file:$.: $1\.$2 is an unsupported version number\n";
		    close(FD);
		    return(-1);
		}
	    }
	    else {
		print STDERR "$0: $file:$.: unsupported version header\n";
		close(FD);
		return(-1);
	    }
	}
	elsif ( m/^postal code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_postalcode", $1);
	}
	elsif ( m/^zip code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_zipcode", $1);
	}
	elsif ( m/^provider:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->setValue("option_provider", $1);
	    $self->setValue("option_provider_desc", $2);
	}
	elsif ( m/^\#+channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 0);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^channel:\s*(.+)$/o ) {
	    $self->setStationIncluded($1, 1);
	    #$self->setStationDescription($1, $1);
	}
	elsif ( m/^#/o ) {
	    next;
	}
	elsif ( m/^\s*$/o ) {
	    # ignore empty lines
	}
	else {
	    print STDERR "$0: $file:$.: invalid\n";
	    close(FD);
	    return(-1);
	}
	   
    }
    close(FD);
    if ( defined($self->{option_postalcode}) && defined($self->{option_zipcode})) {
	print STDERR "$0: $file: corrupt, only one of postal or zip can be defined\n";
	return(-1);
    }
    return(0);
}

1;

package main;

use strict;
#use diagnostics;
use Fcntl qw(:DEFAULT);
use XML::Writer;
use IO;
use Getopt::Long;
use Date::Manip;
use File::Basename;

use XMLTV::ZapListings;
use XMLTV::Ask;

sub mkpathtofile($$)
{
    my ($file, $debug)=@_;
    my @paths;

    my $path=dirname($file);
    if ( -d $path ) {
	return(1);
    }
    print STDERR "making path: $path..\n" if ( $debug );
    while (length($path)!=0 && $path ne "." && $path ne "/" ) {
	push(@paths, $path);
	$path=dirname($path);
    }

    foreach my $dir (@paths) {
	if ( ! -d $dir ) {
	    print STDERR "mkdir($dir, 0775)\n" if ( $debug > 1 );
	    mkdir($dir, 0775) || return(-1);
	}
	else {
	    print STDERR "$dir exists, not making\n" if ( $debug > 1);
	}
    }
    return(1);
}

#
# How this grabber works:

# Step 1 - Configure
#  
#   The configure step is meant to be run interactively.
#   You can use 'tv_grab_na --configure --help' to see
#   how to run non-interactively, providing information on
#   the command line.

#   run 'tv_grab_na --configure'
#
#   Follow the prompts to provide the necessary information.
#
#   When finished, configure will create a file $HOME/$ConfigFileName_g
#   which contains the postal/zip code, the provider id
#   and a line for each channel that provider supplies.
#   This file is what you specify with the --config command
#   line option to "Step 2 Grabbing Data". See Step 2 for details
#   of how this file is interpreted.
#

sub ConfigureUsage($)
{
    no strict 'subs';
    no strict 'refs';
    my $stdout=shift;

    my $fp=STDERR;
    if ( $stdout ) {
	$fp=STDOUT;
    }
    print $fp "usage $0 --configure [options]\n";
    print $fp "where options are:\n";
    print $fp "   --help\n";
    print $fp "     print $fp configure help\n";
    print $fp "\n";
    print $fp "   --debug\n";
    print $fp "     turn on debugging\n";
    print $fp "\n";
    print $fp "   --postalcode XXXXXX\n";
    print $fp "     specify postal code, don't use with --zipcode\n";
    print $fp "\n";
    print $fp "   --zipcode YYYYYY\n";
    print $fp "     specify zip code, don't use with --postalcode\n";
    print $fp "\n";
    print $fp "   --provider ZZZZZZZ\n";
    print $fp "     specify provider id\n";
    print $fp "\n";
    print $fp "   --config <file>\n";
    print $fp "     write results of configure to <file> instead of \$HOME/$ConfigFileName_g\n";
    print $fp "\n";
    print $fp "  The following options are used to invoke --configure in a non-interactive mode\n";
    print $fp "   --auto-fail-on-provider-changes <boolean>\n";
    print $fp "     true/false - exit 1 if provider has changed\n";
    print $fp "\n";
    print $fp "   --auto-new-channels [ignore|add]\n";
    print $fp "     ignore/add - ignore or automatically add new channels in schedule listing\n";
    print $fp "\n";
    print $fp "   --auto-missing-channels [ignore|remove]\n";
    print $fp "     ignore/remove - ignore or remove channels no longer in schedule listing\n";
    print $fp "\n";
    print $fp "If any neccessary options are given, interactive mode is enabled\n";
    print $fp "(ie no postal/zip code in config file and not on command line)\n";
    print $fp "Result of running configure is a configuration file\n";
    print $fp "\$HOME/$ConfigFileName_g (use --config to override location).\n";
}

# Step 2 - Grab
#   
#   The grab step uses the information collected during
#   configuration to get tv listings.
#  
#
#

sub Usage($)
{
    no strict 'subs';
    no strict 'refs';
    my $stdout=shift;

    my $fp=STDERR;
    if ( $stdout ) {
	$fp=STDOUT;
    }

    print $fp "usage $0 [--help|--configure [configure-options] |[grab-options]]\n";
    print $fp "command line options are:\n";
    print $fp "   --help\n";
    print $fp "     print this help\n";
    print $fp "     use --configure --help for configure help or\n";
    print $fp "     use --grab --help for grab help\n";
    print $fp "\n";
    print $fp "   --configure\n";
    print $fp "     run configuration step, see --configure --help for more info\n";
    print $fp "\n";
    print $fp "grab-options are:\n";
    print $fp "   --debug\n";
    print $fp "     turn on debugging\n";
    print $fp "\n";
    print $fp "   --debuglistings\n";
    print $fp "     add debugging material in output xml as comments\n";
    print $fp "\n";
    print $fp "   --config <file>\n";
    print $fp "     specify file that contains config information, default in \$HOME/$ConfigFileName_g\n";
    print $fp "     (created by using --configure)\n";
    print $fp "\n";
    print $fp "   --listings <file>\n";
    print $fp "       specify listings.xml filename(s) for channel & program info\n";
    print $fp "       <file> may contain Date::Manip::Unix substitutions\n";
    print $fp "       for instance, use --listings \"listings-%d%m%Y.xml\" to separate output by day.\n";
    print $fp "       similarily, %postalcode, %zipcode, are also substituted from settings\n";
    print $fp "       current configuration.\n";
    print $fp "       The filename is only re-evaluated when a new days listings is started.\n";
    print $fp "       if no --listings is specified stdout is used\n";
    print $fp "\n";
    print $fp "   --output <file>\n";
    print $fp "       synonym for --listings\n";
    print $fp "\n";
    print $fp "   --days n\n";
    print $fp "       specify number of days to include in output (default 7)\n";
    print $fp "\n";
    print $fp "   --offset n\n";
    print $fp "       specify number of days (in the future) to offset the\n";
    print $fp "       start of the listings (default 0)\n";
}

# First lets check to see if someone asked for help.
# this is easier to do here than later.
my $configure=0;
if ( @ARGV ) {
    foreach my $arg (@ARGV) {
	$configure=1 if ( $arg=~m/^--configure/o );
        if ( $arg=~m/^--debug/o ) { $SIG{__WARN__} = sub { die $_[0] }; }
    }
}

if ( $configure ) {
    use vars qw/$opt_configure $opt_help $opt_postalcode $opt_zipcode $opt_provider $opt_config $opt_debug $opt_auto_fail_on_provider_changes $opt_auto_new_channels $opt_auto_missing_channels/;

    $opt_debug=0;
    $opt_auto_fail_on_provider_changes="false";

    # For backwards compatibility, accept underscores in long
    # arguments as well as hyphens.
    #
    foreach (@ARGV) {
	last if $_ eq '--';
	if (s/^--//) {
	    tr/_/-/;
	    $_ = "--$_";
	}
    }
    if ( ! GetOptions('configure', 'help', 'postalcode=s', 'zipcode=s', 'provider=s', 'config=s', 'debug', 'auto-fail-on-provider-changes=s', 'auto-new-channels=s', 'auto-missing-channels=s') ) {
	ConfigureUsage(0);
	exit(1);
    }

    if ( defined($opt_help) ) {
	ConfigureUsage(1);
	exit(0);
    }

    $opt_auto_fail_on_provider_changes=($opt_auto_fail_on_provider_changes=~m;^t;i);

    if ( defined($opt_auto_new_channels) ) {
	if ( $opt_auto_new_channels=~m;^ignore;i ) {
	    $opt_auto_new_channels="ignore";
	}
	elsif ( $opt_auto_new_channels=~m;^add;i ) {
	    $opt_auto_new_channels="add";
	}
	else {
	    print STDERR "$0: invalid argument to --auto_new_channels, must be 'ignore' or 'add'\n";
	    ConfigureUsage(1);
	}
    }

    if ( defined($opt_auto_missing_channels) ) {
	if ( $opt_auto_missing_channels=~m;^ignore;i ) {
	    $opt_auto_missing_channels="ignore";
	}
	elsif ( $opt_auto_missing_channels=~m;^remove;i ) {
	    $opt_auto_missing_channels="remove";
	}
	else {
	    print STDERR "$0: invalid argument to --auto_missing_channels, must be 'ignore' or 'remove'\n";
	    ConfigureUsage(1);
	}
    }

    # versions starting with 0.5 have configuration information in $HOME/.xmltv by default.
    if ( defined($ENV{HOME}) && -f "$ENV{HOME}/.xmltv_na" ) {
	print STDERR "$0: updating configuration file location from\n";
	print STDERR "    $ENV{HOME}/.xmltv_na to \$HOME/.xmltv/tv_grab_na\n";
	mkdir("$ENV{HOME}/.xmltv", 0775) || die "mkdir $ENV{HOME}/.xmltv:$!";
	rename("$ENV{HOME}/.xmltv_na", $ConfigPathName_g) || 
	    die "mv $ENV{HOME}/.xmltv_na $ConfigPathName_g:$!";
    }

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config) ) {
	$configfile=$opt_config;
    }

    if ( -f $configfile && $config->load($configfile, $opt_debug) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	exit(1);
    }

    if ( defined($opt_postalcode) && defined($opt_zipcode) ) {
	print STDERR "$0: only one of --postalcode and --zipcode is allowed\n";
	exit(1);
    }

    # command line arguments
    if ( defined($opt_postalcode) ) {
	$config->setValue("option_postalcode", $opt_postalcode);
	$config->unsetValue("option_zipcode");
	$config->unsetValue("option_provider");
    }

    if ( defined($opt_zipcode) ) {
	$config->setValue("option_zipcode", $opt_zipcode);
	$config->unsetValue("option_postalcode");
	$config->unsetValue("option_provider");
    }
    
    if ( defined($opt_provider) ) {
	$config->setValue("option_provider", $opt_provider);
	$config->setValue("option_provider_desc", ""); # unknown so reset to ''
    }

    # sanity check
    if ( defined($config->{option_postalcode}) && defined($config->{option_zipcode})) {
	print STDERR "$0: only one of postal or zip code can be defined\n";
	exit(1);
    }

    #
    # Go interactive to collect what we don't have
    #

    my $msg="Welcome to XMLTV $VersionID for Canada and US tv listings";
    print "$msg\n";
    print "-" x length($msg);
    #for (my $i=0; $i<length($msg); $i++ ) {print "-";};
    print "\n";
    print "Please report any problems, bugs or suggestions to:\n";
    print "\txmltv-users\@lists.sourceforge.net\n";
    print "For more information consult http://xmltv.sourceforge.net\n\n";
    print "starting manual configuration process..\n";
    print "\n";
  
    # if we have no postal code or zip code, the prompt for it
    if ( !defined($config->{option_postalcode}) && !defined($config->{option_zipcode})) {
	my $res=ask('what is your postal/zip code ?');
	$res=~s/\s+//og if ( defined($res) );
	if ( defined($res) && length($res) ) {
	   # $res=~tr/[a-z]/[A-Z]/;
	    if ( $res=~m/^[a-zA-Z]/o ) {
		$config->setValue("option_postalcode", $res);
	    }
	    else {
		$config->setValue("option_zipcode", $res);
	    }
	}
	else {
	    print STDERR "$0: failed to get postal/zip code\n";
	    exit(1);
	}
    }
    
    # double check or get list of providers and give them the choice
    if ( 1 ) {

	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	print "\ngetting list of providers for postal/zip code $code, be patient..\n";
	my @providers=XMLTV::ZapListings::getProviders($config->{option_postalcode},
						       $config->{option_zipcode},
						       $opt_debug);
	if ( ! @providers || !defined($providers[0]) ) {
	    #print STDERR "$0: failed to get list of providers for postal/zip code $code\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}

	my $defaultChoice=0;

	if ( $config->{option_provider} ) {
	    my $still_valid=0;
	    for my $p (@providers) {
		if ( $p->{id} eq $config->{option_provider} ) {
		    if ( $config->{option_provider_desc} ne $p->{description} ) {
			if ( $opt_auto_fail_on_provider_changes ) {
			    print "provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
				"\nhas new description (".$p->{description}."), exiting\n";
			    exit(1);
			}
			print "updating provider description to: $p->{description}\n";
			$config->{option_provider_desc}=$p->{description};
		    }
		    $still_valid=1;
		}
		if ( $config->{option_provider_desc} eq $p->{description} ) {
		    $defaultChoice=$p->{id};
		}
	    }
	    if ( $still_valid == 0 ) {
		if ( $opt_auto_fail_on_provider_changes ) {
		    print "provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
			"\nis no longer valid, exiting\n";
		    exit(1);
		}
		print "provider:\n\t".$config->{option_provider}." \# ".$config->{option_provider_desc}.
		    "\nis no longer valid, choose a new one\n";
		delete($config->{option_provider});
		delete($config->{option_provider_desc});
	    }
	}

	while ( !$config->{option_provider} ) {
	    print "\n";
	    print "Id   \tService Provider\n";
	    print "-----\t---------------------------\n";
	    for my $p (@providers) {
		print "$p->{id}\t$p->{description}\n";
	    }
	    print "\n";
	    my $res=askQuestionWithoutValidation("Choose a service provider by id ?", "$defaultChoice", ('id','use 0 to cancel'));

	    if ( !defined($res) || $res eq "0" || $res eq "use 0 to cancel"  ) {
		print "operation cancelled by user\n";
		exit(0);
	    }
	    for my $p (@providers) {
		if ( $res eq $p->{id} ) {
		    $config->{option_provider}=$p->{id};
		    $config->{option_provider_desc}=$p->{description};
		    print "\nyou choose $p->{id} \# $p->{description}\n";
		}
	    }
	}
    }

    # if we're in the configure step, lets refresh the list of channels
    # being careful to warn about additions and deletions
    
    if ( $config->haveAnyChannels() ) {
	print "\nchecking for changes to channel list, be patient..\n";
    }
    else {
	print "\ngetting channel list, be patient..\n";
    }

    my @channels=XMLTV::ZapListings::getChannelList($config->{option_postalcode},
						    $config->{option_zipcode},
						    $config->{option_provider},
						    $opt_debug);
    
    if ( ! @channels || !defined($channels[0]) ) {
	#print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
	#print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	exit(1);
    }

    my $channelsUpdated=0;
    my $easyAnswer;

    if ( defined($opt_auto_new_channels) ) {
	if ( $opt_auto_new_channels eq "ignore" ) {
	    $easyAnswer='no';
	}
	elsif ( $opt_auto_new_channels eq "add" ) {
	    $easyAnswer='yes';
	}
	else {
	    die "invalid auto_new_channels $opt_auto_new_channels\n";
	}
    }

    # notify user about update channel ids and new channels
    foreach my $channel (@channels) {
	my $station=$channel->{description};
	if ( $config->haveAnyChannels() ) {
	    if ( $config->stationExists($station) ) {
		$config->setStationTransientFlag($station, 'found', 1);
	    }
	    else {
		my $res;
		if ( $easyAnswer ) {
		    $res=$easyAnswer;
		    if ( $res eq 'yes' ) {
			print "adding channel $station..\n";
		    }
		    else {
			print "ignoring new channel $station..\n";
		    }
		}
		else {
		    $res=askQuestion("add channel $station ?", 'yes', ('yes', 'no', 'all'));
		    if ( $res eq 'all' ) {
			$easyAnswer='yes';
			$res=$easyAnswer;
		    }
		}
		$config->setStationIncluded($station, ($res eq 'yes'));
		$config->setStationTransientFlag($station, 'found', 1);
		#$config->setStationDescription($station, $channel->{description});
		$channelsUpdated++;
	    }
	}
	else {
	    my $res;
	    if ( $easyAnswer ) {
		$res=$easyAnswer;
		if ( $res eq 'yes' ) {
		    print "adding channel $station..\n";
		}
	    }
	    else {
		$res=askQuestion("add channel $station ?", 'yes', ('yes', 'no', 'all'));
		if ( $res eq 'all' ) {
		    $easyAnswer='yes';
		    $res=$easyAnswer;
		}
	    }
	    $config->setStationIncluded($station, ($res eq 'yes'));
	    $config->setStationTransientFlag($station, 'found', 1);
	    #$config->setStationDescription($station, $channel->{description});
	    $channelsUpdated++;
	}
    }

    undef($easyAnswer);

    if ( defined($opt_auto_missing_channels) ) {
	if ( $opt_auto_missing_channels eq "ignore" ) {
	    $easyAnswer='no';
	}
	elsif ( $opt_auto_missing_channels eq "remove" ) {
	    $easyAnswer='yes';
	}
	else {
	    die "invalid auto_missing_channels $opt_auto_missing_channels\n";
	}
    }

    # warn about channel declarations we didn't find
    foreach my $station ($config->stationsInDisplayOrder()) {
	if ( defined($config->getStationTransientFlag($station, 'found')) ) {
	    $config->removeStationTransientFlag($station, 'found');
	}
	else {
	    my $res;
	    if ( $easyAnswer ) {
		$res=$easyAnswer;
		if ( $res eq 'yes' ) {
		    print "removing channel $station..\n";
		}
		else {
		    print "ignoring missing channel $station..\n";
		}
	    }
	    else {
		$res=askQuestion("remove no-longer available channel $station ?", 'yes', ('yes', 'no', 'all'));
		if ( $res eq 'all' ) {
		    $easyAnswer='yes';
		    $res=$easyAnswer;
		}
	    }
	    if ( $res eq 'yes' ) {
		#print STDERR "warning: didn't find channel id: $station \#".
		#    $config->stationDescription($station)."\n";
		$config->stationRemove($station);
		$channelsUpdated++;
	    }
	}
    }

    if ( $channelsUpdated == 0 ) {
	if ( $config->haveAnyChannels() ) {
	    print "\nchannel line-up hasn't changed\n";
	}
	else {
	    print "\nno channels added\n";
	}
    } 

    # write out config file
    print "\nupdating $configfile..\n";
    if ( $config->save($configfile) != 0 ) {
	print "$0: $configfile save failed\n";
	exit(1);

    }

    print "\nconfiguration step complete, let the games begin !\n";
    exit(0);
}

# in grabber mode - yeah !

use vars qw/$opt_help $opt_config $opt_debug $opt_programs $opt_channels $opt_listings $opt_output $opt_days $opt_debuglistings $opt_offset/;

$opt_debug=0;
$opt_debuglistings=0;

if ( ! GetOptions('help', 'config=s', 'debug', 'programs=s', 'channels=s', 'listings=s', 'output=s', 'days=i', 'debuglistings', 'offset=i') ) {
    Usage(0);
    exit(1);
}
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);

# throw error for invalid use of both --listings and --output
if ( defined($opt_output) && defined($opt_listings) ) {
    print STDERR "$0: only one of --listings or --output can be used at once\n";
    exit(1);
}

# implement --output as synonym for --listings
if ( defined($opt_output) ) {
    $opt_listings=$opt_output;
    undef($opt_output);
}

if ( defined($opt_help) ) {
    Usage(1);
    exit(0);
}

#
# detect old style usage
#
if ( defined($opt_programs) || defined($opt_channels) ) {
    print STDERR "$0: new xmltv.dtd format, use --listings instead of\n";
    print STDERR "                --programs and/or --channels\n";
    exit(1);
}

# set defaults if they didn't appear on command line
$opt_listings="" if ( !defined($opt_listings) );
$opt_days=7 if ( !defined($opt_days) );
$opt_offset=0 if ( !defined($opt_offset) );

if ( $opt_days < 0 || $opt_days > 14 ) {
    print STDERR "specified days must be between 1 and 14\n";
    Usage(0);
    exit(1);
}

STDOUT->autoflush(1);

my @FilesWeOpened_g;

my $failed=grab();

if ( $failed ) {
    if ( @FilesWeOpened_g ) {
	for my $file (@FilesWeOpened_g) {
	    if ( -f $file ) {
		#print STDERR "   removing $file\n";
		print STDERR "removing $file after failure..\n";
		unlink($file);
	    }
	}
    }
    exit(1);
}
exit(0);

sub writeListingsXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date                  =>Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      'source-info-url'     =>"http://www.zap2it.com",
		      'source-info-name'    =>"Zap2It",
		      'source-data-url'     =>"http://tvlistings2.zap2it.com/textall.asp",
		      'generator-info-name' =>"$VersionID",
		      'generator-info-url'  =>'http://www.sourceforge.net/projects/xmltv');
}

sub writeListingsXMLFooter($)
{
    my $writer=shift;
    $writer->endTag('tv');
}

sub grab
{
    # initalize global XML::Writer if we're writting listings to stdout
    # or if all listings are to being output'd to a single file.
    # The later allows us to use --listings tv.xml with more than one days listings.
    my $writer_g;

    # output_g is only used if we are writting all Listings to the same file.
    my $output_g;

    my $config=new myConfig();
    
    my $configfile=$ConfigPathName_g;
    if ( defined($opt_config) ) {
	if ( ! -f $opt_config ) {
	    print STDERR "$0: specified config file '$opt_config' does not exist, run --configure\n";
	    return(1);
	}
	$configfile=$opt_config;
    }
    else {
	# versions starting with 0.5 have configuration information in $HOME/.xmltv by default.
	if ( defined($ENV{HOME}) && -f "$ENV{HOME}/.xmltv_na" ) {
	    print STDERR "$0: location of config file (~/.xmltv_na) needs upgrade, run --configure\n";
	    $configfile="$ENV{HOME}/.xmltv_na";
	}
	if ( ! -f $configfile ) {
	    print STDERR "$0: config file '$configfile' does not exist, run --configure\n";
	    return(1);
	}
    }

    if ( $config->load($configfile, $opt_debug) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	return(1);
    }
    
    # check provider information, usually fast anyway.
    #
    if ( 1 ) {
	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	print STDERR "\nchecking provider information for postal/zip code $code, be patient..\n";
	my @providers=XMLTV::ZapListings::getProviders($config->{option_postalcode},
						       $config->{option_zipcode},
						       $opt_debug);
	if ( ! @providers || !defined($providers[0]) ) {
	    #print STDERR "$0: failed to get list of providers for postal/zip code $code\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}

	my $still_valid=0;
	for my $p (@providers) {
	    if ( $p->{id} eq $config->{option_provider} ) {
		if ( $config->{option_provider_desc} ne $p->{description} ) {
		    print STDERR "provider description changed ($p->{description}), think about re-running --configure\n";
		}
		$still_valid=1;
	    }
	}
	if ( $still_valid == 0 ) {
	    print STDERR "noticed provider changed (for postal/zip code $code), re-run --configure\n";
	    # return failed
	    return(1);
	}
    }

    # collect information about channels.
    if ( 1 ) {
	print STDERR "double checking channel information, be patient..\n";

	my @channels=XMLTV::ZapListings::getChannelList($config->{option_postalcode},
							$config->{option_zipcode},
							$config->{option_provider},
							$opt_debug);
    
	if ( ! @channels || !defined($channels[0]) ) {
	    #print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}
	
	my $channelsUpdated=0;

	# notify user about update channel ids and new channels
	foreach my $channel (@channels) {
	    my $station=$channel->{description};
	    if ( $config->haveAnyChannels() ) {
		if ( $config->stationExists($station) ) {
		    $config->setStationTransientFlag($station, 'found', 1);

		    # save zap2it channel id for grabbing url usage
		    $config->setStationTransientFlag($station, 'zap2it-id', $channel->{stationid});
		    
		    if ( defined($channel->{icon}) ) {
			$config->setStationIcon($station, $channel->{icon});
		    }
		}
		else {
		    print STDERR "noticed new station available ($station), re-run --configure\n";
		}
	    }
	    else {
		print STDERR "noticed new station available ($station), re-run --configure\n";
	    }
	}

	# warn about channel declarations we didn't find
	foreach my $station ($config->stationsInDisplayOrder()) {
	    if ( defined($config->getStationTransientFlag($station, 'found')) ) {
		$config->removeStationTransientFlag($station, 'found');
	    }
	    else {
		print STDERR "noticed station unavailable ($station), re-run --configure\n";
		$config->setStationTransientFlag($station, 'notavailable', 1);
	    }
	}

	if ( $channelsUpdated++ ) {
	    print STDERR "some channel information is out of date, re-run --configure\n";
	}
    }

    my $stats;

    $stats->{num_channels}=0;
    $stats->{num_programs}=0;
    $stats->{num_days}=0;

    # start time only includes programming grabs, no channel detail grab
    my $startTime=time();

    # do %postalcode and %zipcode substitutions now since they can't change
    # if they don't appear, we remove them
    if ( defined($config->{option_postalcode}) ) {
	$opt_listings=~s/%(postal|zip)code/$config->{option_postalcode}/og;
    }
    elsif ( defined($config->{option_zipcode}) ) {
	$opt_listings=~s/%(postal|zip)code/$config->{option_zipcode}/og;
    }
    else {
	$opt_listings=~s/%(postal|zip)code//og;
    }

    if ( !length($opt_listings) ) {
	print STDERR "writing listings to stdout\n";
	$writer_g = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 2 );
    }
    elsif ( UnixDate("now","$opt_listings") eq $opt_listings ) {
	mkpathtofile($opt_listings, $opt_debug) || die "mkdir $opt_listings:$!";
	print STDERR "writing listings to $opt_listings\n";
	$output_g = new IO::File("> $opt_listings") || die "$opt_listings: $!";
	push(@FilesWeOpened_g, $opt_listings);
	$writer_g = new XML::Writer(OUTPUT=>$output_g,
				     DATA_MODE => 1, DATA_INDENT => 2 );
    }
    
    if ( defined($writer_g) ) {
	writeListingsXMLHeader($writer_g);
	$stats->{num_channels}=writeOutChannels($config, $writer_g);
    }

    my $failedCount=0;
    my ($y,$m,$d,$h,$mn,$s)=Date::Manip::Date_Split(ParseDateString("now"));
    my $startNDay=Date_DayOfYear($m,$d,$y);
    my $tz=Date_TimeZone();

    #
    # So that the output a day at a time, this allows for separate files per day
    #
    my $year=$y;
    my $runNDayOfYear=$startNDay + $opt_offset;
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	my $writer;
	my $output;

	# handle cross-year listings
	while ( $runNDayOfYear+$nday > Date_DaysInYear($year) ) {
	    $runNDayOfYear-=Date_DaysInYear($year);
	    $year++;
	}
	

	$stats->{num_days}++;;

	my $dateStr=createDateString(0, $runNDayOfYear+$nday, $year, 0, $tz);

	if ( defined($writer_g) ) {
	    $writer=$writer_g;
	}
	else {
	    my $filename=UnixDate($dateStr, "$opt_listings");
	    if ( $opt_listings eq $filename ) {
		die "This case should have been caught before here";
	    }
	    
	    mkpathtofile($filename, $opt_debug) || die "mkdir $opt_listings:$!";
	    print STDERR "writing listings to $filename\n";
	    $output = new IO::File("> $filename") || die "$filename: $!";
	    push(@FilesWeOpened_g, $filename);
	    $writer = new XML::Writer(OUTPUT=>$output,
					 DATA_MODE => 1, DATA_INDENT => 2 );
	    writeListingsXMLHeader($writer);
	    $stats->{num_channels}=writeOutChannels($config, $writer);
	}
	
	my $lg=new XMLTV::ZapListings::Scraper('PostalCode'=> $config->{option_postalcode},
					       'ZipCode'   =>$config->{option_zipcode},
					       'ProviderID'=>$config->{option_provider},
					       'Debug'     =>$opt_debug,
					       'DebugListings'     =>$opt_debuglistings);

	foreach my $station ($config->stationsInDisplayOrder()) {
	    
	    next if ( !$config->stationIncluded($station) );
	    
	    if ( defined($config->getStationTransientFlag($station, 'notavailable')) ) {
		print STDERR "skipping unavailable channel $station\n";
		next;
	    }

	    if ( !defined($config->getStationTransientFlag($station, 'zap2it-id')) ) {
		warn "ignoring channel without zap2it channel id $station\n";
		next;
	    }

	    my ($Year,$month,$day,$hr,$min,$sec)=Date::Manip::Date_NthDayOfYear($year, $runNDayOfYear+$nday);
	    
	    if ( $lg->readSchedule($config->getStationTransientFlag($station, 'zap2it-id'),
				   $station,
				   $day, $month, $Year) == -1 ) {
		warn("readSchedule failed for $Year-$month-$day for station $station");
		$failedCount++;
	    }
	    else {
		# set time zone for date conversions
		#Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
		#Date::Manip::Date_Init();
		
		$stats->{num_programs}+=writeOutPrograms($lg, $runNDayOfYear+$nday, $Year, $tz, $writer, $station);
	    }
	}
	
	if ( !defined($writer_g) || $writer != $writer_g ) {
	    writeListingsXMLFooter($writer);
	    $writer->end();
	    $output->close();
	}
    }

    if ( defined($writer_g) ) {
	writeListingsXMLFooter($writer_g);
	$writer_g->end();
	$output_g->close() if ( defined($output_g) );
    }

    my $endTime=time();
    printf(STDERR "Grabbed %d programs on %d channels over %d day(s) in %d seconds\n",
	   $stats->{num_programs},
	   $stats->{num_channels},
	   $stats->{num_days},
	   $endTime-$startTime);

    printf(STDERR "  not too bad, that's %.2f programs/sec and %.2f seconds/www page\n",
	   $stats->{num_programs}/($endTime-$startTime),
	   ($endTime-$startTime)/($stats->{num_days}*$stats->{num_channels}));
	    
    return($failedCount);
}

# create a conversion string
sub createDateString($$$$$)
{
    my ($minuteOfDay, $dayOfYear, $year, $additionalMin, $time_zone)=@_;
    
    if ( $additionalMin != 0 ) {
	$minuteOfDay+=$additionalMin;

	# deal with case where additional minutes pushes us over end of day
	if ( $minuteOfDay > 24*60 ) {
	    $minuteOfDay-=24*60;
	    $dayOfYear++;

	    # check and deal with case where this pushes us past end of year
	    my $isleap=Date_LeapYear($year);
	    if ($dayOfYear >= ($isleap ? 367 : 366)) {
		$year++;
		$dayOfYear-=($isleap ? 367 : 366);
	    }
	}
    }

    # account for end of year boundaries
    while ( $dayOfYear > Date_DaysInYear($year) ) {
	$dayOfYear-=Date_DaysInYear($year);
	$year++;
    }

    # calculate year,month and day from nth day of year info
    my ($pYEAR,$pMONTH,$pDAY,$pHR,$pMIN,$pSEC)=Date::Manip::Date_NthDayOfYear($year, $dayOfYear);

    # set HR and MIN to what they should really be
    $pHR=int($minuteOfDay/60);
    $pMIN=$minuteOfDay-($pHR*60);

    return(sprintf("%4d%02d%02d%02d%02d00 %s", $pYEAR, $pMONTH, $pDAY, $pHR, $pMIN, $time_zone));
}

sub writeOutPrograms($$$$$$)
{
    my ($lg, $dayOfYear, $year, $mytz, $writer, $channel)=@_;
    my $IncludePartialPrograms=0;

    my @programs=$lg->getPrograms();

    for my $prog (@programs) {

	$prog->{start}=createDateString(($prog->{start_hour}*60+$prog->{start_min}), $dayOfYear, $year, 0, $mytz);
	delete($prog->{start_hour});
	delete($prog->{start_min});
	if ( $prog->{end_hour} >= 24 ) {
	    $prog->{end}=createDateString((($prog->{end_hour}-24)*60+$prog->{end_min}), $dayOfYear+1, $year, 0, $mytz);
	}
	else {
	    $prog->{end}=createDateString(($prog->{end_hour}*60+$prog->{end_min}), $dayOfYear, $year, 0, $mytz);
	}
	delete($prog->{end_hour});
	delete($prog->{end_min});

	my $title=$prog->{title};
	    
	#print STDERR "storing $title..\n";

	if ( defined($prog->{contFromPreviousListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which starts previous to listing\n";
		next;
	    }
	    $title="(<-cont) $title";
	}
	if ( defined($prog->{contToNextListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which ends past listing boundaries\n";
		next;
	    }
	    $title="$title (cont->)";
	}
	
	$writer->startTag('programme', start=> $prog->{start}, 
			  stop => $prog->{end}, channel=> "$channel");
	if ( defined($prog->{precomment}) ) {
	    # -- in comments causes carp() calls in Writer.pm
	   $prog->{precomment}=~s/\-\-/\=\=/og;

	   # imbed in programme output a comment
	   # this is here for debugging listings and their results
	   $writer->comment("\n   ".$prog->{precomment});
	}
	$writer->dataElement('title', $title);
	$writer->dataElement('sub-title', $prog->{subtitle}) if ( defined($prog->{subtitle}) );
	$writer->dataElement('desc', $prog->{desc}) if ( defined($prog->{desc}) );
		
	if ( defined($prog->{director}) || defined($prog->{actors}) ) {
	    $writer->startTag('credits');
	    $writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
	    if ( defined($prog->{actors}) ) {
		foreach my $actor (@{$prog->{actors}}) {
		    $writer->dataElement('actor', $actor);
		}
	    }
	    $writer->endTag('credits');
	}
	$writer->dataElement('date', $prog->{year}) if ( defined($prog->{year}) );
	
	if ( defined($prog->{category}) ) {
	    foreach my $cat(@{$prog->{category}}) {
		$writer->dataElement('category', $cat);
	    }
	}
	# hunt for things in the "qualifiers bucket" where alot of things fall.
	if ( defined($prog->{qualifiers}) ) {
	    if ( defined($prog->{qualifiers}->{PaidProgram}) ) {
		# FIXME I don't that payment counts as a
		# 'category'.  Though there should probably be
		# some way to include it.  -- epa98@doc.ic.ac.uk
		# 
		$writer->dataElement('category', "advertisement");
	    }
	    if ( defined($prog->{qualifiers}->{Language}) ) {
		if ( defined($prog->{qualifiers}->{Dubbed}) ) {
		    $writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		    $writer->dataElement('language', $prog->{qualifiers}->{Dubbed});
		}
		else {
		    $writer->dataElement('language', $prog->{qualifiers}->{Language});
		}
	    }
	    
	    if ( defined($prog->{qualifiers}->{Taped}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{InProgress}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		# nowhere to put this
		# comes in the form of "Part 1 of 2"
		$writer->dataElement('episode-num', $prog->{qualifiers}->{PartInfo});
	    }
	    if ( defined($prog->{qualifiers}->{Live}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{CallIn}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{Animated}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{HDTV}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		$writer->startTag('video');
		$writer->dataElement('colour', 'no');
		$writer->endTag('video');
	    }
	    if ( defined($prog->{qualifiers}->{InStereo}) ) {
		$writer->startTag('audio');
		# The 'stereo' element requires some text inside it,
		# so you have to say <stereo>stereo</stereo>.  :-P.
		$writer->dataElement('stereo', 'stereo');
		$writer->endTag('audio');
	    }
	    if ( defined($prog->{qualifiers}->{PreviouslyShown}) ) {
		# Write as <previously-shown /> to indicate there is
		# no textual content, not even the empty string :-).
		$writer->emptyTag('previously-shown');
	    }
	    if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		$writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
	    }
	    if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		$writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
	    }

	    if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		$writer->startTag('subtitles', 'type' => 'onscreen');
		if ( defined($prog->{qualifiers}->{Subtitles}->{Language}) ) {
		    $writer->dataElement('language', $prog->{qualifiers}->{Subtitles}->{Language});
		}
		$writer->endTag('subtitles');
	    }
	    elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		# Write as <subtitles></subtitles> to show that there
		# _could_ be subelements, they're just not there.
		$writer->dataElement('subtitles', '', 'type' => "teletext");
	    }
	}
	if ( defined($prog->{ratings_VCHIP}) ) {
	    $writer->startTag('rating', system => 'VCHIP');
	    if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		$writer->dataElement('value', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}");
	    }
	    else {
		$writer->dataElement('value', $prog->{ratings_VCHIP});
	    }
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_MPAA}) ) {
	    $writer->startTag('rating', 'system' =>'MPAA');
	    $writer->dataElement('value', $prog->{ratings_MPAA});
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_ESRB}) ) {
	    $writer->startTag('rating', 'system' => 'ESRB');
	    $writer->dataElement('value', $prog->{ratings_ESRB});
	    $writer->endTag('rating');
	}
	if ( defined($prog->{ratings_Warnings}) ) {
	    my %hash;
	    foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		$hash{$k}=1;
	    }
	    foreach my $k ( keys %hash ) {
		$writer->startTag('rating', 'system' => 'General Warning');
		$writer->dataElement('value', $k);
		$writer->endTag('rating');
	    }
	}
	if ( defined($prog->{star_rating}) ) {
	    # comes in the form of a rating out fraction X/Y (X out of Y)
	    $writer->startTag('star-rating');
	    $writer->dataElement('value', $prog->{star_rating});
	    $writer->endTag('star-rating');
	}
	$writer->endTag('programme');
    }
    return(scalar(@programs));
}

# write the channels in xml format
sub writeOutChannels($$)
{
    my ($config, $writer)=@_;

    my $count=0;
    foreach my $station ($config->stationsInDisplayOrder()) {
	
	next if ( defined($config->getStationTransientFlag($station, 'notavailable')) );
	next if ( !$config->stationIncluded($station));

	$writer->startTag('channel', id=> $station);

	$writer->dataElement('display-name', "Channel $station");
	if ( defined($config->stationIcon($station)) ) {
	    # Write as empty tag because icon can never contain anything.
	    $writer->emptyTag('icon', 'src'=>$config->stationIcon($station));
	}

	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
	$count++;
    }

    return($count);
}

1;
