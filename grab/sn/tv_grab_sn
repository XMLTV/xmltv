#!/usr/bin/perl -w

=head1 NAME

tv_grab_sn - Grab TV listings for Sweden.

=head1 SYNOPSIS

tv_grab_sn --help

tv_grab_sn [--config-file FILE] --configure

tv_grab_sn [--config-file FILE] [--output FILE] [--days N]

=head1 DESCRIPTION

Output TV listings for several channels available in Sweden or Norway.
The data comes from www.dagenstv.com which is owned by the largest
company providing TV listings in Sweden.  The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_sn --configure> to choose whether you want Swedish
or Norwegian listings.  Then running B<tv_grab_sn> with no arguments
will output listings in XML format to standard output.

B<--configure> Prompt for Sweden or Norway and write the configuration
file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_sn>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  The default is ten.

B<--offset N> start N days in the future.  The default is to start
from today.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Stefan Görling, stefan@gorling.se

=head1 BUGS

The data source does not include full channels information and the
channels are identified by short names rather than the RFC2838 form
recommended by the XMLTV DTD.

I havenE<39>t even considered what happends whith DST issues.

=cut

use strict;
use Getopt::Long;
use Date::Manip;
use LWP::Simple;
use HTML::TableExtract; # parse html nicer than regular expressions.
use Date::Manip;
use IO::File;

use XMLTV;
use XMLTV::Memoize; XMLTV::Memoize::check_argv();
use XMLTV::Ask;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get Swedish or Norwegian television listings in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
END
  ;

# Use Term::ProgressBar if installed.
my $have_bar;
BEGIN {
    eval { require Term::ProgressBar };
    $have_bar = not $@;
}

# Whether zero-length programmes should be included in the output.
my $WRITE_ZERO_LENGTH = 0;

# For an unknown reason, the site includes '&#xxxx' character
# escapes even though the page is Latin-1 and so should not
# have chars outside the 8-bit range.  Try to make them into
# something legal.
#
# This is partly based on web searches for examples of Spanish
# words with the missing letter filled in, so it may not be
# accurate.
my %char_map
  = (8217 => 'i',
     8212 => chr(242),		# LATIN SMALL LETTER O WITH GRAVE
     8211 => chr(241),		# LATIN SMALL LETTER N WITH TILDE
     8240 => chr(226),		# LATIN SMALL LETTER A WITH CIRCUMFLEX
     8226 => chr(239),		# LATIN SMALL LETTER I WITH DIAERESIS
     8218 => 'i',
     2014 => '--',
     382  => chr(251),		# LATIN SMALL LETTER U WITH CIRCUMFLEX
     353  => chr(220),          # LATIN CAPITAL LETTER U WITH DIAERESIS
     339  => 'u',
    );

# Get options.
XMLTV::Memoize::check_argv('get');
my ($opt_days,$opt_offset, $opt_help, $opt_output,
    $opt_configure, $opt_config_file);
$opt_days = 10;  # default
$opt_offset = 0; # default
GetOptions('days=i'        => \$opt_days,
	   'offset=i'      => \$opt_offset,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/tv_grab_sn";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = 'tv_grab_sn';
    }
}

# FIXME commonize this configuration stuff within the XMLTV project.
if ($opt_configure) {
    if (-e $CONFIG_FILE) {
	print <<END
The configuration file $CONFIG_FILE already exists.  There is
currently no support for altering an existing configuration, you have
to reconfigure from scratch.

END
  ;
	if (not askBooleanQuestion
	    ('Do you wish to overwrite the old configuration?', 0)) {
	    print "Exiting.\n";
	    exit 0;
	}
    }
}
else {
    if (-e $CONFIG_FILE) {
	print STDERR "using config file $CONFIG_FILE\n";
    }
    else {
	die "config file $CONFIG_FILE does not exist, run me with --configure\n";
    }
}

if ($opt_configure) {
    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    my %cs = (Sweden => 'se', Norway => 'no');
    my $default_cn = 'Sweden';
    my $cn = askQuestion('Grab listings for which country?',
			 $default_cn,
			 sort keys %cs);
    my $c = $cs{$cn}; die if not defined $c;
    print CONF "country $c\t# $cn\n";
    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab listings.\n";
    exit();
}

my $country;
open(CONF, $CONFIG_FILE) or die "cannot read $CONFIG_FILE: $!\n";
while (<CONF>) {
    s/\#.*//; s/^\s+//; s/\s+$//;
    next if not length;
    if (/^country\s+(\w\w)$/) {
	warn "$CONFIG_FILE:$.: already seen country\n"
	  if defined $country;
	$country = $1;
    }
    else {
	warn "$CONFIG_FILE:$.: bad line\n";
    }
}

sub tidy( $ );
sub nextday( $ );
sub process_table( $$$$ );
sub dc( $$ );
sub pd( $ );

# Assume the listings source uses CET (see BUGS above).
Date_Init('TZ=CET');
my $now = dc(pd('now'), "+ $opt_offset days");

# Memoize some date parsing routines, if possible.  FIXME move to
# XMLTV::Memoize.
#
eval { require Memoize };
unless ($@) {
    foreach (qw(nextday pd UnixDate dc Date_Cmp)) {
	Memoize::memoize($_) or warn "cannot memoize $_";
    }
}

#Find Channels.
my $bar = new Term::ProgressBar('getting list of channels', 1)
  if $have_bar;
my $url="http://www.dagenstv.com/$country/frontpage";
my $local_data=get($url);
update $bar if $have_bar;
if ($local_data=~m/<select\s*name=\"cha\"(.*?)<\/select>/s) {
    $local_data=$1;
    my %w_args;
    if (defined $opt_output) {
	my $fh = new IO::File(">$opt_output");
	die "cannot write to $opt_output: $!" if not defined $fh;
	$w_args{OUTPUT} = $fh;
    }
    $w_args{encoding} = 'ISO-8859-1';
    my $w = new XMLTV::Writer(%w_args);

    # TODO: standardize these things between grabbers.
    $w->start({ 'source-info-url'     => 'http://www.dagenstv.com/',
		'source-data-url'     => "http://www.dagenstv.com/$country/frontpage",
		'generator-info-name' => 'XMLTV',
		'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
	      });
    # TODO write <channel> elements.

    # for each channel
    my @to_get;
    while ($local_data=~m/<option\s*value=\"(\d+)\"\s*>([^>]+)<\/option>/sg) {
	my $ch_name=tidy($2);
	my $ch_did=$1;
	my $ch_xid="$ch_did.dagenstv.com";
	$w->write_channel({ id => $ch_xid, 'display-name' => [ [ $ch_name ] ] });
	my $day=$now;
	for (my $i=0;$i<$opt_days;$i++) {
	    #for each day
	    if ($i>0) {
		$day=dc($day, '+ 1 day'); die if not defined $day;
	    }
	    push @to_get, [ $day, $ch_xid, $ch_did ];
	}
    }

    # This progress bar is for both downloading and parsing.  Maybe
    # they could be separate, as with tv_grab_uk.
    #
    my $bar = new Term::ProgressBar('getting listings', scalar @to_get)
      if $have_bar;
    foreach (@to_get) {
	process_table($w, $_->[0], $_->[1], $_->[2]);
	update $bar if $have_bar;
    }
    $w->end();
}else{
    die "Could not find channel listing.";
}


#Fetch a URL and process it.
#
#Arguments:
#    XMLTV::Writer object to write to
#    Date::Manip object giving the day to grab
#    xmltv id of channel
#    dagenstv id of channel
sub process_table( $$$$ ) {
    my ($w, $date, $ch_xmltv_id, $ch_dagenstv_id) = @_;
    my $today = UnixDate($date, '%Y-%m-%d');
    my $url = "http://www.dagenstv.com/$country/chart/?dat=$today&cha=$ch_dagenstv_id";
    my $data=get($url);
    if (not defined $data) {
	die "could not fetch $url, aborting\n";
    }
    local $SIG{__WARN__} = sub {
	warn "$url: $_[0]";
    };

    my $te = new HTML::TableExtract(depth=>3, count=>5,keep_html=>1 );
    my $ts;
    $te->parse($data);
    my $table=$te->first_table_found();
    $today =~ tr/-//d;
    my %program = (channel => $ch_xmltv_id);
    foreach my $row ($te->rows($table)) {
	# Get the interesting fields of this row.
	my ($first, $third) = (tidy($row->[0]), tidy($row->[2]));

	if ($first=~m/(\d\d:\d\d)/) {
	    if (defined $program{title} && not defined $program{stop}) {
		#We have a record without endtime. use next starttime as endtime
		$program{stop} = pd("$today $1 CET");
		my $cmp = Date_Cmp($program{start}, $program{stop});
		if ($cmp > 0) {
		    $today = nextday($today);
		    $program{stop} = pd("$today $1 CET");
		}

		if ($WRITE_ZERO_LENGTH or $cmp) {
		    foreach (@program{'start', 'stop'}) {
			# Convert to plain strings for writing.
			$_ = UnixDate($_, '%q %z');
		    }
		    $w->write_programme(\%program);
		}
		%program = (channel => $ch_xmltv_id);
	    }

	    $program{start} = pd("$today $1 CET");

	    if (defined $third) {
		my %classes = (charteventname => sub {
				   push @{$program{title}}, [ $_ ];
			       },
			       chartshowview => sub {
				   if (/^\[(\d+)\]$/) {
				       $program{showview} = $1;
				   }
				   else {
				       warn "bad showview number '$_'\n";
				   }
			       },
			       chartdescription => sub {
				   push @{$program{desc}}, [ $_ ];
			       },
			      );
		while ($third=~s/<span class=\"([^>]+?)\">\s*([^<]+)\s*</</) {
		    my ($class, $content) = ($1, $2);
		    my $handler = $classes{$class};
		    if (not defined $handler) {
			warn "unknown class $class in HTML\n";
			next;
		    }
		    for ($content) { $handler->() }
		}

		if ($third=~m/<\/span>\s*\((\d\d:\d\d)\)\s*</s) {
		    $program{stop}=pd("$today $1 CET");
		    my $cmp = Date_Cmp($program{start}, $program{stop});
		    if ($cmp > 0) {
			$today = nextday($today);
			$program{stop} = pd("$today $1 CET");
		    }

		    if ($WRITE_ZERO_LENGTH or $cmp) {
			foreach (@program{'start', 'stop'}) {
			    # Convert to plain strings for writing.
			    $_ = UnixDate($_, '%q %z');
			}
			$w->write_programme(\%program);
		    }
		    %program = (channel => $ch_xmltv_id);
		}
	    }			# if we have a time row.
	}
    }
}


# Trim spaces and newlines, fix rogue characters.
my %warned_char;
# I hope that these &#xxx; entities are decimal not octal.
sub decode_char( $ ) {
    for (shift) {
	if ($_ < 256) {
	    # It might not be a legal Latin-1 value but we deal with
	    # those afterwards.
	    #
	    return chr($_);
	}
	elsif ($_ >= 256 and $_ < 65536) {
	    # 16-bit character, really shouldn't occur.  We can
	    # correct some of these.
	    #
	    my $to = $char_map{$_};
	    if (not defined $to) {
		warn "stripping unknown 16-bit character $_ in HTML\n"
		  unless $warned_char{$_}++;
		return '';
	    }
	    return $to;
	}
	else {
	    warn "stripping very strange character $_ in HTML\n"
	      unless $warned_char{$_}++;
	    return '';
	}
    }
}
# Remove weird characters and entities in the HTML.  Some of these
# come from Per Wigren's dagenstv2xmltv grabber, but most are just
# observed from what the site returns.
#
# Could use HTML::Entites for at least some of these things.
sub tidy($) {
    for (my $tmp=shift) {
	return undef if not defined;
	s/\n$//sg;
	s/\s*$//sg;
	s/^\s*//sg;

	# Deal with &#xxx; entities, including those which specify
	# illegal characters.
	s/&\#(\d{3,});/decode_char($1)/eg;
	s/&\#[xX](\d{3,});/decode_char(oct("0x$1"))/eg;

	# We've reduced the string to 8-bit chars, but some of them
	# are not legal Latin-1.
	s/([\000-\037])//g; # remove control characters
	tr/\220/\352/;      # LATIN SMALL LETTER E WITH CIRCUMFLEX
	tr/\235/\371/;      # LATIN SMALL LETTER U WITH GRAVE
	tr/†/?/;         # no idea, FIXME
	tr/\217/e/;
	tr/\200-\237//d && warn "removing illegal high-bit-set chars\n";

	s/&[rl]squo;/chr(39)/eg; # ' character
	s/&[rl]dquo;/chr(22)/eg; # " character
	s/&mdash;/--/g;

	# dagenstv2xmltv does &[aeiou](grave|acute|circ|tilde|uml|ring);
	# entities, but I have never seen them in the site's output.

	# It's not necessary to change the copyright sign 169, because
	# that is a legal character in the Latin-1 output.

	s/&lt;/</g;
	s/&gt;/>/g;
	s/&amp;/&/g;

	return $_;
    }
}

# Bump a YYYYMMDD date by one.
sub nextday( $ ) {
    my $d = shift; $d =~ /^\d{8}$/ or die;
    my $p = pd($d);
    my $n = dc($p, '+ 1 day');
    return UnixDate($n, '%Q');
}

# Wrapper for DateCalc().
sub dc( $$ ) {
    my $err;
    my $r = DateCalc(@_, \$err);
    die "DateCalc() failed with $err" if $err;
    die 'DateCalc() returned undef' if not defined $r;
    return $r;
}

# Wrapper for ParseDate().  FIXME commonize.
sub pd( $ ) {
    for ($_[0]) {
	return undef if not defined;
	my $r = ParseDate($_);
	die "bad date $_" if not defined $r or not length $r;
	return $r;
    }
}
