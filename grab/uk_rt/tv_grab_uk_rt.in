#!/usr/bin/perl
=pod

=head1 NAME

tv_grab_uk_rt - Grab TV listings for United Kingdom and Republic of Ireland

=head1 SYNOPSIS

tv_grab_uk_rt --help

tv_grab_uk_rt --configure [--config-file FILE]

tv_grab_uk_rt [--config-file FILE] [--output FILE] [--days N] [--offset N]
              [--gui OPTION] [--quiet]

tv_grab_uk_rt --list-channels

tv_grab_uk_rt --capabilities

tv_grab_uk_rt --version

=head1 DESCRIPTION

Output TV listings in XMLTV format for many stations available in the 
United Kingdom and Republic of Ireland.  The data comes from 
machine-readable files produced by the Radio Times website.

=head1 USAGE

First you must run B<tv_grab_uk_rt --configure> to choose which stations you
want to receive.  Then running B<tv_grab_uk_rt> with no arguments will get
about a fortnightE<39>s listings for the stations you chose.

B<--configure> Prompt for which stations to download and write the
configuration file.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of Term::ProgressBar.

B<--config-file FILE> Set the name of the configuration file, the default is
B<~/.xmltv/tv_grab_uk_rt.conf>.  This is the file written by B<--configure> and
read when grabbing.

B<--output FILE> When grabbing, write output to FILE rather than standard
output.

B<--quiet> Suppress the progress messages normally written to standard error.

B<--days N> When grabbing, grab N days of data instead of all available.

B<--offset N> Start grabbing at today + N days.

B<--list-channels> Write output giving <channel> elements for every channel
available, but no programmes.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://xmltv.org/wiki/xmltvcapabilities.html>

B<--version> Show the version of the grabber.

B<--help> Print a help message and exit.

Note that tv_grab_uk_rt always downloads data for all days and then filters
out the days specified with --days and --offset. It is therefore more
efficient to omit --days and --offset and use all the returned data.

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.radiotimes.com/>

=head1 AUTHOR

Ed Avis, ed@membled.com

Nick Morrott, knowledgejunkie@gmail.com (maintainer)

=cut

use warnings;
use strict;
use XMLTV::Version '$Id$ ';
use XMLTV::Capabilities qw/baseline manualconfig cache preferredmethod/;
use XMLTV::Description 'United Kingdom/Republic of Ireland (Radio Times)';
use XMLTV::PreferredMethod qw/allatonce/;
use Getopt::Long;
use Unicode::UTF8simple;
use Date::Manip; Date_Init('TZ=+0000');
use XMLTV::Config_file;
use XMLTV::Get_nice;
use XMLTV::Ask;
use XMLTV::ProgressBar;
use File::Path;
use File::Basename;
use LWP::Simple qw($ua get); $ua->agent("xmltv/$XMLTV::VERSION");
use HTTP::Cache::Transparent;
use XMLTV::Memoize; XMLTV::Memoize::check_argv 'get_nice';
use XMLTV::DST;
use XMLTV::Supplement qw/GetSupplement SetSupplementRoot/;
use XMLTV::Usage <<END
$0: Get TV listings for United Kingdom and Republic of Ireland in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N] [--offset N]
                     [--gui OPTION] [--quiet]
To list channels: $0 --list-channels
To show capabilities: $0 --capabilities
To show version: $0 --version
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
        *t = sub {};
        *d = sub { '' };
    }
    else {
        *t = \&Log::TraceMessages::t;
        *d = \&Log::TraceMessages::d;
        Log::TraceMessages::check_argv();
    }
}

# This script is intended for grabbing
$XMLTV::Get_nice::Delay = 0;

# The Radio Times data is made available in UTF-8 format
my $uref = new Unicode::UTF8simple;

# Location of Radio Times channel index file
my $rt_channels_uri = 'http://xmltv.radiotimes.com/xmltv/channels.dat';

# Retrieve tv_grab_uk_rt channel_ids mapping via XMLTV::Supplement
my $xmltv_channel_ids = GetSupplement( 'tv_grab_uk_rt', 'channel_ids' );

# Get default location to store cached listings data
my $default_cachedir = get_default_cachedir();

init_cachedir( $default_cachedir );

HTTP::Cache::Transparent::init( {
    BasePath => $default_cachedir,
    MaxAge => 15*24,
    NoUpdate => 15*60,
    Verbose => 0,
    ApproveContent => \&check_content_length,
} );

sub get_default_cachedir {
    my $winhome = $ENV{HOMEDRIVE} . $ENV{HOMEPATH}
    if defined( $ENV{HOMEDRIVE} )
        and defined( $ENV{HOMEPATH} );
        
    my $home = $ENV{HOME} || $winhome || ".";
    return "$home/.xmltv/cache";
}

sub init_cachedir {
    my( $path ) = @_;
    if( not -d $path ) {
        mkpath( $path ) or die "Failed to create cache-directory $path: $@";
    }
}

# Check whether data files on the RT website are empty but still online, or
# contain HTML/XML from the Radio Times' error page.
#
# These files will have a good HTTP response header as they exist, but they
# contain no data. Caching via HCT without checking for a non-zero content_size
# beforehand will therefore overwrite good data with bad. Any file having a
# content_length of 0 or seen to contain DOCTYPE info will not be cached and the 
# existing cached copy of the file will be used instead.
#
# Support for this functionality requires using at least the 1.0 version of
# HTTP::Cache::Transparent, which can be obtained from CPAN.
#
sub check_content_length {
    my $rt_file = shift @_;
    if( $rt_file->is_success ) {
        if( $rt_file->content_length == 0 || $rt_file->content =~ /DOCTYPE/ ) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        return 0;
    }
}

sub configure();

GetOptions('help'      => \ my $opt_help,
       'configure'     => \ my $opt_configure,
       'config-file=s' => \ my $opt_config_file,
       'gui:s'         => \ my $opt_gui,
       'output=s'      => \ my $opt_output,
       'share=s'       => \ my $opt_share, # also undocumented
       'quiet'         => \ my $opt_quiet,
       'list-channels' => \ my $opt_list_channels,
       'days=s'        => \ my $opt_days,
       'offset=s'      => \ my $opt_offset,
       )
  or usage(0);

if ($opt_help) {
    usage(1);
}

# Required for Tk
XMLTV::Ask::init($opt_gui);

# Stuff for the root <tv> element.
my %tv_credits = ( # 'source-info-url'     => "todo",
           'source-info-name'    => 'Radio Times',
           'generator-info-name' => 'XMLTV',
           'generator-info-url'  =>
           'http://xmltv.org/wiki/',
           );


# Tables to convert between Radio Times and XMLTV ids of channels.
# The way to access these is through the routines rt_to_xmltv() and
# xmltv_to_rt(), not directly.  Those will deal sensibly with a new RT
# channel that isn't mentioned in the file.
#
my @lines = split( /[\n\r]+/, $xmltv_channel_ids );
my (%rt_to_xmltv, %xmltv_to_rt, %extra_dn, %icon_urls);
foreach my $line (@lines) {
    next if $line =~ '^#';
    my @fields = split( /\|/, $line );
    # We need at least 2 fields (xmltv_id,rt_id) to run the grabber
    # No check on maximum number of fields to support future updates
    # to channel_ids now we are using XMLTV::Supplement
    die "Wrong number of fields in XMLTV channel_ids file. Please update XMLTV"
      if @fields < 2;

    # First 4 fields of channel_ids file are:
    # i) XMLTV ID ii) RT ID iii) Name of channel iv) Icon URL
    # The RT channels.dat provides a channel name - here we provide
    # an alternative or updated name if the channel name has changed
    my ($xmltv_id, $rt_id, $extra_dn, $icon_url) = @fields;

    if (not $opt_quiet) {
        warn "RT ID '$rt_id' already seen in XMLTV channel_ids file\n"
          if defined $rt_to_xmltv{$rt_id};
    }
    $rt_to_xmltv{$rt_id} = $xmltv_id;

    if (not $opt_quiet) {
        warn "XMLTV ID '$xmltv_id' already seen in XMLTV channel_ids file\n"
          if defined $xmltv_to_rt{$xmltv_id};
    }
    $xmltv_to_rt{$xmltv_id} = $rt_id;

    $extra_dn{$xmltv_id} = $extra_dn if defined $extra_dn;
    $icon_urls{$xmltv_id} = $icon_url if defined $icon_url;
}

# Keep output on STDERR preserving STDOUT for XML data
say( "\nAll data is the copyright of the Radio Times website
<http://www.radiotimes.com> and the use of this data
is restricted to personal use only.\n" ) if not $opt_quiet;

# Process the list of available channels from the RT site
my (%channels, %seen_rt_id, %seen_name);
my $rt_channels_dat_utf8 = get $rt_channels_uri;
my $rt_channels_dat = $uref->fromUTF8( "iso-8859-1" , $rt_channels_dat_utf8 );
my @rt_channels = split /\n/, $rt_channels_dat;
my $num_rt_channels = scalar @rt_channels;
say( "Radio Times reports available listings for $num_rt_channels channels.\n")
  if not $opt_quiet;

my $chans_bar = new XMLTV::ProgressBar({name   => 'Retrieving channels',
                                        count  => $num_rt_channels,
                                        ETA    => 'linear', })
                                          if not $opt_quiet;
my $need_final_update = 0;

foreach (@rt_channels) {
    chomp;
    /^(\d+)\|(.+)/ or die "Bad line seen in RT channels.dat: $_";
    my ($rt_id, $name) = ($1, $2);
    if ($seen_rt_id{$rt_id}++) {
        die "RT channel ID '$rt_id' already seen in RT channels.dat, aborting";
    }
    if ($seen_name{$name}++) {
        if (not $opt_quiet) {
            warn "RT channel '$name' already seen in RT channels.dat\n";
        }
    }
    
    my $xmltv_id = $rt_to_xmltv{$rt_id};
    
    # If the current RT channel has a known XMLTV ID, check it against known bad
    # channels and skip it if required. If the channel does not have an 
    # XMLTV ID, create one and continue.
    if (defined $xmltv_id) {
        # Skip any RT entries which have been flagged as bad in channel_ids file
        if ( $extra_dn{ $rt_to_xmltv{$rt_id} } =~ /.*Do\ Not\ Use.*/ ) {
    #       if (not $opt_quiet) {
    #           warn "RT channel '$name' ($rt_id) flagged as bad, skipping\n";
    #       }
            $need_final_update = 1;
            next;
        }
    } else {
        # Handle new channels on RT site unknown to channel_ids
        if (not $opt_quiet) {
            warn "RT channel '$name' ($rt_id) unknown in XMLTV channel_ids file\n";
        }
        $xmltv_id = "C$rt_id.radiotimes.com";
    }

    my @names = ([ $name ]);
    my $icon_url = $icon_urls{$xmltv_id};
    my @icon = { 'src' => $icon_url } if $icon_url;
    for ($extra_dn{$xmltv_id}) { push @names, [ $_ ] if defined }
    if (@icon) {
        $channels{$xmltv_id} = { id => $xmltv_id,
                                 rt_id => $rt_id,
                                 'display-name' => \@names,
                                 'icon' => \@icon };
    } else {
        $channels{$xmltv_id} = { id => $xmltv_id,
                                 rt_id => $rt_id,
                                 'display-name' => \@names };
    }
    
    # Update the progres bar by one increment
    if (defined $chans_bar) {
        $chans_bar->update();
    }
}

if (defined $chans_bar) {
    # Only update the progress bar to 100% if we need to
    $chans_bar->update($num_rt_channels) if $need_final_update;
    $chans_bar->finish();
    say( "\n" ) if not $opt_quiet;
}

if (not $opt_quiet) {
    foreach (keys %xmltv_to_rt) {
        # ignore channels flagged as bad in channel_ids
        next if $extra_dn{$_} =~ /.*Do\ Not\ Use.*/;
        warn "XMLTV channel '$_' ($xmltv_to_rt{$_}) not seen on RT site\n"
          if not exists $channels{$_};
    }
}

my %g_args = ();
if (defined $opt_output) {
    my $fh = new IO::File ">$opt_output";
    die "Cannot write to $opt_output" if not $fh;
    #    binmode $fh or die "cannot set binmode for output: $!";
    %g_args = (OUTPUT => $fh);
}

if ($opt_list_channels) {
    die "--list-channels can't be given with --configure, exiting.\n"
      if $opt_configure;
    my $writer = new XMLTV::Writer(%g_args, encoding => 'ISO-8859-1');
    $writer->start(\%tv_credits);
    foreach (sort keys %channels) {
        delete $channels{$_}{rt_id};
        $writer->write_channel($channels{$_});
    }
    $writer->end;
    exit;
}

# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_uk_rt', $opt_quiet);

if ($opt_configure) {
    configure();
    exit;
}

# Ask the user which channels to download, and write $config_file.
#
# Uses global %channels hash.
#
# FIXME commonize with other grabbers.
#
sub configure() {
    #    local $Log::TraceMessages::On = 1;

    XMLTV::Config_file::check_no_overwrite($config_file);

    # FIXME need to make directory
    open(CONF, ">$config_file") or die "Cannot write to $config_file: $!";
    t 'channels: ' . d \%channels;

    my %chan_id_to_name;
    foreach my $chan_id (keys %channels) {
        $chan_id_to_name{$chan_id} =
            $channels{$chan_id}->{'display-name'}->[0]->[0];
    }

    my @chan_ids = sort {$chan_id_to_name{$a} cmp $chan_id_to_name{$b}}
        keys %chan_id_to_name;

    my @questions;
    foreach my $chan_id (@chan_ids) {
        push @questions, "Add channel ".$chan_id_to_name{$chan_id}."? ";
    }
    my @answers = ask_many_boolean(1, @questions);

    for (my $i=0; $i < $#chan_ids; $i++) {
        if ($answers[$i]) {
            print CONF "channel ".$chan_ids[$i]."\n";
        }
    }

    close CONF or warn "cannot close $config_file: $!";
    say("Finished configuration.");
    exit();
}

# Grabbing.  Start by reading config file.
my @wanted_chs;
my $n = 0;
foreach (XMLTV::Config_file::read_lines $config_file) {
    ++$n;
    next if not defined;
    /^\s*channel\s+(\S+)\s*$/ or die "$config_file: $n: bad line $_\n";
    my $id = $1;
    if (not exists $channels{$id}) {
        warn "XMLTV channel '$id' mentioned in $config_file but is not available on RT site\n"
          if not $opt_quiet;
        next;
    }
    push @wanted_chs, $id;
}
#@wanted_chs = sort keys %channels;

my %d_args = ();
if (defined( $opt_days ) or defined( $opt_offset )) {
    $opt_offset = 0 unless defined $opt_offset;
    $opt_days = 15 unless defined $opt_days;

    $d_args{offset} = $opt_offset;
    $d_args{days} = $opt_days;
    $d_args{cutoff} = "000000";
}

my $writer = new XMLTV::Writer(%g_args, %d_args, encoding => 'ISO-8859-1');
$writer->start(\%tv_credits);
foreach (@wanted_chs) {
    my %h = %{$channels{$_}};
    delete $h{rt_id};
    $writer->write_channel(\%h);
}

my $num_req_chans = scalar @wanted_chs;

say("Downloading listings for $num_req_chans configured channels\n")
  if not $opt_quiet;

my $listings_bar = new XMLTV::ProgressBar({name   => 'Retrieving listings',
                                           count  => $num_req_chans,
                                           ETA    => 'linear', })
                                             if not $opt_quiet;

my %warned_wrong_num_fields; # give that warning once per channel file

# Reset check for final progress bar update
$need_final_update = 0;

foreach my $ch (@wanted_chs) {
    my $c = $channels{$ch};
    my $rt_id = $channels{$ch}->{rt_id}; die if not defined $rt_id;

    # Try to get the base timezone for this channel from its name.
    my $base_tz;
    if ($c->{'display-name'}->[0]->[0] =~ /\((UTC|GMT|CET)\)\s*$/) {
        $base_tz = $1;
    }
    for ($base_tz) { $_ = 'UTC' if not defined }

    my $uri = "http://xmltv.radiotimes.com/xmltv/$rt_id.dat";
    local $SIG{__DIE__} = sub { die "$uri: $_[0]" };
    local $SIG{__WARN__} = sub { warn "$uri: $_[0]" };
    my $page_utf8 = get $uri;
    my $page = $uref->fromUTF8( "iso-8859-1" , $page_utf8 );

    # Tidy up any remaining bad characters in the Radio Times data. The
    # data is provided in UTF-8 format which we convert to ISO 8859-1
    # Latin-1 format, but the text may still contain bad/null characters 
    # which should be corrected if possible before processing.
    #
    # http://en.wikipedia.org/wiki/ISO/IEC_8859-1
    # http://en.wikipedia.org/wiki/UTF-8
    #
    for ($page) {
        # Remove Unicode null (U+0000) characters
        s/\x{0000}//g;
        # Programme entries containing RT reviews or updated information
        # may have erroneous CR/space characters which we tidy up here
        s/\x0D\x20//g;
        # Incorrect UTF-8 characters may be present which we correct
        #
        # Even after decoding the source data from UTF-8 to Latin-1, the two 
        # bytes replaced below (\xC3\xA9) are the *UTF-8* representation
        # of e-grave. We need the Latin-1 code \xE9.
        s/\xC3\xA9/\xE9/g;
        # Remove any remaining non-printing ASCII/8859-1 control characters but
        # make sure we keep \t \n and \r
        s/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F-\x9F]//g;

        # Debug output for possible UTF-8-formatted characters
        if (not $opt_quiet) {
            my @utf8_chars = $page =~ /([\xC2-\xDF][\x80-\xBF])/g;
            if (@utf8_chars) {
                say ("\n");
                my $utf8_char;
                foreach $utf8_char (@utf8_chars) {
                    warn "Possible UTF-8 character seen '$utf8_char'";
                }
                say("\n");
            }
        }
    }

    foreach (split /\n/, $page) {
        my @fields = split /\~/;
        if (@fields != 23) {
            if (not $opt_quiet) {
                warn "Wrong number of fields in line:\n$_\n"
                  unless $warned_wrong_num_fields{$ch}++;
            }
            next;
        }
        foreach (@fields) { s/^\s+//; s/\s+$//; undef $_ if not length }
        
        # Description of Radio Times data fields (23 in total):
        #
        # title - the programme title (text)
        # sub_title - infrequently defined - preference is given to episode
        #             if defined (text)
        # episode - the name of a particular episode of the programme and/or 
        #           the episode's position in the current series (text)
        # year - the year of production (text)
        # director - the programme's director(s) (text)
        # cast - the programme's cast (may include character details) (text)
        # premiere - whether this is a film's first showing (boolean)
        # film - whether the programme is a film (boolean)
        # repeat - whether the programme has been shown before (boolean)
        # subtitles - whether subtitles are available (boolean)
        # widescreen - whether the broadcast is 16:9 widescreen (boolean)
        # new_series - whether the programme is the first episode in a 
        #              series new (boolean)
        # deaf_signed - whether in-vision signing is available (boolean)
        # blank_and_white - whether the broadcast is not in colour (boolean)
        # star_rating - a star rating between 0 and 5 for films (text)
        # certificate - the BBFC certificate for the programme (text)
        # genre - the genre of the programme (text)
        # desc - a description of the programme. Can be a specific review by a
        #        Radio Times reviewer (text)
        # choice - whether the programme is recommended by the 
        #          Radio Times (boolean)
        # date - the transmission date (text)
        # start - the transmission start time for the programme (text)
        # stop - the transmissions stop time for the programme (text)
        # duration_mins - the duration of the programme in minutes (text)
        my ($title, $sub_title, $episode, $year, $director, $cast,
            $premiere, $film, $repeat, $subtitles, $widescreen,
            $new_series, $deaf_signed, $black_and_white, $star_rating,
            $certificate, $genre, $desc, $choice, $date, $start, $stop,
            $duration_mins) = @fields;
        foreach ($premiere, $film, $repeat, $subtitles, $widescreen,
                 $new_series, $deaf_signed, $black_and_white, $choice) {
            die "true/false value not defined" if not defined;
            if ($_ eq 'true') { $_ = 1 }
            elsif ($_ eq 'false') { $_ = 0 }
            else { die "bad true/false value $_" }
        }

        warn "Ignoring sub-title '$sub_title' as episode '$episode' provided\n"
          if defined $sub_title and defined $episode and not $opt_quiet;
        $sub_title = $episode if defined $episode;

        if (not defined $title) {
            warn("Missing title in: $_") if not $opt_quiet;
            next;
        }

        # Parse out any explicit GMT/BST timing information the RT may include 
        # in the title for a programme.
        my $explicit_tz = '';
        if ($title =~ s/^\((GMT|UTC|BST|UTC\+1)\)\s*//) {
            $explicit_tz = $1;
        }
        
        # Remove extra non-title programme information from title. Leaving
        # this information in the title results in PVR applications not
        # being able to consistently match programme titles. 
        for($title) {
            s/^3 Minute Wonder\s*:\s*//;
            s/^4 Music\s*:\s*//;
            s/^4Play\s*:\s*//;
            s/^Bond Season\s*:\s*//;
            s/^CBBC\s*:\s*//;
            s/^CBeebies\s*:\s*//;
            s/^CITV\s*:\s*//;
            s/^Comedy Season\s*:\s*//;
            s/^Sign Zone\s*:\s*//;
            s/^T4\s*:\s*//;
        }

        my %p = (channel => $ch, title => [ [ $title ] ]);

        if (defined $sub_title && 
            ($sub_title =~ /^(\d+)\/(\d+)$/ ||
             $sub_title =~ /^(\d+)\/(\d+)\s+-\s+/))
        {
            my $episode = $1 - 1;
            my $episodes = $2;

            $p{'episode-num'} = [ [ " . ${episode}/${episodes} . ", "xmltv_ns" ] ];

            $sub_title =~ s/^(\d+)\/(\d+)(?:\s+-\s+)?//;

            undef $sub_title if $sub_title =~ /^\s*$/;
        }
        for ($sub_title) { $p{'sub-title'} = [ [ $_ ] ] if defined }
        for ($desc) {
            if (defined) {
                s/\s+/ /g;
                # s!</?[A-Za-z]+>!!g;
                $p{desc} = [ [ $_, 'en' ] ];
            }
        }
        for ($director) { $p{credits}{director} = [ $_ ] if defined }

        # The Radio Times includes cast information in 2 formats:
        #
        # a) pairings of 'character*actor' with subsequent pairings 
        #    separated by '|' - '*' does not appear in any text
        # b) a comma separated list of actors with no character details
        #
        # If 'Director' appears in the character entry, this is to be used 
        # as a regular cast member, not the programme's director
        if (defined $cast) {
            my @cast;
            
            $cast =~ s/\s+/ /g;
            
            # first we check for 'character*actor' entries
            if ($cast =~ tr/*//) {
                # multiple 'character*actor'entries
                if ($cast =~ tr/|//) {
                    @cast = split /\|/, $cast;
                }
                # single 'character*actor' entry
                else {
                    push @cast, $cast;
                }
                
                # we remove the 'character*' portion of the entry
                foreach (@cast) {
                    unless ( s/^.*[*]// ) {
                        warn "Bad cast entry for '$title': $_" if not $opt_quiet;
                    }
                }
            }
            # next we check for CSV-style actor entries
            elsif ($cast =~ tr/,//) {
                @cast = split /,/, $cast;
            }
            # finally we assume a single actor's name that contains neither 
            # '*' nor ','
            else {
                push @cast, $cast;
            }
            # trim whitespace from beginning/end of actor names
            foreach (@cast) { s/^\s+//; s/\s+$//; }
            $p{credits}{actor} = \@cast;
        }
        for ($year) { $p{date} = $_ if defined }
        push @{$p{category}}, [ $genre, 'en' ] if defined $genre and not $film;
        push @{$p{category}}, [ 'Film', 'en' ] if $film;
        $p{video}{aspect} = '16:9' if $widescreen;
        $p{video}{colour} = 0 if $black_and_white;
        $p{'previously-shown'} = {} if $repeat;
        $p{premiere} = [ '' ] if $premiere;
        $p{new} = 1 if $new_series;
        push @{$p{subtitles}},{type=>'teletext'} if $subtitles;
        push @{$p{subtitles}},{type=>'deaf-signed'} if $deaf_signed;
        $p{rating} = [ [ $certificate, 'BBFC' ] ] if defined $certificate;
        push @{$p{'star-rating'}}, [ "$star_rating/5", 'Radio Times Film Rating' ] 
            if defined $star_rating and $film;
        push @{$p{'star-rating'}}, [ '1/1', 'Radio Times Recommendation' ] if $choice;

        # Broadcast date, start/stop times, and timezone adjustments.
        #
        # The RT data includes the date at start of broadcast, the start time,
        # and the stop time of the programme, which may span a date, so we
        # adjust the stop time to account for this.
        #
        # The Radio Times sometime explicitly flags a programme's start/stop
        # times as being in a specific timezone (GMT or BST). We parse this
        # information out when processing the programme's title and apply it
        # to the start/stop times of any such programmes.
        #
        # For the majority of programmes where the timezone is not flagged 
        # explicity, we determine the TZ/offset of the programme's start time
        # via XMLTV::DST::utc_offset() and apply it to the stop time. This is 
        # required because the RT timing data for a programme that spans a DST 
        # changeover uses the same TZ/UTC offset for both times if not flagged.
        #
        # During the GMT->BST transition, any unflagged programme starting before 
        # 0100 +0000 has both start/stop times given in GMT (+0000) in the RT 
        # data. utc_offset will only provide the correct stop time if we 
        # force the TZ/offset of the stop time to GMT for a programme finishing
        # after 0100 +0000 as it will otherwise interpret the date as BST.
        #
        # DateCalc will always use TZ=+0000 when processing/displaying
        # dates ( Date_Init('TZ=+0000') ) so we must also allow for this when
        # adjusting dates and using this output with utc_offset.
        #
        # The transition from BST->GMT has a similar issue where we must
        # explicitly force a stop time to BST (+0100) for any programmes 
        # starting before the changeover and finishing at or after 0200 +0100 
        # (0100 +0000).
        #
        my ($yyyy, $mm, $dd);
        for ($date) {
            die "Missing date in $_" if not defined;
            m!(\d\d)/(\d\d)/(\d{4})$! or die "Bad date $_";
            ($dd, $mm, $yyyy) = ($1, $2, $3);
        }

        # First we handle an explicit TZ (GMT/BST) found in the programme's
        # title.
        #
        if ( $explicit_tz ) {
            $p{start} = utc_offset "$yyyy$mm$dd$start $explicit_tz", $base_tz;
            $p{stop} = utc_offset "$yyyy$mm$dd$stop $explicit_tz", $base_tz;
            if (Date_Cmp($p{start}, $p{stop}) > 0) {
                $p{stop} = utc_offset(
                               DateCalc(
                                   Date_ConvTZ(
                                       ParseDate( "$yyyy$mm$dd$stop $explicit_tz" ), 
                                       Date_TimeZone,
                                       $explicit_tz ),
                                   ParseDateDelta( "+ 1 day" ) ),
                               $base_tz);
            }
        }
        # Otherwise, we determine the timezone of the programme's start time
        # and apply the same TZ to the stop time.
        else {
            $p{start} = utc_offset "$yyyy$mm$dd$start", $base_tz;
            my $implicit_tz;
            for ($p{start}) {
                m!([+-]\d{4})$! or die "Bad UTC offset for programme $title";
                $implicit_tz = $1;
            }
            $p{stop} = utc_offset "$yyyy$mm$dd$stop $implicit_tz", $base_tz;
            if (Date_Cmp($p{start}, $p{stop}) > 0) {
                $p{stop} = utc_offset(
                               DateCalc(
                                   Date_ConvTZ(
                                       ParseDate( "$yyyy$mm$dd$stop $implicit_tz" ),
                                       Date_TimeZone,
                                       $implicit_tz ),
                                   ParseDateDelta( "+ 1 day" ) ),
                               $base_tz );
            }
        }

        # Compare the stated and calculated durations of the programme
        my $rt_prog_length = ParseDateDelta( $duration_mins . " minutes" );
        my $real_prog_length = DateCalc( ParseDate( $p{start} ),
                                         ParseDate( $p{stop} ) );
        if ($rt_prog_length ne $real_prog_length && not $opt_quiet) {
            say "Calculated/stated programme durations do not agree for '$title':";
            say "  Start time: '$p{start}'\t\tCalculated:  '$real_prog_length'";
            say "  Stop time:  '$p{stop}'\t\tRadio Times: '$rt_prog_length'\n";
        }

        # Finally, write the programme's XML data
        $writer->write_programme(\%p);
    
    }
    
    # Update the progres bar by one increment
    if (defined $listings_bar) {
        $listings_bar->update();
    }
}

$writer->end;

if (defined $listings_bar) {
    # Only update the progress bar to 100% if we need to
    $listings_bar->update($num_req_chans) if $need_final_update;
    $listings_bar->finish();
    say( "\n" ) if not $opt_quiet;
}

# Keep output on STDERR preserving STDOUT for XML data
say( "Finished!\n" ) if not $opt_quiet;
