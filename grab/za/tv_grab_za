#!/usr/bin/perl -w

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
	if 0; # not running under some shell

=pod

=head1 NAME

tv_grab_za - Grab TV listings for South Africa.

=head1 SYNOPSIS

tv_grab_za --help

tv_grab_za [--config-file FILE] --configure [--gui OPTION]

tv_grab_za [--config-file FILE] [--output FILE] [--days N]
		   [--offset N] [--quiet] [--opentime] [--opentime-combined]

=head1 DESCRIPTION

Output TV listings for DSTV channels available in South Africa.
The data comes from www.dstv.com. The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_za --configure> to choose, which channels you want
to download. Then running B<tv_grab_za> with no arguments will output
listings in XML format to standard output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_za.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of XMLTV::ProgressBar.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  Can be 1, 7, 14 or 30.  Default is 14

B<--quiet> suppress the progress messages normally written to standard
error.

B<--opentime> Discard all M-Net programs outside of opentime

B<--opentime-combined> Generate both Opentime and normal M-Net programs

B<--help> print a help message and exit.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Chris Picton, cpicton@users.sf.net.  Based on tv_grab_fi by Matti Airas.
Latest version always at http://www.tangent.co.za/index.pl/fun_stuff

=head1 BUGS

Probably many

=cut

######################################################################
# initializations

use strict;
use XMLTV::Version '$Id$ ';
use Getopt::Long;
use Date::Manip;
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;
#use Date::Parse;

use XMLTV;
use XMLTV::Memoize;
use XMLTV::ProgressBar;
use XMLTV::Ask;
use XMLTV::Config_file;
use XMLTV::DST;
use XMLTV::Get_nice;
use XMLTV::Mode;
use XMLTV::Date;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get South African television listings in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
		[--quiet] [--opentime] [--opentime-combined] [--retries]
END
  ;

use POSIX qw(strftime);

# Attributes of the root element in output.
my $HEAD = { 'source-info-url'	 => 'http://www.dstv.com/',
			 'source-data-url'	 => "http://www.dstv.com/dstv-guide/default.asp",
			 'generator-info-name' => 'XMLTV',
			 'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
		   };

# Whether zero-length programmes should be included in the output.
my $WRITE_ZERO_LENGTH = 0;

# The timezone in South Africa.
my $TZ="+0200";

# default language
my $LANG="en";

# Global channel data.
our @ch_all;

our %channelmap;

# Initialize cookie_jar
use LWP::Simple qw($ua);
use LWP::UserAgent;
use HTTP::Request::Common qw(GET);
use HTTP::Cookies;
my $cookies = HTTP::Cookies->new;
my $ua = LWP::UserAgent->new(keep_alive => 1);
# Cookies
$ua->cookie_jar($cookies);
# Define user agent type
$ua->agent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US)');

######################################################################
# Get options.
XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');
my ($opt_days, $opt_offset, $opt_help, $opt_output,
	$opt_configure, $opt_config_file, $opt_gui,
	$opt_quiet, $opt_list_channels, $opt_opentime, 
    $opt_opentime_combined, $opt_retries, $opt_cache);
$opt_days  = 14; # default
$opt_offset = 0; # default
$opt_quiet  = 0; # default
GetOptions('days=i'		=> \$opt_days,
		   'help'		  => \$opt_help,
		   'configure'	 => \$opt_configure,
		   'opentime'	  => \$opt_opentime,
		   'opentime-combined'	  => \$opt_opentime_combined,
		   'config-file=s' => \$opt_config_file,
		   'gui:s'		 => \$opt_gui,
		   'output=s'	  => \$opt_output,
		   'quiet'		 => \$opt_quiet,
		   'retries'		 => \$opt_retries,
		   'cache'		 => \$opt_cache,
		  )
  or usage(0);
die 'number of days must not be negative' 
	if (defined $opt_days && $opt_days < 0);
die 'number of days can only be 1, 7, 14 or 30' 
	if (defined $opt_days && $opt_days !~ /^(1|7|14|30)$/);
die '--opentime and --opentime-combined are mutually exclusive' 
	if (defined $opt_opentime && $opt_opentime_combined);
usage(1) if $opt_help;

XMLTV::Ask::init($opt_gui);

my $mode = XMLTV::Mode::mode('grab', # default
							 $opt_configure => 'configure'
							);

# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_za', $opt_quiet);

get_channel_mappings();
#init_cookies();

if ($mode eq 'configure') {
	mode_configure();
}
my @config_lines; # used only in grab mode
@config_lines = XMLTV::Config_file::read_lines($config_file);

# Whatever we are doing, we need the channels data.
my @channels;
my %channels;

#######################################
# Ignore the mess for now - will be sorted out soon
die if $mode ne 'grab' and $mode ne 'list-channels';

# Options to be used for XMLTV::Writer.
my %w_args;
if (defined $opt_output) {
	my $fh = new IO::File(">$opt_output");
	die "cannot write to $opt_output: $!" if not defined $fh;
	$w_args{OUTPUT} = $fh;
}
$w_args{encoding} = 'ISO-8859-1';
my $writer = new XMLTV::Writer(%w_args);
$writer->start($HEAD);

if ($mode eq 'list-channels') {
	# Write channels mode.
	$writer->write_channel($_) foreach @ch_all;
	$writer->end();
	exit();
}

######################################################################
# We are producing full listings.
die if $mode ne 'grab';

# Read configuration.
my $line_num = 1;
foreach (@config_lines) {
	++ $line_num;
	next if not defined;
	s/#.*//g;
	next if /^\s+$/;
	s/\s+$//g;
    if (/^channel/) {
    	my (undef, $chanid, $name) = split(/\s+/, $_, 3);
	    $channels{$chanid} = {'name' => $name, 'id' => $chanid};
    }
    if (/^option/) {
    	my (undef, $conf_option, $conf_value) = split(/\s+/, $_, 3);
	    if ($conf_option eq 'opentime') {$opt_opentime = 1;}
	    if ($conf_option eq 'opentime-combined') {$opt_opentime_combined = 1;}
	    if ($conf_option eq 'days') {$opt_days = $conf_value;}
	    if ($conf_option eq 'retries') {$opt_retries = $conf_value;}

        die 'config file: number of days must not be negative' 
        	if (defined $opt_days && $opt_days < 0);
        die 'config file: number of days can only be 1, 7, 14 or 30' 
        	if (defined $opt_days && $opt_days !~ /^(1|7|14|30)$/);
        die 'config file: --opentime and --opentime-combined are mutually exclusive' 
        	if (defined $opt_opentime && $opt_opentime_combined);


    }
}
if ($opt_days == 1) {$opt_days = 0;}

######################################################################
# begin main program


# Print out the channels
die "No channels specified, run me with --configure first\n"
  if not keys %channels;

foreach my $chanid (keys %channels) {
	my $n=$channels{$chanid}->{'name'};
	my $ch_xid="$chanid.dstv.com";
	$writer->write_channel({ id => $ch_xid, 'display-name' => [ [ $n ] ] });
	if ($n eq 'M-Net' && $opt_opentime_combined) {
    	$ch_xid="$chanid-o.dstv.com";
        $n.=" Opentime";
    	$writer->write_channel({ id => $ch_xid, 'display-name' => [ [ $n ] ] });
    }
}

my $bar = new XMLTV::ProgressBar('getting listings', (scalar keys %channels))
  if not $opt_quiet;
foreach (keys %channels) {
	process_html($channels{$_});
	update $bar if not $opt_quiet;
}
$bar->finish() if not $opt_quiet;
$writer->end();

######################################################################
# subroutine definitions

# Use Log::TraceMessages if installed.
BEGIN {
	eval { require Log::TraceMessages };
	if ($@) {
		*t = sub {};
		*d = sub { '' };
	}
	else {
		*t = \&Log::TraceMessages::t;
		*d = \&Log::TraceMessages::d;
		Log::TraceMessages::check_argv();
	}
}

sub tidy( $ ) {
	for (my $tmp = shift) {
		if (not defined $tmp) { return };
        tr/\t\205/ /d;
		s/([^\012\015\040-\176\240-\377]+)//g;
		return $_;
	}
}

####
# process_table: fetch a URL and process it
#
# arguments:
#	Date::Manip object giving the day to grab
#	xmltv id of channel
#	katso id of channel
#
# returns: list of programme hashes to write
#
sub process_html {
	my $inhash = shift;
	my $chanid = $inhash->{'id'};
	my $name = $inhash->{'name'};

	my $now = time();
	my $data;
    my $tries = 0;
    if ($opt_cache) {
        my $cachefile = "/tmp/tv_grab_za-cache-$chanid";
    	if (! -f $cachefile) {
    		$data=tidy(get_dstv_nice($name));
    		open CACHE, ">$cachefile";
    		print CACHE $data;
    		close CACHE;
    	} else {
    		open CACHE, $cachefile;
    		my @data = <CACHE>;
    		close CACHE;
    		$data = join("", @data);
    	}
    } else {
        $data = tidy(get_dstv_nice($name));
    }

	if (not defined $data) {
		warn "\nskipping $name (maximum retries)";
        return;
	}

	# parse the page to a document object
	my $tree = HTML::TreeBuilder->new();
	$tree->parse($data);
	my ($prev_r, $r, $prev_time);
	
   	my @array_ot;

	# Find the date headers on the page
	my @date_headers = $tree->look_down(_tag => "td", class => 'srch_date_chnl_head');
	foreach my $td (@date_headers) {
		my $date = $td->as_text();
		$date =~ s/^[^\w]+//g;
		
		
		my $table = $td->look_up(_tag => "table");
		my @times = $table->look_down(_tag => "td", class => 'srch_rslt1');
		foreach my $result (@times) {
			$result = $result->parent();
			
			my $temp;
			
			$temp = $result->look_down(_tag => "td", class => 	'srch_rslt1')->as_HTML;
			$temp =~ /\<b\>(.*)\<\/b\>/;
			my $time = $1;
			
			my $title = $result->look_down(_tag => "td", class => 'srch_rslt2')->look_down(_tag => "b")->as_text;
			$temp = $result->look_down(_tag => "td", class => 'srch_rslt2')->as_HTML;
			$temp =~ /Rating: \((.+)\)\<br\>/;
			my $rating = $1;
			$temp =~ /Duration: ([0-9:]+)/;
			my $duration = $1;
			
			t "$title: $rating: $duration\n";
			
			$temp = $result->look_down(_tag => "td", class => 	'srch_rslt4');
			my $desc = ($temp->content_list())[0];
			$desc =~ s/(^\s+|\s+$)//g;
			t "---\n$desc\n---\n";
			
			my $start = gen_start_time($date, $time, $now);
			
			# Try to get full title from description if title seems cut off
			if ($title =~ /\.\.\.$/ ) {
				   $title =~ s/\.\.\.$//g;
				  # Try get full title from description;
				 if ($desc =~ /^'(${title}[^\.]+[^\'])'?\.\s+(.+)/) {
					   t "REMAPPING TITLE from $title to $1";
					$title = $1;
					$desc = $2;
					  t "New desc = $desc";
				}
			}
			
			my $subtitle = undef;
			my $year = undef;
			my $actors = undef;
			my $director = undef;
			my $writers = undef;	   # Unused right now
			my $commentators = undef;  # Unused right now
			my $category = undef;

				
			if ($desc =~ /^'([^\.]+)'\.\s+(.+)/) {
				$subtitle = $1;
				$desc = $2;
				t "FOUND EPISODE TITLE: $subtitle";
				t "Title: $title";
				t "New desc = $desc";
				$category = "series";
			}
			
			if ($desc =~ /^Aka ([^\.]+)\. (.*)/) {
				$desc = $2;
				my $aka = $1;
				t "Aka found: $aka\n";
				# TODO - do something with the aka
			}
			
			if ($desc =~ /(.*)\. HI Subtitles$/) {
				$desc = $1;
				t "REMOVING Subtitle string";
				# TODO: Encode subtitles in output
			}
				
			if ($desc =~ /(.*) \((\d{4})\)\s*([^\.]+)\.?\s*$/) {
				$year = $2;
				$director = $3;
				$desc = $1;
				t "desc = $desc\n";
				t "Year = $year\n";
				t "Director = $director\n";
			}
			
			if ($desc =~ /(.*) \((\d{4})\)\s*$/) {
				$desc = $1;
				$year = $2;
				t "desc = $desc\n";
				t "Year = $year\n";
			}
			
			if (defined $year && $desc =~ /(.*\.)\s+([^\.]+ [A-Z][^\.]+)\.\s*/) {
				$desc = $1;
				$actors = $2;
				if (defined $actors) {
					$actors =~ s/^\s+//g;
					$actors =~ s/\s+$//g;
					my @a = split(/,\s+/, $actors);
					$actors = [];
					foreach my $a (@a) {
						push @$actors, $a;
					}
				}
				$category = "movie";
			}

			# Trim whitespace from elements
			$title =~ s/(^\s+|\s+$)//g;
			$desc =~ s/(^\s+|\s+$)//g;
			$subtitle =~ s/(^\s+|\s+$)//g if $subtitle;

			# Fix "Press 'i'" entries
            if ($title =~ /^Press .i.$/) {
                $title = $subtitle;
                $subtitle = undef;
            }

			$r = undef;
			$r->{title} = [[$title]];
			$r->{'sub-title'} = [[$subtitle]] if $subtitle;
			$r->{rating} = [[$rating, "DSTV"]];
			$r->{start} = $start;
			$r->{channel} = "$chanid.dstv.com";
			$r->{desc} = [[$desc]];
			$r->{category} = [[ $category, 'en' ]] if $category;
				
			# credits
			my %c;
			$c{director} = [ $director ] if $director;
			$c{actor} = $actors if $actors;
			$c{writer} = $writers if $writers;
			$c{commentator} = $commentators if $commentators;
			$c{director} = [ $director ] if $director;
			$r->{date} = $year if $year;

			$r->{credits} = \%c if %c;
				
			if (defined $prev_r) {
				$prev_r->{stop} = $start;

				my $write = 1;

				my ($hr, $min) = split(/:/, $time);
				my ($prev_hr, $prev_min) = split(/:/, $prev_time);
				if ($name eq 'M-Net' && ($opt_opentime || 
                        $opt_opentime_combined)) {
					if ($hr <= 17) { # $prev ends before 17:00
						$write = 0;
					}
					if ($prev_hr >= 19) { # $prev starts after 19:00
						$write = 0;
					}
				}
				if ($name eq 'M-Net' && $opt_opentime_combined) {
                    $writer->write_programme($prev_r);
                    if ($write == 1) {
                        $prev_r->{channel} = "$chanid-o.dstv.com";
                        push @array_ot, $prev_r;
                    }
				} elsif ($write == 1) {
					$writer->write_programme($prev_r);
				}
			}
			$prev_time = $time;
			$prev_r = $r;

		}
	}
    # Write opentime-combined data
    if (@array_ot) {
        for my $ot_prog ( @array_ot ) {
            $writer->write_programme($ot_prog);
        }
        @array_ot = undef;
        
    }

}

# get channel listing
sub get_channels {
	my $bar;


	$bar = new XMLTV::ProgressBar('getting list of channels', 1)
	  if not $opt_quiet;
	my %channels;
	my $url="http://www.dstv.com/main.aspx?ID=136";
	my $local_data=get_nice($url);
	die "could not get channel listing $url, aborting\n"
	  if not defined $local_data;

	# FIXME commonize this
	local $SIG{__WARN__} = sub {
		warn "$url: $_[0]";
	};
	local $SIG{__DIE__} = sub {
		die "$url: $_[0]";
	};
	
	my $tree = HTML::TreeBuilder->new();
	$tree->parse($local_data);

	# all channel elements are options inside the ChannelID select

	my @list = $tree->look_down(
		_tag   => 'img',
		class => 'artcl_img',
		height => '70',
	);
	foreach my $entry (@list) {
		my $table = $entry->parent()->parent()->parent();
		
		my $temp   = $table->look_down(_tag => 'a', class => 'img_btn') or next;
		my $name   = $temp->look_down(_tag => 'b')->as_text();
		my $chanid = $temp->parent->look_down(_tag => 'i')->as_text();
#        next;
		my $tempopt  = $table->look_down(_tag => 'select') or next;
#		$tempopt->attr('onchange') =~ /GoToSchedule\((\d+),this\.value\)/;
#		my $optid = $1;
		
		$channels{$chanid} = {'name' => $name, 'id' => $chanid};
	}
	
	die "no channels could be found" if not keys %channels;
	update $bar if not $opt_quiet;
	$bar->finish() if not $opt_quiet;
	return %channels;
}

# Bump a YYYYMMDD date by one.
sub nextday {
	my $d = shift;
	my $p = parse_date($d);
	my $n = DateCalc($p, '+ 1 day');
	return UnixDate($n, '%Q');
}

sub mode_configure {

	XMLTV::Config_file::check_no_overwrite($config_file);
	%channels = get_channels();

	open(CONF, ">$config_file") or die "cannot write to $config_file: $!";

	# Ask about each channel.
	my @chs = sort {uc($channels{$a}->{'name'}) cmp uc($channels{$b}->{'name'})} keys %channels;
	my @qs = map { "add channel '$channels{$_}->{name}'?" } @chs;
	my @want = ask_many_boolean(1, @qs);
    my $handle_mnet;
	foreach (@chs) {
		my $w = shift @want;
			warn("cannot read input, stopping channel questions"), last
			  if not defined $w;

			# Print a config line, but comment it out if channel not wanted.
			print CONF '#' if not $w;
			my $name = $channels{$_}->{'name'};
			print CONF "channel $_ $name\n";
            if ($name eq 'M-Net' && $w) {
                $handle_mnet = 1
            }
	}

    if ($handle_mnet) {
        if (ask_boolean( "Retrieve Opentime and full M-Net schedule?")) {
        	print CONF "option opentime-combined 1\n";
        } 
        elsif (ask_boolean( "Retrieve only Opentime?")) {
        	print CONF "option opentime 1\n";
        }
    }
    my @choices = (1,7,14,30);
    my $days = ask_choice("Number of days to retrieve",$choices[2], @choices);
    print CONF "option days $days\n";
    
    my $retries;
    $retries = ask("Number of retries for failed downloads? ",$retries);
    print CONF "option retries $retries\n";

	close CONF or warn "cannot close $config_file: $!";
	say("Finished configuration.");

	exit();
}

# Initialize cookies and retrieve current channel ID's
sub get_channel_mappings {

    our %channelmap = ();
    t "refreshing channel mappings";
    my $req = GET 'http://www.dstv.com/DStv_Guide/default.aspx';
    $req->header('Accept-Encoding','gzip');

    # Make the request
    my $res = $ua->request($req);

    # Unpack
    if (($res->headers()->header('Content-Encoding')) && 
        ($res->headers()->header('Content-Encoding') eq 'gzip')) {
            $res->content(Compress::Zlib::memGunzip($res->content));
    }

    # Check the response
    if ($res->is_success) {
    	my $chantree = HTML::TreeBuilder->new();
    	$chantree->parse($res->content);

    	my $chanselect = $chantree->look_down(_tag => 'select', id => 'Channel');
      	my @chan_list = $chanselect->look_down(_tag => "option");
    	foreach my $chanentry (@chan_list) {
            $channelmap{$chanentry->as_text} = $chanentry->attr('value') if ($chanentry->as_text =~ /^[^-]/);
        }
    }
}

# Download listings for a channel name - refresh mappings if necessary
sub get_dstv_nice() {
	my $channame = shift;
    my $data;
    my $tries = 0;
    my $req;
    my $res;
    while ($tries < $opt_retries && not defined $data) {
        $tries++;
        my $url = "http://www.dstv.com/DStv_Guide/default.aspx?Channel=$channelmap{$channame}&time=$opt_days&submit=true&Channels";
    	t "getting URL: $url";
        $req = GET $url;
        $req->header('Accept-Encoding','gzip');
        $req->header('Referer','http://www.dstv.com/DStv_Guide/default.aspx');
        $res = $ua->request($req);
        if ($res->status_line =~ /302/) {
            # Invalid channel code - refresh mappings
            t "302 error - refreshing";
            get_channel_mappings();
        }
            
        if ($res->is_success) {
            if (($res->headers()->header('Content-Encoding')) && 
                ($res->headers()->header('Content-Encoding') eq 'gzip')) {
                    $res->content(Compress::Zlib::memGunzip($res->content));
            }
            if ($res->content =~ /No Results Found/) {
                # Cookie expired - refresh mappings
                t "No results found - refreshing cookie";
                get_channel_mappings();
            } else {
                $data = $res->content;
            }
    	}
    }
 
    return $data;
}

sub init_cookies {
	get_nice('http://www.dstv.com');
	my $bar = new XMLTV::ProgressBar('Initialising cookies', 1)
	  if not $opt_quiet;
    update $bar if not $opt_quiet;
	$bar->finish() if not $opt_quiet;
}

sub gen_start_time {
	my ($date, $time, $now) = @_;
	
	# Date = 'Friday 23 May'
	# Time = '14:00';
	# str2time sometimes gets the wrong year
	# Append the current year to the date
	# If we are in Nov or Dec, reading for Jan or Feb, year++
	my $year = (localtime($now))[5] + 1900;
	my $mon = (localtime($now))[4] + 1;
	if (($mon == 11 || $mon == 12) && ($date =~ /(January|February)/)) {
		$year++;
	}
	my $timestamp = UnixDate("$date $year $time", "%s");
#	my $timestamp = str2time("$date $year $time");
	return POSIX::strftime("%Y%m%d%H%M", localtime($timestamp));
}
