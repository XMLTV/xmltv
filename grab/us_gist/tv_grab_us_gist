#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_grab_us_gist - Grab TV listings for the USA, from an alternative
source.

=head1 SYNOPSIS

tv_grab_us_gist --help

tv_grab_us_gist [--config-file FILE] --configure

tv_grab_us_gist [--config-file FILE] [--output FILE] [--days N] [--offset N]
                [--quiet]

=head1 DESCRIPTION

Output TV listings for a particular user account at the US listings
site gist.com.  At the moment you need to manually register for an
account at that site and choose the channels to download using their
web interface.

The normal grabber for US listings is B<tv_grab_na>, but you might
prefer the data returned by this one.

=head1 SETUP

At the moment to set up this grabber you must register by hand at the
site.  Once you have logged in, find your user id by doing 'view
source' in your web browser and look near the bottom of the file for a
line such as

    <font COLOR=WHITE>Userid=5094954 profileid=1</font><br>

Then run B<tv_grab_us_gist --configure> and enter the number shown, in
this case, 5094954.  The channels fetched by the grabber will be those
you set up during registration.  You also need to enter a timezone:
listings will be converted to this timezone before downloading.

I donE<39>t know what the difference is between the ordinary,
free-of-charge gist.com subscription and the pay 'Gist Gold' service.
ItE<39>s possible that to customize the list of channels you must take
the pay service - otherwise you may be stuck with the default setting
of all channels for the region you selected.  Also, it may be that
Gold subscribers can fetch listings for more days.

Once you have set up the account and configured the grabber, no more
manual intervention should be necessary.

=head1 OPTIONS

B<--configure> Prompt for which stations to download and write the
configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_us_gist.conf>.  This is the file written
by B<--configure> and read when grabbing.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days starting from today, rather than as many as
possible.

B<--offset N> start grabbing N days from today, rather than starting
today.  N may be negative.

B<--quiet> suppress the progress messages normally written to standard
error.

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.gist.com/tv/xmltv/intro.jsp>

=head1 AUTHOR

Ed Avis, ed@membled.com

=head1 BUGS

It should be possible to fully automate the registration process.

=cut

use strict;
use LWP::UserAgent;

# First we give some support routines.

# Use Compress::Zlib if installed, else spawn external gzip.
#
# This code is copied from tv_grab_de, it could be made into a
# library.  But then again it only exists as a workaround for not
# having the real Compress::Zlib library.
#
# FIXME Compress::Zlib is standard with perl 5.8.0, remove this?
#
use File::Temp;
sub my_gunzip {
    my ($fh, $fname) = File::Temp::tempfile();
    print $fh $_[0] or die "cannot write to $fname: $!";
    close $fh or die "cannot close $fname: $!";
    open(GZIP, "gzip -d <$fname |") or die "cannot run gzip: $!";
    local $/ = undef;
    my $r = <GZIP>;
    close GZIP or die "cannot close pipe from gzip: $!";
    unlink $fname or die "cannot unlink $fname: $!";
    return $r;
}
BEGIN {
    eval { require Compress::Zlib };
    if ($@) { *gunzip = \&my_gunzip }
    else {
	# eval()ed to quieten 'used only once' warning if the module
	# was not loaded.
	#
	eval '*gunzip = \*Compress::Zlib::memGunzip';
    }
}

# Fetch a page.  This code is necessary because I can't seem to
# persuade libwww-perl to do transparent 'deflate' decompression.
#
sub get_deflate( $ ) {
    my $url = shift;

    my $ua = new LWP::UserAgent();
    my $req = HTTP::Request->new(GET => $url);
    $req->header('Accept-Encoding' => [ 'deflate', 'gzip' ]);
    my $res = $ua->request($req);
    if (not $res->is_success()) {
	warn "$url: could not fetch, result code $res";
	return undef;
    }
    my $c = $res->content();
    local $_ = gunzip($res->content());
    if (not defined) {
	warn "$url: could not gunzip";
	return undef;
    }
    return $_;
}

# We work by inheriting from XMLTV::Grab_XML and overriding certain
# methods.
#
use XMLTV::Grab_XML;
package Grab_XML_us_gist;
use base 'XMLTV::Grab_XML';
sub configure();

use Date::Manip;
use XMLTV::Ask;
use XMLTV::Config_file;
use XMLTV::TZ qw(tz_to_num);

# Main program.  Get some of the options (but most are handled in the
# superclass).
#
use Getopt::Long;
my $opt_configure = 0;
my $opt_config_file;
Getopt::Long::Configure('pass_through');
my $r = GetOptions('configure'     => \$opt_configure,
		   'config-file=s' => \$opt_config_file);
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_us_gist');
my ($userid, $tz); # set by reading config
if ($opt_configure) {
    die Grab_XML_us_gist->usage_msg() if @ARGV;
    configure();
}
else {
    Grab_XML_us_gist->go();
}
exit();

sub configure() {
    XMLTV::Config_file::check_no_overwrite($config_file);
    # We might as well use the globals $userid and $tz here.
    for (;;) {
	$userid = ask('Enter your gist.com user id (a number): ');
	die "failed to read response\n" if not defined $userid;
	last if $userid =~ /^\d+$/;
	print "bad user id, please enter a string of digits\n";
    }
    my $tz_str;
    for (;;) {
	$tz_str = ask('What timezone should be used? ');
	die "failed to read response\n" if not defined $tz_str;
	$tz = tz_to_num($tz_str);
	if (defined $tz) {
	    print "Using timezone $tz_str, $tz.\n";
	    last;
	}
	print "bad timezone, try something like '-0500' or 'EDT'\n";
    }
    open(FH, ">$config_file")
      or die "cannot write to $config_file: $!";
    print FH "userid $userid\n";
    print FH "tz $tz\n";
    close FH or die "cannot close $config_file: $!";
    print "All done, run with no arguments to grab listings.\n";
}

# Below here are package methods for Grab_XML_us_gist, overriding
# those from the superclass.
#
sub country( $ ) {
    my $pkg = shift;
    return 'USA';
}

# Todo: perhaps we should internationalize messages and docs?
sub usage_msg( $ ) {
    my $pkg = shift;
    my $country = $pkg->country();
    return <<END
$0: get $country television listings in XMLTV format
To configure: $0 [--config-file FILE] --configure
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N] [--offset N] [--quiet]
END
      ;
}

# Returns a hash mapping YYYMMDD to URL.  Uses global $userid and $tz.
sub urls_by_date( $ ) {
    my $pkg = shift;
    my $num_days = 7; # guess
    my $date = UnixDate(ParseDate('today'), '%Q');
    my %urls;
    while ($num_days--) {
	$urls{$date} = "http://www.gist.com/tv/xmltv/?userid=$userid&date=$date&tz_offset=$tz";
	print STDERR "$urls{$date}\n";
	$date = $pkg->nextday($date);
    }
    return %urls;
}

# Return XML data from a URL.
sub get( $$ ) {
    my ($pkg, $url) = @_;
    return ::get_deflate($url);
}

sub cachables( $ ) {
    my $pkg = shift;
    return ($pkg->SUPER::cachables(), '::get_deflate');
}

# Given some data downloaded for a particular day, turn it into XML.
sub xml_from_data( $$ ) {
    my $pkg = shift;
    my @lines = split /\n/, shift;
    my @r;
    while (@lines) {
	local $_ = shift @lines;
	push @r, $_;
	if (/<credits>/) {
	    my @l;
	    my $end_line;
	    while (@lines) {
		local $_ = shift @lines;
		if (m!</credits>!) {
		    $end_line = $_;
		    last;
		}
		push @l, $_;
	    }
	    die 'EOF before </credits> line' if not defined $end_line;
	    my %correct = (host => 'presenter',
			   executive_producer => 'producer',
			   guest_star => 'guest',
			  );
	    foreach (@l) {
		foreach my $from (keys %correct) {
		    my $to = $correct{$from};
		    if (s/<$from>/<$to>/) {
			s!</$from>!</$to>!
			  or warn "didn't see </$from> on same line as <$from>\n";
		    }
		}
	    }
	    my @sorted;
	    foreach my $person (qw(director actor writer adapter producer
				   presenter commentator guest)) {
		my @new_l;
		foreach (@l) {
		    if (index($_, "<$person>") != -1) {
			push @sorted, $_;
		    } else {
			push @new_l, $_;
		    }
		}
		@l = @new_l;
	    }
	    foreach (@l) {
		warn "ignoring unknown credit: $_";
	    }
	    push @r, (@sorted, $end_line);
	}
    }

    return join("\n", @r);
}

# Read the configuration data and set global variables $userid and $tz.
sub go( $ ) {
    my $pkg = shift;
    my $line_num = 0;
    foreach (XMLTV::Config_file::read_lines($config_file)) {
	++ $line_num;
	next if not defined;
	my $where = "$config_file:$line_num";
	if (/^userid\s+(\d+)$/) {
	    warn "$where: seen userid before\n" if defined $userid;
	    $userid = $1;
	}
	elsif (/^tz\s+([+-]\d{4})$/) {
	    warn "$where: seen tz before\n" if defined $tz;
	    $tz = $1;
	}
	else {
	    die "$where: bad line\n";
	}
    }
    $pkg->SUPER::go();
}

